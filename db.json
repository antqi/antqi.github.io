{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/cards/source/css/dark.styl","path":"css/dark.styl","modified":0,"renderable":1},{"_id":"themes/cards/source/css/github.min.css","path":"css/github.min.css","modified":0,"renderable":1},{"_id":"themes/cards/source/css/note.styl","path":"css/note.styl","modified":0,"renderable":1},{"_id":"themes/cards/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cards/source/js/b2t.js","path":"js/b2t.js","modified":0,"renderable":1},{"_id":"themes/cards/source/js/darkmode.js","path":"js/darkmode.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/cards/.gitignore","hash":"f875b6524d4c61e5de0a1d9efdec1fe451d7bc07","modified":1593098291071},{"_id":"themes/cards/README.md","hash":"c5c0e8c59928ef9857fd3eb84c790fb18871c027","modified":1593098291072},{"_id":"themes/cards/LICENSE","hash":"98492416802a4cf078ed983cf4749bd4608c8afe","modified":1593098291072},{"_id":"themes/cards/_config.yml","hash":"2ef4ab30213fab2a37396bbdf22eb8e6e4bc09ef","modified":1593098909259},{"_id":"themes/cards/package.json","hash":"4f4b1320ee911668473a658c83dfb574ef248ef3","modified":1593098291086},{"_id":"themes/cards/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1593098291075},{"_id":"themes/cards/languages/en.yml","hash":"92f11e826cb92c806e8fef562790bc06224a0930","modified":1593098291076},{"_id":"themes/cards/languages/zh-CN.yml","hash":"8221de3ded465af97ae0dc72a9cc902a3a164917","modified":1593098291076},{"_id":"themes/cards/languages/zh-TW.yml","hash":"16945b14573c6374eebb2002d73f385f46fac072","modified":1593098291076},{"_id":"themes/cards/layout/archive.ejs","hash":"f174f1eeba56d4f06b2587b869cd07d4d80c1953","modified":1593098291084},{"_id":"themes/cards/layout/category.ejs","hash":"26a50024379b3af47469b2a26349f7adc8c7805c","modified":1593098291085},{"_id":"themes/cards/layout/index.ejs","hash":"a041f01103d542b15a4bc624e74003e6f050ecc9","modified":1593098291085},{"_id":"themes/cards/layout/layout.ejs","hash":"57faead97691021f5b209a2ca66470c8cb4f35f6","modified":1593098291085},{"_id":"themes/cards/layout/links.ejs","hash":"f72900abac66625d1f8042d90c1cf79859a6ca40","modified":1593098291085},{"_id":"themes/cards/layout/page.ejs","hash":"fd95d5b204a5d92f2b9ae4bc0f0ce1995a26b040","modified":1593098291086},{"_id":"themes/cards/layout/post.ejs","hash":"fd95d5b204a5d92f2b9ae4bc0f0ce1995a26b040","modified":1593098291086},{"_id":"themes/cards/layout/tag.ejs","hash":"240702efd0b3463a7e22d2ef9c1cb032f6d3af71","modified":1593098291086},{"_id":"source/_posts/HTTP/HTTP-长连接.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593054624406},{"_id":"source/_posts/HTTP/HTTP-cookie&session.md","hash":"0e232e2f84900f9ae5784b8bdb3f63444124f12c","modified":1593054624403},{"_id":"source/_posts/HTTP/HTTP-缓存.md","hash":"fd6bdeea31d02c6701ffc74c49845b1fb02d1a55","modified":1593054624406},{"_id":"source/_posts/HTTP/HTTP历史.md","hash":"1b3db368231957d2e93a47427c6897df6752625a","modified":1593054624407},{"_id":"source/_posts/HTTP/HTTP报文.md","hash":"65f2b9886c4b2e54a9099736d8d1ba5c4d7d7231","modified":1593054624407},{"_id":"source/_posts/HTTP/HTTP的三次握手.md","hash":"bc90006e5bff0e6bf14d6e6f8b334911d8a5b0d4","modified":1593054624407},{"_id":"source/_posts/HTTP/URI URL URN.md","hash":"fe830c7a8ef5d91f96e78d0148c737484672704b","modified":1593054624408},{"_id":"source/_posts/HTTP/在地址栏输入URL后发生了什么.md","hash":"b570c0341ead8798bcf13e498149c599bdf62eb3","modified":1593054624408},{"_id":"source/_posts/HTTP/数据协商.md","hash":"d2063cfc15c31453223e6dd3077d24f90bb8e26f","modified":1593054624408},{"_id":"source/_posts/HTTP/浏览器的安全策略.md","hash":"a52cd1e9484ba8dd298170dbf55fd36d145dd64e","modified":1593054624408},{"_id":"source/_posts/JavaScript模块化/AMD.md","hash":"b97f8c007ca642bef94a3d712886b9605e181fc3","modified":1593054624410},{"_id":"source/_posts/JavaScript模块化/模块化的规范.md","hash":"c8af94c849c72260ca1e5fa3a2ef9dfbc04d620d","modified":1593054624410},{"_id":"source/_posts/JavaScript模块化/CommonJS.md","hash":"578b96f75371807ebb17b7ebf388ccb944855753","modified":1593098423532},{"_id":"source/_posts/JavaScript模块化/模块化进程.md","hash":"f4b3e67e42b7154caba485098a667bb731128ef6","modified":1593054624411},{"_id":"source/_posts/LEVEL 1/.DS_Store","hash":"65a323e564d7baae5c915db7151ee8e865486166","modified":1593054624411},{"_id":"source/_posts/LEVEL 1/构建知识体系.md","hash":"6c4d9ff21aa86c34b1b2cdd67928ddbcae238ab6","modified":1593054624440},{"_id":"source/_posts/javascript/print-i-one-time.md","hash":"ebd99910e84b9b0a92a68e121bcd117551759641","modified":1593054624445},{"_id":"source/_posts/javascript/this.md","hash":"fa9609ccd4eeb9d460a2fcecdf8f72c534a476d8","modified":1593054624446},{"_id":"source/_posts/javascript/作用域.md","hash":"43a3811b695bad4a7bb363abd44c0b82f6025305","modified":1593054624446},{"_id":"source/_posts/javascript/函数.md","hash":"7412e15ca6c5abfd00acebe8f15860bfd49cac1d","modified":1593054624447},{"_id":"source/_posts/javascript/原型.md","hash":"2c22b0cf09551cae9aac9e41f93d687688a40fd1","modified":1593054624447},{"_id":"source/_posts/javascript/对象.md","hash":"6125877165322fbb86b5a14f84bec1ecfe18703f","modified":1593054624447},{"_id":"source/_posts/自定义Promise/.DS_Store","hash":"613ebb5ed52bbfdb4d3057c4f56f6759185f63b9","modified":1593054624448},{"_id":"source/_posts/自定义Promise/01-准备.md","hash":"42cffb215fad00ecad31329106b7bdeeefc405e8","modified":1593054624448},{"_id":"source/_posts/自定义Promise/02-Promise的理解和使用.md","hash":"48695cd2f4684963b5bb09816885bce5b403da2b","modified":1593054624449},{"_id":"source/_posts/自定义Promise/03-Promise API.md","hash":"f1e983359205169b9d413ff24a5d1bd25b17dc64","modified":1593054624449},{"_id":"source/_posts/自定义Promise/04-promise中的关键问题.md","hash":"6b4b06c154274027958e91741c119e9df7563388","modified":1593054624449},{"_id":"source/_posts/自定义Promise/05-自定义Promise.md","hash":"1c2aaaf40a43d51a452b5af93ff179f3de4e6096","modified":1593054624450},{"_id":"source/_posts/自定义Promise/06-自定义Promise-class版本.md","hash":"e15d34b2e31a4755f27f04ec34bd31ef50978640","modified":1593054624450},{"_id":"source/_posts/自定义Promise/07-async&await.md","hash":"952c0db479c1d47778514b61e0021c8b0d7678bf","modified":1593054624451},{"_id":"source/_posts/自定义Promise/Event Loop.md","hash":"ce819729434e98e0059ebd0d9e8eff6dfce144ce","modified":1593054910762},{"_id":"source/_posts/自定义Promise/宏任务和微任务.md","hash":"980c63358dca17dcb7e431924d025ef4bdb1595f","modified":1593054869800},{"_id":"themes/cards/dist/css/dark.css","hash":"7e318cd843aa8e6b3718f8ca0a1f3f173cbd581d","modified":1593098291073},{"_id":"themes/cards/dist/css/dark.min.css","hash":"b191f762402bb6f6ee77d325a84d1557f3db84a3","modified":1593098291073},{"_id":"themes/cards/dist/css/github.css","hash":"4729df37598a602922605dcf653cb26fc9028c80","modified":1593098291073},{"_id":"themes/cards/dist/css/github.min.css","hash":"3bb8dc45fb4e714153845e35020b7ba94519eb36","modified":1593098291073},{"_id":"themes/cards/dist/css/note.css","hash":"f166507392731b42a8d433643c21d96e9a3b46a1","modified":1593098291074},{"_id":"themes/cards/dist/css/note.min.css","hash":"86876eb46557725d4db87485037f11942396e274","modified":1593098291074},{"_id":"themes/cards/dist/css/style.css","hash":"49c86c0d36ca1b4fc41221fb7e78b54b8a9d914c","modified":1593098291074},{"_id":"themes/cards/dist/css/style.min.css","hash":"b24a79cf46371ab679017de31f594add8bf57898","modified":1593098291074},{"_id":"themes/cards/dist/js/b2t.js","hash":"322260f1aa64c16d8c04a1e53f7b7675431a3268","modified":1593098291075},{"_id":"themes/cards/dist/js/b2t.min.js","hash":"61b89ca7234e1ae94f7fbd4eefab87d89a8472c2","modified":1593098291075},{"_id":"themes/cards/dist/js/darkmode.js","hash":"1f36e3ba413c2825f08a7e2ec69e61bf305a9188","modified":1593098291075},{"_id":"themes/cards/dist/js/darkmode.min.js","hash":"dbd3875a11e020e9a12eaaee79d228829cb35779","modified":1593098291075},{"_id":"themes/cards/layout/_meta/categories.ejs","hash":"418a5f98b7f5104aae9ffbff68be95a9ddaeed2f","modified":1593098291076},{"_id":"themes/cards/layout/_meta/category.ejs","hash":"5accb9e217ba1b1e0e005010f7a10ac484455b5d","modified":1593098291077},{"_id":"themes/cards/layout/_meta/copyright.ejs","hash":"bbd69a3601c4535cccab9c35f99eb85d53ddeb71","modified":1593098291077},{"_id":"themes/cards/layout/_meta/date.ejs","hash":"58131fd88a69cc6cdccaa9344cb76efe8dd13f11","modified":1593098291077},{"_id":"themes/cards/layout/_meta/expire.ejs","hash":"89dcc04c099d97151b253b1ff5dd9fea4c1227ac","modified":1593098291077},{"_id":"themes/cards/layout/_meta/tags.ejs","hash":"480ea52f6aabf8a8ed5ce40269b646453fada5d5","modified":1593098291078},{"_id":"themes/cards/layout/_meta/thumbnail.ejs","hash":"8b6201d3c62779421d72c8f5ff0c2b9b7e6433af","modified":1593098291078},{"_id":"themes/cards/layout/_meta/updated.ejs","hash":"e54fab27ee7adabe2c660c3ca2186237ddde0717","modified":1593098291079},{"_id":"themes/cards/layout/_partial/archive.ejs","hash":"48b854c8fef0f9fc6762cfd45c7497ecce5fb206","modified":1593098291079},{"_id":"themes/cards/layout/_partial/article.ejs","hash":"477a5167e19aa77dd87186b8535d1ba760bda67a","modified":1593098291080},{"_id":"themes/cards/layout/_partial/cover.ejs","hash":"64beda0ac444a68ed38d5c8f493f24cfeffca15f","modified":1593098291080},{"_id":"themes/cards/layout/_partial/footer.ejs","hash":"f6d52ef26aa64d99e47a60c778c2eecdb95ae8b7","modified":1593098291080},{"_id":"themes/cards/layout/_partial/head.ejs","hash":"d7091fa7bfd839e5acf0f4feca0e6dce5d5cffd2","modified":1593098291081},{"_id":"themes/cards/layout/_partial/header.ejs","hash":"3e53b1d140d6f3fc756717769b0d706e4eb64c24","modified":1593098291081},{"_id":"themes/cards/layout/_partial/post.ejs","hash":"f4d199f7a2949b82904ca3391bfbb9bcf5c3acb6","modified":1593098291081},{"_id":"themes/cards/layout/_partial/scripts.ejs","hash":"cee40beaf879f5f0c742ef43e2169ea54d78fbfb","modified":1593098291082},{"_id":"themes/cards/layout/_third-party/analytics.ejs","hash":"2fd6224b3373f25ba238fa91c9f3711b64b76ad1","modified":1593098291082},{"_id":"themes/cards/layout/_third-party/busuanzi.ejs","hash":"4ad939d654dac56ecea0756e021d98f84d798c33","modified":1593098291083},{"_id":"themes/cards/layout/_third-party/comments.ejs","hash":"fcc6feab4b34cfc03020a418c4d5cf322a638ae8","modified":1593098291083},{"_id":"themes/cards/layout/_third-party/fancybox.ejs","hash":"8e1993956c0fb3795c31dfdf6718f10720cd479e","modified":1593098291084},{"_id":"themes/cards/layout/_third-party/mathjax.ejs","hash":"1fd2a13dbe23c13b2858b0ad9555eecb9fa8e056","modified":1593098291084},{"_id":"themes/cards/scripts/events/index.js","hash":"cff2f9ea85a9a9c689f2fe1bcebc67b9f2535155","modified":1593098291087},{"_id":"themes/cards/scripts/lazyload/index.js","hash":"5b564efd522ad9f7290a70091320ec94a7d48c0c","modified":1593098291088},{"_id":"themes/cards/scripts/tags/note.js","hash":"df687dea68e23e9da39f8abf00cff4e700926e28","modified":1593098291089},{"_id":"themes/cards/source/css/dark.styl","hash":"b07d325d33224809306419409f0f96307914462f","modified":1593098291094},{"_id":"themes/cards/source/css/github.min.css","hash":"3bb8dc45fb4e714153845e35020b7ba94519eb36","modified":1593098291094},{"_id":"themes/cards/source/css/note.styl","hash":"961c8e1817d57b0ece8fce0249a7ebb8bb7aab31","modified":1593098291094},{"_id":"themes/cards/source/css/style.styl","hash":"7107aeed239ee26d0102584dc1425852a02cfa69","modified":1593098291095},{"_id":"themes/cards/source/js/b2t.js","hash":"322260f1aa64c16d8c04a1e53f7b7675431a3268","modified":1593098291095},{"_id":"themes/cards/source/js/darkmode.js","hash":"1f36e3ba413c2825f08a7e2ec69e61bf305a9188","modified":1593098291096},{"_id":"source/_posts/LEVEL 1/压力管理/.DS_Store","hash":"2abf7530c88dc2926064f30b8618fe70eb96b5b2","modified":1593054624413},{"_id":"source/_posts/LEVEL 1/时间管理/《时间管理》工作与生活冲突，如何享受生活.md","hash":"b81ca11cb81b67dc3aa6017b40b71c3df28ba25a","modified":1593054624439},{"_id":"source/_posts/LEVEL 1/时间管理/如何优雅的实现时间自由.md","hash":"b6b76ded0a7171a1e790eaff71e82c9f24c5c507","modified":1593054624440},{"_id":"source/_posts/LEVEL 1/高效工作/.DS_Store","hash":"2334cf50e0e1ff6bbd02a703fb6811828ab4d1f5","modified":1593054624441},{"_id":"themes/cards/scripts/events/lib/config.js","hash":"e137a7d27c5f1036f58891d210247b4c00392ff4","modified":1593098291087},{"_id":"themes/cards/scripts/lazyload/lib/process.js","hash":"fcdcbf608f4321320b47e75f791c2a7777fb025b","modified":1593098291088},{"_id":"themes/cards/source/css/_/_darkmode.styl","hash":"17e98dd5db495af5fec065359e3d8c20e4e60472","modified":1593098291090},{"_id":"themes/cards/source/css/_/_defines.styl","hash":"d40f2da20879dacbeef1c431fe035f33a5fbceb5","modified":1593098291090},{"_id":"themes/cards/source/css/_base/base.styl","hash":"6c75b6f62ef65f326c63d5bba8c242c14cd3a17e","modified":1593098291091},{"_id":"themes/cards/source/css/_element/element.styl","hash":"9419c48ef2df92b91b882d4a3269c7a1cbb1dc99","modified":1593098291091},{"_id":"themes/cards/source/css/_layout/layout.styl","hash":"efe74019a8209c6da59aa5b007cb29c987cfc0ac","modified":1593098291092},{"_id":"themes/cards/source/css/_markdown/markdown.styl","hash":"39cf2da18a82e0c4f6189e96e3e8c8bf112450cb","modified":1593098291092},{"_id":"themes/cards/source/css/_page/links.styl","hash":"2c1903845d915b7dfa2964c2b9a8a10b946c0bf0","modified":1593098291093},{"_id":"themes/cards/source/css/_page/archives.styl","hash":"ff4ae8757f2b3a30c3084e2854fa7ea68b3d3308","modified":1593098291093},{"_id":"themes/cards/source/css/_widget/widget.styl","hash":"d80e7bb30f1778c5dbc5c2573cbe9209cb6a8361","modified":1593098291093},{"_id":"source/_posts/LEVEL 1/高效工作/4 综合案例/4.1 综合练习.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593054624444},{"_id":"source/_posts/LEVEL 1/压力管理/1 认识压力/1.1 你真的了解压力吗.md","hash":"b8adaf0ad3f4be3ab3a287dcb8c1882e8c1605bb","modified":1593054624415},{"_id":"source/_posts/LEVEL 1/压力管理/1 认识压力/1.2 为什么会感觉到压力.md","hash":"c703ec6faf2f549aacb0b0d6bc360b9ddb3390e1","modified":1593054624415},{"_id":"source/_posts/LEVEL 1/压力管理/1 认识压力/1.3 为什么有人总说压力山大.md","hash":"4b688770ef31156f08c6362386acfc9d07ada727","modified":1593054624418},{"_id":"source/_posts/LEVEL 1/压力管理/2 识别压力/2.1 揭开你的压力真面目.md","hash":"04e522995cd4922f166339ce1c818965460c2e92","modified":1593054624420},{"_id":"source/_posts/LEVEL 1/压力管理/3 应对压力/3.1 方法一：调整行为方式.md","hash":"12e24ff2a717a12b61f35bc0d0f8968264baeeeb","modified":1593054624420},{"_id":"source/_posts/LEVEL 1/压力管理/3 应对压力/3.2 方法二：改变认知方式.md","hash":"726d98b1e14916047f7299e0092175344944792d","modified":1593054624420},{"_id":"source/_posts/LEVEL 1/压力管理/3 应对压力/3.3 方法三：增加应对资源.md","hash":"673a1736cc9f1ab399dd3dc407ce51089d99938d","modified":1593054624421},{"_id":"source/_posts/LEVEL 1/压力管理/3 应对压力/3.4 方法四：提升应对能力.md","hash":"a05c2e3c176558accf148ef181db01f84345ca21","modified":1593054624422},{"_id":"source/_posts/LEVEL 1/时间管理/1 认识时间管理/1.1 时间管理的误区.md","hash":"e8f9b0204bb733835626d38fcf964b6efde107bb","modified":1593054624430},{"_id":"source/_posts/LEVEL 1/时间管理/2 了解你的时间观/2.1 津巴多时间观｜了解自己的时间观.md","hash":"63b5e8cbaca57268335ee2d95934c93d4f9c4e93","modified":1593054624431},{"_id":"source/_posts/LEVEL 1/时间管理/2 了解你的时间观/2.2 时间观察调整法｜ 如何平衡自己的时间.md","hash":"1b548b7f49e0d89a94aa5f1080aa9c82cc9409ba","modified":1593054624433},{"_id":"source/_posts/LEVEL 1/时间管理/3 诊断你的时间/3.1 时间记录法 | 了解你的时间花费，让时间变得更可控.md","hash":"d9b352acba6d48030a14dac1b019a5496c4f4b2a","modified":1593054624434},{"_id":"source/_posts/LEVEL 1/时间管理/3 诊断你的时间/3.2 关键可行矩阵 | 让你用更短的时间，创造更高的价值.md","hash":"b3ab7de46b0d82170431c1b0bbc231616ee0782b","modified":1593054624434},{"_id":"source/_posts/LEVEL 1/时间管理/3 诊断你的时间/3.3 时间分类法 | 找到你的时间规律，发挥时间的最大价值.md","hash":"fb472cb56f44e35d5c6a7e40856f6cfd5fbea928","modified":1593054624435},{"_id":"source/_posts/LEVEL 1/时间管理/4 打造你的时间管理系统/4.1 RAR管理法 | 打造时间管理系统，释放你的大脑.md","hash":"8a9fcb1a450e91669301491e8e61eb9442bfed8c","modified":1593054624437},{"_id":"source/_posts/LEVEL 1/时间管理/4 打造你的时间管理系统/4.2 时间管理工具 | 让工具为你创造更多自由时间.md","hash":"bf401dd8e2e6feab0a319a074e95b920cdf42492","modified":1593054624438},{"_id":"source/_posts/LEVEL 1/高效工作/1 做正确的事/1.1 结果导向、极致专心.md","hash":"93f550f607c05effe4663f2f910a194958c1f563","modified":1593054624442},{"_id":"source/_posts/LEVEL 1/高效工作/2 正确地做事/2.1 善于借助外部力量.md","hash":"4ee9d6ffa3ad9d9dabf580ef00a30abfdaf88395","modified":1593054624443},{"_id":"source/_posts/LEVEL 1/高效工作/2 正确地做事/2.2 小步快跑、试错迭代.md","hash":"a56af1d5400c1f1ad9dcf43d08a012facc3443a3","modified":1593054624443},{"_id":"source/_posts/LEVEL 1/高效工作/3 事后复盘/3.1 不被同一块石头绊倒两次.md","hash":"3ec3de1dc496b766b8ebc46319498bfdbb1bea82","modified":1593054624444},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/不当诉诸的谬误.md","hash":"c77daadad5c7baf1036cbc50079c3c725c76a352","modified":1593054624424},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/两种转移人身谬误.md","hash":"fdfca71a6bb9f2e578bb26374a4bb0da0b282dbd","modified":1593074830945},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/几种常见的逻辑谬误.md","hash":"7b4ab30d3fd294b9cc1cf8fc30d3dcd2769d479f","modified":1593054624425},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/判断与应对虚假两难谬误.md","hash":"98e5db9c6c9c43aa20810f12a5945d2b3c127d61","modified":1593054624425},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/转移到不同的话题.md","hash":"0dc2eb1ab7ad9afeac32121b95532e3f87cf97a8","modified":1593054624426},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/1 讨论对象三要素｜把偏离的思路拉回正轨.md","hash":"2caf30bebdabb7186594accaddd9829166116efe","modified":1593054624427},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/2 四类证据效力｜打造缜密的思维.md","hash":"6909fa6e7371045d3060da501213045a21a70a4e","modified":1593054624428},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/3 两类假设｜洞悉那些看似有道理却靠不住的观念.md","hash":"362e3f1505dce048b751d6e26df40a6de484ea44","modified":1593054624428},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/4 三种逻辑谬误｜牢固掌握批判性思维能力.md","hash":"1508556bd230be588329a9dba36509944923b29e","modified":1593054624429},{"_id":"source/_posts/LEVEL 1/批判思维/独立思考/破除思维误区/四大思维误区｜冲破独立思考.md","hash":"f5ca344225a319fe2a611bd943effe19bd7f9460","modified":1593054624429},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/两种转移人身谬误/index.html","hash":"d08251eeccd32310914cc6dfd3ed8b3ff1d8f3eb","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/07-async&await/index.html","hash":"4727fa1fd4909ecdb9259a61a6b89289991a3ca8","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/06-自定义Promise-class版本/index.html","hash":"aee673dc83ac7ac9a00c477d61ee98f52deb491b","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/03-Promise API/index.html","hash":"32c798d50336c19ab90ad6f44870c0325b8d3a0e","modified":1593149617261},{"_id":"public/2020/06/25/javascript/this/index.html","hash":"86cac1d3ed376cfb5be4333e7d8c43a8d2ac4bd2","modified":1593149617261},{"_id":"public/2020/06/25/javascript/函数/index.html","hash":"ec02526aee7f34a0550e184f34179bdbe540fcb8","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/高效工作/3 事后复盘/3.1 不被同一块石头绊倒两次/index.html","hash":"f1e45b79596da51d5c0126c412c0b15748b8a067","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/高效工作/4 综合案例/4.1 综合练习/index.html","hash":"84d1b083e8f34ef1d8dae0af87d8d1a04caa52df","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/高效工作/2 正确地做事/2.2 小步快跑、试错迭代/index.html","hash":"21aa4318e030e5f7172d442b55eed32bebab09f3","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/高效工作/2 正确地做事/2.1 善于借助外部力量/index.html","hash":"84ac57aeacbc6e59c3fd35005623922a649eb07d","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/高效工作/1 做正确的事/1.1 结果导向、极致专心/index.html","hash":"0065df6209d991d93251a05201d426706cf31ca3","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/如何优雅的实现时间自由/index.html","hash":"7f279b781150d4a13cc1a3a559cc3d070240e4bc","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/《时间管理》工作与生活冲突，如何享受生活/index.html","hash":"a0df541db7f40cab655af9707abed7a54aac93a7","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/4 打造你的时间管理系统/4.1 RAR管理法 | 打造时间管理系统，释放你的大脑/index.html","hash":"e30ec580b54c3a7924261a18a47eb4d7d470489e","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/4 打造你的时间管理系统/4.2 时间管理工具 | 让工具为你创造更多自由时间/index.html","hash":"ffbdd0d9866925ac415b03d66b8307f13754247c","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/3 诊断你的时间/3.1 时间记录法 | 了解你的时间花费，让时间变得更可控/index.html","hash":"44b56b8326007d5d210a0271bf0ff4df4a51fb0c","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/2 了解你的时间观/2.1 津巴多时间观｜了解自己的时间观/index.html","hash":"3985e474e09082e44428847bcbf72d15ced5bc0a","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/思考跟独立四步法/3 两类假设｜洞悉那些看似有道理却靠不住的观念/index.html","hash":"fcdca935d78c65af39294606e95743cf91d48aa8","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/思考跟独立四步法/4 三种逻辑谬误｜牢固掌握批判性思维能力/index.html","hash":"88df545ba7cb0d3171b879bdbad29a0d3065bc23","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/思考跟独立四步法/2 四类证据效力｜打造缜密的思维/index.html","hash":"130f331cc6a25d634f76e5c03614b13165c0f5a1","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/判断与应对虚假两难谬误/index.html","hash":"eff62d0372063f29d62c4f98c58c5be8b1bb366b","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/几种常见的逻辑谬误/index.html","hash":"84bc54fc48bc20d1434a367d50d0db33f7ed34ba","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/转移到不同的话题/index.html","hash":"ba2877b677b33c1ba60d04162273459683d47654","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/3 应对压力/3.4 方法四：提升应对能力/index.html","hash":"0e8a74af1a20d50a9c3748ec74a786c5ab3b842a","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/3 应对压力/3.2 方法二：改变认知方式/index.html","hash":"6fa6793b15aef64ea7d0977a9857a6d8aaf80820","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/3 应对压力/3.1 方法一：调整行为方式/index.html","hash":"4e37cdf79bc61d90ea254d844730de0d47915f82","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/3 应对压力/3.3 方法三：增加应对资源/index.html","hash":"4ab27cf404013823aa9d137cfced49f5cc73fae5","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/2 识别压力/2.1 揭开你的压力真面目/index.html","hash":"c3dd222356d6980505ab3572801130055cafe506","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/1 认识压力/1.3 为什么有人总说压力山大/index.html","hash":"5722616e4ca62a77b71d152c4ba3020ca1e5b8f3","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/1 认识压力/1.2 为什么会感觉到压力/index.html","hash":"82a61d825075ed4f98fb05c8f0739e4a2c4f816a","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/压力管理/1 认识压力/1.1 你真的了解压力吗/index.html","hash":"4b9107483268a5ab83e073ec56a7e9259215a024","modified":1593149617261},{"_id":"public/2020/06/25/JavaScript模块化/AMD/index.html","hash":"8a21ae7dfd47b09900e448eab5138b94847b80a8","modified":1593149617261},{"_id":"public/2020/06/25/JavaScript模块化/模块化的规范/index.html","hash":"a14a54e97c32d41df1e9a4bfef55a96655e2563f","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/在地址栏输入URL后发生了什么/index.html","hash":"2916508e5575ba9d6f24c3a89d8da860662592f5","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/URI URL URN/index.html","hash":"9cc3e5f35934e982c4bafa546369d307a2e3d5aa","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/数据协商/index.html","hash":"fe9c1e20108d355bb9922ca89e403aebc23b2493","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP报文/index.html","hash":"cc8c648301b19cea8dfe03e3cf168c5024017ec9","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP的三次握手/index.html","hash":"068d96e2a615055996302b8351472084ef636207","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP-长连接/index.html","hash":"aa1bf7d146283bf6e39025a9e71c8c7d6488cf67","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP-cookie&session/index.html","hash":"d1d961105e50e4aec7ac4d356391f59d5899ad42","modified":1593149617261},{"_id":"public/page/7/index.html","hash":"5bdabb8f62bfa773f9fa8eacea5ab1b57e4658d1","modified":1593149617261},{"_id":"public/archives/2020/page/7/index.html","hash":"6eea2f6dbc4d3e7e43e601e66020ff7ba5b669d7","modified":1593149617261},{"_id":"public/archives/2020/06/page/7/index.html","hash":"fa2589f7dcb36b075f6941a782983f8693f5a655","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/宏任务和微任务/index.html","hash":"369f4cb1f682192d0abf222b92467b55c132f7ea","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/Event Loop/index.html","hash":"4921274c3aa286621639b931c02476703da0f657","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/05-自定义Promise/index.html","hash":"4a6103e31fd51e445a9a71d6a75c0962faacf260","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/02-Promise的理解和使用/index.html","hash":"c242a83ab716ef229d4604f73a83d08fe7203f51","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/04-promise中的关键问题/index.html","hash":"1b39fba1824af48611b27aa953e6576b2b2ccf7c","modified":1593149617261},{"_id":"public/2020/06/25/自定义Promise/01-准备/index.html","hash":"50d0a1348a046b173609be2f427a388d76b9dee8","modified":1593149617261},{"_id":"public/2020/06/25/javascript/对象/index.html","hash":"b5d107b7e01f07421d11778c273762cbb3f17e06","modified":1593149617261},{"_id":"public/2020/06/25/javascript/原型/index.html","hash":"8749cf345fdf24bb07cae365a4daaa213ab27d70","modified":1593149617261},{"_id":"public/2020/06/25/javascript/作用域/index.html","hash":"72557580d17275df7dff79089f72960eeea7e495","modified":1593149617261},{"_id":"public/2020/06/25/javascript/print-i-one-time/index.html","hash":"0d432bcf76b0f265263cc43732ad5fa611e88fba","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/构建知识体系/index.html","hash":"9d8302876ea2ea5ea9ded97450f4da55452a09be","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/3 诊断你的时间/3.3 时间分类法 | 找到你的时间规律，发挥时间的最大价值/index.html","hash":"4cb5cd0f64d1f9820cf8593666f4b311002946a5","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/3 诊断你的时间/3.2 关键可行矩阵 | 让你用更短的时间，创造更高的价值/index.html","hash":"70d616c589409c0a79771738db3a9ecdf7051629","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/2 了解你的时间观/2.2 时间观察调整法｜ 如何平衡自己的时间/index.html","hash":"d31a0dd18affa79f03548b17043d540f4fd8ff02","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/时间管理/1 认识时间管理/1.1 时间管理的误区/index.html","hash":"1f7e1bb7063e2317e91ac7afe789d9c97e3dd276","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/破除思维误区/四大思维误区｜冲破独立思考/index.html","hash":"883a662f05c27a38117f11e9a43f7bfddcbce309","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/思考跟独立四步法/1 讨论对象三要素｜把偏离的思路拉回正轨/index.html","hash":"f02d54199616be717195bad07230f0962b10c758","modified":1593149617261},{"_id":"public/2020/06/25/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/不当诉诸的谬误/index.html","hash":"a5c07271898ff9b550aba4cabb1267883655c9be","modified":1593149617261},{"_id":"public/2020/06/25/JavaScript模块化/模块化进程/index.html","hash":"8c119a5569482900b22149bb8138ceff61fe75d0","modified":1593149617261},{"_id":"public/2020/06/25/JavaScript模块化/CommonJS/index.html","hash":"05920e3379228c298ecea5015cb3b3dd598b4aac","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/浏览器的安全策略/index.html","hash":"9ad3ed9161337dcfed16ea430ff991d56ee7ce7c","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP历史/index.html","hash":"0d1ae211b37dd89ff64f7bc1fd70ee761d04139a","modified":1593149617261},{"_id":"public/2020/06/25/HTTP/HTTP-缓存/index.html","hash":"a5cc311281d715edf0f7c5624eb32ab75ce0a14e","modified":1593149617261},{"_id":"public/index.html","hash":"b1c87de6a30637f9928ccb6f1150cb7dbeb0e665","modified":1593149617261},{"_id":"public/page/2/index.html","hash":"5b0236dc36187bf0b6293167984415bed66cc862","modified":1593149617261},{"_id":"public/page/3/index.html","hash":"96b968619831c45450ddd041e25df9f01a9c0693","modified":1593149617261},{"_id":"public/page/4/index.html","hash":"58c71882d227285aa17fd33a160f79575cd0e3e2","modified":1593149617261},{"_id":"public/page/5/index.html","hash":"efd21427a007fbc618f07160ed8790adf9ab2e59","modified":1593149617261},{"_id":"public/page/6/index.html","hash":"db0d8ae56b65e9f740bba8c5a46c13a0b04bc3af","modified":1593149617261},{"_id":"public/archives/index.html","hash":"c43e51132ff2eeff758711707727482eecd7af4b","modified":1593149617261},{"_id":"public/archives/page/2/index.html","hash":"1ba56efcf05ba0ee1812762477d184e87b3746e8","modified":1593149617261},{"_id":"public/archives/page/3/index.html","hash":"4e8abc0c81131a96d3911299ec88a749e9ea475b","modified":1593149617261},{"_id":"public/archives/page/4/index.html","hash":"066fcb6538a4c8c3e565efd079fddb672554472e","modified":1593149617261},{"_id":"public/archives/page/5/index.html","hash":"377af82ca3c03259ef2e1bbe3a5f1ac4c89561b9","modified":1593149617261},{"_id":"public/archives/page/6/index.html","hash":"07fcc50def97fe0fe50872c690358871b19c82ab","modified":1593149617261},{"_id":"public/archives/page/7/index.html","hash":"4d940ce5212397e8c13caf8fc1d5c7b4fdfac451","modified":1593149617261},{"_id":"public/archives/2020/index.html","hash":"828043bf7fe75391800408e4593f680c579c2e35","modified":1593149617261},{"_id":"public/archives/2020/page/2/index.html","hash":"4874dfcbf6f5aed86ee2b4e39795ae149ae98d87","modified":1593149617261},{"_id":"public/archives/2020/page/3/index.html","hash":"7126988fd09399af075524ad5248cf55fc7ec21a","modified":1593149617261},{"_id":"public/archives/2020/page/4/index.html","hash":"ecc7a5b504fc39e3243295a1c683e58dcf362c8e","modified":1593149617261},{"_id":"public/archives/2020/page/5/index.html","hash":"2e7a04ebc7833bfdc6b69aa0468ae9838f841215","modified":1593149617261},{"_id":"public/archives/2020/page/6/index.html","hash":"f4de2a42745d978040b30a714bbe0d6ff8c5f283","modified":1593149617261},{"_id":"public/archives/2020/06/index.html","hash":"407a5edaf3b7ac65f97e35bea2ed51146ff48b4c","modified":1593149617261},{"_id":"public/archives/2020/06/page/2/index.html","hash":"3d4d2d484e0eb0b6d8064816d649df236b2639d4","modified":1593149617261},{"_id":"public/archives/2020/06/page/3/index.html","hash":"7e778b9f05c8992ee1cc36bd56c3af0590901744","modified":1593149617261},{"_id":"public/archives/2020/06/page/4/index.html","hash":"f79a388aafb3e39f31e50507f1b99b66b9033b0a","modified":1593149617261},{"_id":"public/archives/2020/06/page/5/index.html","hash":"c379010402e06de83619a3be8bee585422a35843","modified":1593149617261},{"_id":"public/archives/2020/06/page/6/index.html","hash":"73c6f7d1df6b02e4d97ae9c52c3c12c05474c38a","modified":1593149617261},{"_id":"public/css/note.css","hash":"f166507392731b42a8d433643c21d96e9a3b46a1","modified":1593149617261},{"_id":"public/js/b2t.js","hash":"322260f1aa64c16d8c04a1e53f7b7675431a3268","modified":1593149617261},{"_id":"public/js/darkmode.js","hash":"1f36e3ba413c2825f08a7e2ec69e61bf305a9188","modified":1593149617261},{"_id":"public/css/dark.css","hash":"50a9acfdb83cc646997982d8bd31e3da5f8ed9aa","modified":1593149617261},{"_id":"public/css/github.min.css","hash":"3bb8dc45fb4e714153845e35020b7ba94519eb36","modified":1593149617261},{"_id":"public/css/style.css","hash":"49c86c0d36ca1b4fc41221fb7e78b54b8a9d914c","modified":1593149617261}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"","source":"_posts/HTTP/HTTP-长连接.md","raw":"","slug":"HTTP/HTTP-长连接","published":1,"date":"2020-06-25T03:10:24.406Z","updated":"2020-06-25T03:10:24.406Z","title":"HTTP/HTTP-长连接","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wlt00003ns69y725h4w","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"## cookie\n\ncookie是什么\n\n如何使用cookie\n\ncookie的利弊\n\n## session\n\nsession是什么\n\n如何使用session\n\nsession的利弊","source":"_posts/HTTP/HTTP-cookie&session.md","raw":"## cookie\n\ncookie是什么\n\n如何使用cookie\n\ncookie的利弊\n\n## session\n\nsession是什么\n\n如何使用session\n\nsession的利弊","slug":"HTTP/HTTP-cookie&session","published":1,"date":"2020-06-25T03:10:24.402Z","updated":"2020-06-25T03:10:24.403Z","title":"HTTP/HTTP-cookie&session","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wna00013ns680d2a2rf","content":"<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>cookie是什么</p>\n<p>如何使用cookie</p>\n<p>cookie的利弊</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>session是什么</p>\n<p>如何使用session</p>\n<p>session的利弊</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>cookie是什么</p>\n<p>如何使用cookie</p>\n<p>cookie的利弊</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>session是什么</p>\n<p>如何使用session</p>\n<p>session的利弊</p>\n"},{"_content":"HTTP是万维网的基础协议。早起是一个实验室之间交换文件的协议，进化到如今可以传输图片，高分辨率视频、3D效果的复杂的现代互联网协议。\n\n## 万维网\n\n1989年，Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本协议的系统报告。起初命名为Mesh，在1990年项目实施期间被更名为万维网（World Wide Web）。\n\n万维网在现有的TCP/IP协议基础上建立，由四部分组成：\n\n- 用来表示超文本文档的文本格式，超文本标记语言（HTML）\n- 用来交换超文本文档的简单协议，超文本传输协议（HTTP）\n- 显示/编辑超文本文档的客户端，即网络浏览器。\n- 服务器用于提供访问的文档，即`httpd`的前身\n\nHTTP在应用的早起阶段非常的简单，后来被称为HTTP/0.9，也有叫做单行（one-line）协议\n\n## HTTP/0.9-单行协议\n\n请求由单行指令构成，以唯一可用的`Get`开头，其后跟着目标资源的路径\n\n``` http\nGET /index.html\n```\n\n响应也极其简单：只包含文档本身，没有响应头，这意味着只有HTML文件可以传送\n\n``` html\n<html>\n  这是一个简单的HTML页面\n</html>\n```\n\n- 只有GET命令\n- 没有HEADER等描述数据的信息\n- 服务器发送完毕，就关闭TCP连接\n- 一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看\n\n## HTTP/1.0-构建可扩展性\n\n- 协议版本信息会随着每个请求发送 `GET /index.html HTTP/1.0`\n- 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）\n- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性\n- 具备传输纯文本HTML文档以外的其他类型文档的能力（`Content-Type`）\n- 增加了很多命令\n- 增加status code 和 header\n- 多字符集支持、多部分发送、权限、缓存\n\n``` http\nGET /index.html HTTP/1.0\nUser-Agent: NCSA_Mosaic/2.0 (Windows 3.1)\n\n200 OK\nDate: Tue, 15 Nov 1994 08:12:31 GMT\nServer: CERN/3.0 libwww/2.17\nContent-Type: text/html\n<HTML> \n一个包含图片的页面\n</HTML>\n```\n\n这些新扩展并没有马上被引入到标准中。直到1996年11月，一份新的文档被发表出来。该文档定义了HTTP/1.0，但它是狭义的，并不是官方标准。 \n\n## HTTP/1.1-标准化的协议\n\n在1997年，[HTTP/1.1](https://tools.ietf.org/html/rfc2068)标准发布，就在HTTP/1.0发布的几个月后。\n\nHTTP /1.1消除了大量歧义内容并引入了更多改进：\n\n- 连接可复用，节省多次打开TCP连接加载文档资源的时间\n- 增加管线技术pipeline，第一个应答被完全发送之前就发送第二个请求，降低通信延迟(同一个连接里发送多个请求，<u>串行</u>)\n- 支持响应分块\n- 缓存控制机制\n- 内容协商机制\n- 增加host和其他一些命令（同一个IP可以部署多个web服务）\n\n## HTTP/2.0-为了更优异的表现\n\n2015年5月正式标准化\n\n> HTTP/2.0是二进制协议，不是文本协议\n\n- 所有数据以二进制传输（之前是字符串）\n- 同一个连接里发送多个请求可<u>并行</u>处理，移除HTTP/1.x中的顺序和阻塞约束\n- 头信息压缩，移除重复和传输重复数据的成本\n- 推送\n\n## HTTP-安全传输\n\n1994年，网景公司在TCP/IP协议栈基础上创建了一个**额外的加密传输层**：SSL。SSL2.0及其后继者SSL 3.0和SSL 3.1**允许通过加密来保证服务器和客户端之间交换消息的真实性**。SSL标准化最终成为TLS。\n\n## HTTP-复杂应用\n\nWeb 的最初设想不是一个只读媒体。 他设想一个 Web 是可以远程添加或移动文档，是一种分布式文件系统。 大约 1996 年，HTTP 被扩展到允许创作，并且创建了一个名为 WebDAV 的标准。\n\n在 2000 年，一种新的使用 HTTP 的模式被设计出来：[representational state transfer](https://developer.mozilla.org/en-US/docs/Glossary/REST) (或者说 `REST`)。 <u>由 API 发起的操作不再通过新的 HTTP 方法传达，而只能通过使用基本的 HTTP / 1.1 方法访问特定的 URI</u>。 这允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器\n\n其中几个API为特定目的扩张了HTT协议，大部分是新的特定HTTP头\n\n- [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)，服务器可以偶尔推送消息到浏览器。\n- [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket_API)，一个新协议，可以通过升级现有 HTTP 协议来建立。\n\n## 放松的Web安全模型\n\nHTTP和Web安全模型--[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。\n\n","source":"_posts/HTTP/HTTP历史.md","raw":"HTTP是万维网的基础协议。早起是一个实验室之间交换文件的协议，进化到如今可以传输图片，高分辨率视频、3D效果的复杂的现代互联网协议。\n\n## 万维网\n\n1989年，Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本协议的系统报告。起初命名为Mesh，在1990年项目实施期间被更名为万维网（World Wide Web）。\n\n万维网在现有的TCP/IP协议基础上建立，由四部分组成：\n\n- 用来表示超文本文档的文本格式，超文本标记语言（HTML）\n- 用来交换超文本文档的简单协议，超文本传输协议（HTTP）\n- 显示/编辑超文本文档的客户端，即网络浏览器。\n- 服务器用于提供访问的文档，即`httpd`的前身\n\nHTTP在应用的早起阶段非常的简单，后来被称为HTTP/0.9，也有叫做单行（one-line）协议\n\n## HTTP/0.9-单行协议\n\n请求由单行指令构成，以唯一可用的`Get`开头，其后跟着目标资源的路径\n\n``` http\nGET /index.html\n```\n\n响应也极其简单：只包含文档本身，没有响应头，这意味着只有HTML文件可以传送\n\n``` html\n<html>\n  这是一个简单的HTML页面\n</html>\n```\n\n- 只有GET命令\n- 没有HEADER等描述数据的信息\n- 服务器发送完毕，就关闭TCP连接\n- 一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看\n\n## HTTP/1.0-构建可扩展性\n\n- 协议版本信息会随着每个请求发送 `GET /index.html HTTP/1.0`\n- 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）\n- 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性\n- 具备传输纯文本HTML文档以外的其他类型文档的能力（`Content-Type`）\n- 增加了很多命令\n- 增加status code 和 header\n- 多字符集支持、多部分发送、权限、缓存\n\n``` http\nGET /index.html HTTP/1.0\nUser-Agent: NCSA_Mosaic/2.0 (Windows 3.1)\n\n200 OK\nDate: Tue, 15 Nov 1994 08:12:31 GMT\nServer: CERN/3.0 libwww/2.17\nContent-Type: text/html\n<HTML> \n一个包含图片的页面\n</HTML>\n```\n\n这些新扩展并没有马上被引入到标准中。直到1996年11月，一份新的文档被发表出来。该文档定义了HTTP/1.0，但它是狭义的，并不是官方标准。 \n\n## HTTP/1.1-标准化的协议\n\n在1997年，[HTTP/1.1](https://tools.ietf.org/html/rfc2068)标准发布，就在HTTP/1.0发布的几个月后。\n\nHTTP /1.1消除了大量歧义内容并引入了更多改进：\n\n- 连接可复用，节省多次打开TCP连接加载文档资源的时间\n- 增加管线技术pipeline，第一个应答被完全发送之前就发送第二个请求，降低通信延迟(同一个连接里发送多个请求，<u>串行</u>)\n- 支持响应分块\n- 缓存控制机制\n- 内容协商机制\n- 增加host和其他一些命令（同一个IP可以部署多个web服务）\n\n## HTTP/2.0-为了更优异的表现\n\n2015年5月正式标准化\n\n> HTTP/2.0是二进制协议，不是文本协议\n\n- 所有数据以二进制传输（之前是字符串）\n- 同一个连接里发送多个请求可<u>并行</u>处理，移除HTTP/1.x中的顺序和阻塞约束\n- 头信息压缩，移除重复和传输重复数据的成本\n- 推送\n\n## HTTP-安全传输\n\n1994年，网景公司在TCP/IP协议栈基础上创建了一个**额外的加密传输层**：SSL。SSL2.0及其后继者SSL 3.0和SSL 3.1**允许通过加密来保证服务器和客户端之间交换消息的真实性**。SSL标准化最终成为TLS。\n\n## HTTP-复杂应用\n\nWeb 的最初设想不是一个只读媒体。 他设想一个 Web 是可以远程添加或移动文档，是一种分布式文件系统。 大约 1996 年，HTTP 被扩展到允许创作，并且创建了一个名为 WebDAV 的标准。\n\n在 2000 年，一种新的使用 HTTP 的模式被设计出来：[representational state transfer](https://developer.mozilla.org/en-US/docs/Glossary/REST) (或者说 `REST`)。 <u>由 API 发起的操作不再通过新的 HTTP 方法传达，而只能通过使用基本的 HTTP / 1.1 方法访问特定的 URI</u>。 这允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器\n\n其中几个API为特定目的扩张了HTT协议，大部分是新的特定HTTP头\n\n- [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)，服务器可以偶尔推送消息到浏览器。\n- [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket_API)，一个新协议，可以通过升级现有 HTTP 协议来建立。\n\n## 放松的Web安全模型\n\nHTTP和Web安全模型--[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。\n\n","slug":"HTTP/HTTP历史","published":1,"date":"2020-06-25T03:10:24.407Z","updated":"2020-06-25T03:10:24.407Z","title":"HTTP/HTTP历史","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnb00023ns6693y3jdq","content":"<p>HTTP是万维网的基础协议。早起是一个实验室之间交换文件的协议，进化到如今可以传输图片，高分辨率视频、3D效果的复杂的现代互联网协议。</p>\n<h2 id=\"万维网\"><a href=\"#万维网\" class=\"headerlink\" title=\"万维网\"></a>万维网</h2><p>1989年，Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本协议的系统报告。起初命名为Mesh，在1990年项目实施期间被更名为万维网（World Wide Web）。</p>\n<p>万维网在现有的TCP/IP协议基础上建立，由四部分组成：</p>\n<ul>\n<li>用来表示超文本文档的文本格式，超文本标记语言（HTML）</li>\n<li>用来交换超文本文档的简单协议，超文本传输协议（HTTP）</li>\n<li>显示/编辑超文本文档的客户端，即网络浏览器。</li>\n<li>服务器用于提供访问的文档，即<code>httpd</code>的前身</li>\n</ul>\n<p>HTTP在应用的早起阶段非常的简单，后来被称为HTTP/0.9，也有叫做单行（one-line）协议</p>\n<h2 id=\"HTTP-0-9-单行协议\"><a href=\"#HTTP-0-9-单行协议\" class=\"headerlink\" title=\"HTTP/0.9-单行协议\"></a>HTTP/0.9-单行协议</h2><p>请求由单行指令构成，以唯一可用的<code>Get</code>开头，其后跟着目标资源的路径</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /index.html</span><br></pre></td></tr></table></figure>\n\n<p>响应也极其简单：只包含文档本身，没有响应头，这意味着只有HTML文件可以传送</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  这是一个简单的HTML页面</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只有GET命令</li>\n<li>没有HEADER等描述数据的信息</li>\n<li>服务器发送完毕，就关闭TCP连接</li>\n<li>一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看</li>\n</ul>\n<h2 id=\"HTTP-1-0-构建可扩展性\"><a href=\"#HTTP-1-0-构建可扩展性\" class=\"headerlink\" title=\"HTTP/1.0-构建可扩展性\"></a>HTTP/1.0-构建可扩展性</h2><ul>\n<li>协议版本信息会随着每个请求发送 <code>GET /index.html HTTP/1.0</code></li>\n<li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）</li>\n<li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性</li>\n<li>具备传输纯文本HTML文档以外的其他类型文档的能力（<code>Content-Type</code>）</li>\n<li>增加了很多命令</li>\n<li>增加status code 和 header</li>\n<li>多字符集支持、多部分发送、权限、缓存</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.0</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class=\"line\"></span><br><span class=\"line\">200 OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 15 Nov 1994 08:12:31 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: CERN/3.0 libwww/2.17</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\">&lt;HTML&gt; </span><br><span class=\"line\">一个包含图片的页面</span><br><span class=\"line\">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这些新扩展并没有马上被引入到标准中。直到1996年11月，一份新的文档被发表出来。该文档定义了HTTP/1.0，但它是狭义的，并不是官方标准。 </p>\n<h2 id=\"HTTP-1-1-标准化的协议\"><a href=\"#HTTP-1-1-标准化的协议\" class=\"headerlink\" title=\"HTTP/1.1-标准化的协议\"></a>HTTP/1.1-标准化的协议</h2><p>在1997年，<a href=\"https://tools.ietf.org/html/rfc2068\" target=\"_blank\" rel=\"noopener\">HTTP/1.1</a>标准发布，就在HTTP/1.0发布的几个月后。</p>\n<p>HTTP /1.1消除了大量歧义内容并引入了更多改进：</p>\n<ul>\n<li>连接可复用，节省多次打开TCP连接加载文档资源的时间</li>\n<li>增加管线技术pipeline，第一个应答被完全发送之前就发送第二个请求，降低通信延迟(同一个连接里发送多个请求，<u>串行</u>)</li>\n<li>支持响应分块</li>\n<li>缓存控制机制</li>\n<li>内容协商机制</li>\n<li>增加host和其他一些命令（同一个IP可以部署多个web服务）</li>\n</ul>\n<h2 id=\"HTTP-2-0-为了更优异的表现\"><a href=\"#HTTP-2-0-为了更优异的表现\" class=\"headerlink\" title=\"HTTP/2.0-为了更优异的表现\"></a>HTTP/2.0-为了更优异的表现</h2><p>2015年5月正式标准化</p>\n<blockquote>\n<p>HTTP/2.0是二进制协议，不是文本协议</p>\n</blockquote>\n<ul>\n<li>所有数据以二进制传输（之前是字符串）</li>\n<li>同一个连接里发送多个请求可<u>并行</u>处理，移除HTTP/1.x中的顺序和阻塞约束</li>\n<li>头信息压缩，移除重复和传输重复数据的成本</li>\n<li>推送</li>\n</ul>\n<h2 id=\"HTTP-安全传输\"><a href=\"#HTTP-安全传输\" class=\"headerlink\" title=\"HTTP-安全传输\"></a>HTTP-安全传输</h2><p>1994年，网景公司在TCP/IP协议栈基础上创建了一个<strong>额外的加密传输层</strong>：SSL。SSL2.0及其后继者SSL 3.0和SSL 3.1<strong>允许通过加密来保证服务器和客户端之间交换消息的真实性</strong>。SSL标准化最终成为TLS。</p>\n<h2 id=\"HTTP-复杂应用\"><a href=\"#HTTP-复杂应用\" class=\"headerlink\" title=\"HTTP-复杂应用\"></a>HTTP-复杂应用</h2><p>Web 的最初设想不是一个只读媒体。 他设想一个 Web 是可以远程添加或移动文档，是一种分布式文件系统。 大约 1996 年，HTTP 被扩展到允许创作，并且创建了一个名为 WebDAV 的标准。</p>\n<p>在 2000 年，一种新的使用 HTTP 的模式被设计出来：<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/REST\" target=\"_blank\" rel=\"noopener\">representational state transfer</a> (或者说 <code>REST</code>)。 <u>由 API 发起的操作不再通过新的 HTTP 方法传达，而只能通过使用基本的 HTTP / 1.1 方法访问特定的 URI</u>。 这允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器</p>\n<p>其中几个API为特定目的扩张了HTT协议，大部分是新的特定HTTP头</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events\" target=\"_blank\" rel=\"noopener\">Server-sent events</a>，服务器可以偶尔推送消息到浏览器。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket_API\" target=\"_blank\" rel=\"noopener\">WebSocket</a>，一个新协议，可以通过升级现有 HTTP 协议来建立。</li>\n</ul>\n<h2 id=\"放松的Web安全模型\"><a href=\"#放松的Web安全模型\" class=\"headerlink\" title=\"放松的Web安全模型\"></a>放松的Web安全模型</h2><p>HTTP和Web安全模型–<a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">同源策略</a>是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP是万维网的基础协议。早起是一个实验室之间交换文件的协议，进化到如今可以传输图片，高分辨率视频、3D效果的复杂的现代互联网协议。</p>\n<h2 id=\"万维网\"><a href=\"#万维网\" class=\"headerlink\" title=\"万维网\"></a>万维网</h2><p>1989年，Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本协议的系统报告。起初命名为Mesh，在1990年项目实施期间被更名为万维网（World Wide Web）。</p>\n<p>万维网在现有的TCP/IP协议基础上建立，由四部分组成：</p>\n<ul>\n<li>用来表示超文本文档的文本格式，超文本标记语言（HTML）</li>\n<li>用来交换超文本文档的简单协议，超文本传输协议（HTTP）</li>\n<li>显示/编辑超文本文档的客户端，即网络浏览器。</li>\n<li>服务器用于提供访问的文档，即<code>httpd</code>的前身</li>\n</ul>\n<p>HTTP在应用的早起阶段非常的简单，后来被称为HTTP/0.9，也有叫做单行（one-line）协议</p>\n<h2 id=\"HTTP-0-9-单行协议\"><a href=\"#HTTP-0-9-单行协议\" class=\"headerlink\" title=\"HTTP/0.9-单行协议\"></a>HTTP/0.9-单行协议</h2><p>请求由单行指令构成，以唯一可用的<code>Get</code>开头，其后跟着目标资源的路径</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /index.html</span><br></pre></td></tr></table></figure>\n\n<p>响应也极其简单：只包含文档本身，没有响应头，这意味着只有HTML文件可以传送</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  这是一个简单的HTML页面</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只有GET命令</li>\n<li>没有HEADER等描述数据的信息</li>\n<li>服务器发送完毕，就关闭TCP连接</li>\n<li>一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看</li>\n</ul>\n<h2 id=\"HTTP-1-0-构建可扩展性\"><a href=\"#HTTP-1-0-构建可扩展性\" class=\"headerlink\" title=\"HTTP/1.0-构建可扩展性\"></a>HTTP/1.0-构建可扩展性</h2><ul>\n<li>协议版本信息会随着每个请求发送 <code>GET /index.html HTTP/1.0</code></li>\n<li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）</li>\n<li>引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性</li>\n<li>具备传输纯文本HTML文档以外的其他类型文档的能力（<code>Content-Type</code>）</li>\n<li>增加了很多命令</li>\n<li>增加status code 和 header</li>\n<li>多字符集支持、多部分发送、权限、缓存</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.0</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class=\"line\"></span><br><span class=\"line\">200 OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 15 Nov 1994 08:12:31 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: CERN/3.0 libwww/2.17</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\">&lt;HTML&gt; </span><br><span class=\"line\">一个包含图片的页面</span><br><span class=\"line\">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这些新扩展并没有马上被引入到标准中。直到1996年11月，一份新的文档被发表出来。该文档定义了HTTP/1.0，但它是狭义的，并不是官方标准。 </p>\n<h2 id=\"HTTP-1-1-标准化的协议\"><a href=\"#HTTP-1-1-标准化的协议\" class=\"headerlink\" title=\"HTTP/1.1-标准化的协议\"></a>HTTP/1.1-标准化的协议</h2><p>在1997年，<a href=\"https://tools.ietf.org/html/rfc2068\" target=\"_blank\" rel=\"noopener\">HTTP/1.1</a>标准发布，就在HTTP/1.0发布的几个月后。</p>\n<p>HTTP /1.1消除了大量歧义内容并引入了更多改进：</p>\n<ul>\n<li>连接可复用，节省多次打开TCP连接加载文档资源的时间</li>\n<li>增加管线技术pipeline，第一个应答被完全发送之前就发送第二个请求，降低通信延迟(同一个连接里发送多个请求，<u>串行</u>)</li>\n<li>支持响应分块</li>\n<li>缓存控制机制</li>\n<li>内容协商机制</li>\n<li>增加host和其他一些命令（同一个IP可以部署多个web服务）</li>\n</ul>\n<h2 id=\"HTTP-2-0-为了更优异的表现\"><a href=\"#HTTP-2-0-为了更优异的表现\" class=\"headerlink\" title=\"HTTP/2.0-为了更优异的表现\"></a>HTTP/2.0-为了更优异的表现</h2><p>2015年5月正式标准化</p>\n<blockquote>\n<p>HTTP/2.0是二进制协议，不是文本协议</p>\n</blockquote>\n<ul>\n<li>所有数据以二进制传输（之前是字符串）</li>\n<li>同一个连接里发送多个请求可<u>并行</u>处理，移除HTTP/1.x中的顺序和阻塞约束</li>\n<li>头信息压缩，移除重复和传输重复数据的成本</li>\n<li>推送</li>\n</ul>\n<h2 id=\"HTTP-安全传输\"><a href=\"#HTTP-安全传输\" class=\"headerlink\" title=\"HTTP-安全传输\"></a>HTTP-安全传输</h2><p>1994年，网景公司在TCP/IP协议栈基础上创建了一个<strong>额外的加密传输层</strong>：SSL。SSL2.0及其后继者SSL 3.0和SSL 3.1<strong>允许通过加密来保证服务器和客户端之间交换消息的真实性</strong>。SSL标准化最终成为TLS。</p>\n<h2 id=\"HTTP-复杂应用\"><a href=\"#HTTP-复杂应用\" class=\"headerlink\" title=\"HTTP-复杂应用\"></a>HTTP-复杂应用</h2><p>Web 的最初设想不是一个只读媒体。 他设想一个 Web 是可以远程添加或移动文档，是一种分布式文件系统。 大约 1996 年，HTTP 被扩展到允许创作，并且创建了一个名为 WebDAV 的标准。</p>\n<p>在 2000 年，一种新的使用 HTTP 的模式被设计出来：<a href=\"https://developer.mozilla.org/en-US/docs/Glossary/REST\" target=\"_blank\" rel=\"noopener\">representational state transfer</a> (或者说 <code>REST</code>)。 <u>由 API 发起的操作不再通过新的 HTTP 方法传达，而只能通过使用基本的 HTTP / 1.1 方法访问特定的 URI</u>。 这允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器</p>\n<p>其中几个API为特定目的扩张了HTT协议，大部分是新的特定HTTP头</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events\" target=\"_blank\" rel=\"noopener\">Server-sent events</a>，服务器可以偶尔推送消息到浏览器。</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket_API\" target=\"_blank\" rel=\"noopener\">WebSocket</a>，一个新协议，可以通过升级现有 HTTP 协议来建立。</li>\n</ul>\n<h2 id=\"放松的Web安全模型\"><a href=\"#放松的Web安全模型\" class=\"headerlink\" title=\"放松的Web安全模型\"></a>放松的Web安全模型</h2><p>HTTP和Web安全模型–<a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">同源策略</a>是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。</p>\n"},{"_content":"起始行、首部、主体。\n\n语义，具体如何实现，看操作\n\n## 请求报文\n\n\n\n\n\n## 响应报文\n\n","source":"_posts/HTTP/HTTP报文.md","raw":"起始行、首部、主体。\n\n语义，具体如何实现，看操作\n\n## 请求报文\n\n\n\n\n\n## 响应报文\n\n","slug":"HTTP/HTTP报文","published":1,"date":"2020-06-25T03:10:24.407Z","updated":"2020-06-25T03:10:24.407Z","title":"HTTP/HTTP报文","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnd00033ns63qmubjvv","content":"<p>起始行、首部、主体。</p>\n<p>语义，具体如何实现，看操作</p>\n<h2 id=\"请求报文\"><a href=\"#请求报文\" class=\"headerlink\" title=\"请求报文\"></a>请求报文</h2><h2 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h2>","site":{"data":{}},"excerpt":"","more":"<p>起始行、首部、主体。</p>\n<p>语义，具体如何实现，看操作</p>\n<h2 id=\"请求报文\"><a href=\"#请求报文\" class=\"headerlink\" title=\"请求报文\"></a>请求报文</h2><h2 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h2>"},{"_content":"### TCP connection\n\n在客户端向服务器发送HTTP请求的时候，会建立一个`TCP connection`，HTTP基于`TCP connection` 通道来进行数据的请求和响应。\n\n***建立连接的时候，有三次握手的消耗***\n\n\n\n``` mermaid\ngraph LR\n\tA(user) --TCP connection--> B(server) \n```\n\n#### 不同HTTP版本的TCP connection \n\n- HTTP 1.0\n\n  在一个HTTP请求时候则建立，在响应之后连接关闭\n\n- HTTP 1.1\n\n  在第一个HTTP请求时候则建立，并且不会关闭，第二个请求发送的时候不会重新建立连接，那第二次请求则没有三次握手的开销。\n\n- HTTP 2.0\n\n  同一个用户对同一个服务器发送网络请求的时候，只需要一个TCP connection 连接，可以并发的进行HTTP请求响应\n\n\n\n## 三次握手\n\n- 发生在传输层\n\n- 是TCP连接建立的一个过程\n\n  \n\n#### 为什么建立连接的时候要三次握手\n\n防止服务端开启一些无用的连接\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n\trect rgba(0, 0, 255, .1)\n\t\t\t\tNote over Client,Server: 三次握手，建立TCP连接\n        Client->> + Server: seq=0\n\t\t\t\tServer->>  Client: ACK=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n   \n   \n  rect rgba(0, 0, 255, .1) \n   \t\t\tNote over Client,Server:发送HTTP请求， 传输数据\n        Client->> + Server: seq=0\n\t\t\t\tServer->>  Client: seq=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n   \n   rect rgba(0, 0, 255, .1)  \n   \t\t\tNote over Client,Server:四次挥手， 断开连接\n        Client->> + Server: FIN=0\n\t\t\t\tServer->>  Client: seq=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n\t\n```\n\n","source":"_posts/HTTP/HTTP的三次握手.md","raw":"### TCP connection\n\n在客户端向服务器发送HTTP请求的时候，会建立一个`TCP connection`，HTTP基于`TCP connection` 通道来进行数据的请求和响应。\n\n***建立连接的时候，有三次握手的消耗***\n\n\n\n``` mermaid\ngraph LR\n\tA(user) --TCP connection--> B(server) \n```\n\n#### 不同HTTP版本的TCP connection \n\n- HTTP 1.0\n\n  在一个HTTP请求时候则建立，在响应之后连接关闭\n\n- HTTP 1.1\n\n  在第一个HTTP请求时候则建立，并且不会关闭，第二个请求发送的时候不会重新建立连接，那第二次请求则没有三次握手的开销。\n\n- HTTP 2.0\n\n  同一个用户对同一个服务器发送网络请求的时候，只需要一个TCP connection 连接，可以并发的进行HTTP请求响应\n\n\n\n## 三次握手\n\n- 发生在传输层\n\n- 是TCP连接建立的一个过程\n\n  \n\n#### 为什么建立连接的时候要三次握手\n\n防止服务端开启一些无用的连接\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n\trect rgba(0, 0, 255, .1)\n\t\t\t\tNote over Client,Server: 三次握手，建立TCP连接\n        Client->> + Server: seq=0\n\t\t\t\tServer->>  Client: ACK=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n   \n   \n  rect rgba(0, 0, 255, .1) \n   \t\t\tNote over Client,Server:发送HTTP请求， 传输数据\n        Client->> + Server: seq=0\n\t\t\t\tServer->>  Client: seq=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n   \n   rect rgba(0, 0, 255, .1)  \n   \t\t\tNote over Client,Server:四次挥手， 断开连接\n        Client->> + Server: FIN=0\n\t\t\t\tServer->>  Client: seq=0\n\t\t\t\tClient->> - Server: seq=0\n   end\n\t\n```\n\n","slug":"HTTP/HTTP的三次握手","published":1,"date":"2020-06-25T03:10:24.407Z","updated":"2020-06-25T03:10:24.407Z","title":"HTTP/HTTP的三次握手","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wne00043ns63m3bfz7g","content":"<h3 id=\"TCP-connection\"><a href=\"#TCP-connection\" class=\"headerlink\" title=\"TCP connection\"></a>TCP connection</h3><p>在客户端向服务器发送HTTP请求的时候，会建立一个<code>TCP connection</code>，HTTP基于<code>TCP connection</code> 通道来进行数据的请求和响应。</p>\n<p><strong><em>建立连接的时候，有三次握手的消耗</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\tA(user) --TCP connection--&gt; B(server)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不同HTTP版本的TCP-connection\"><a href=\"#不同HTTP版本的TCP-connection\" class=\"headerlink\" title=\"不同HTTP版本的TCP connection\"></a>不同HTTP版本的TCP connection</h4><ul>\n<li><p>HTTP 1.0</p>\n<p>在一个HTTP请求时候则建立，在响应之后连接关闭</p>\n</li>\n<li><p>HTTP 1.1</p>\n<p>在第一个HTTP请求时候则建立，并且不会关闭，第二个请求发送的时候不会重新建立连接，那第二次请求则没有三次握手的开销。</p>\n</li>\n<li><p>HTTP 2.0</p>\n<p>同一个用户对同一个服务器发送网络请求的时候，只需要一个TCP connection 连接，可以并发的进行HTTP请求响应</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><ul>\n<li><p>发生在传输层</p>\n</li>\n<li><p>是TCP连接建立的一个过程</p>\n</li>\n</ul>\n<h4 id=\"为什么建立连接的时候要三次握手\"><a href=\"#为什么建立连接的时候要三次握手\" class=\"headerlink\" title=\"为什么建立连接的时候要三次握手\"></a>为什么建立连接的时候要三次握手</h4><p>防止服务端开启一些无用的连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trect rgba(0, 0, 255, .1)</span><br><span class=\"line\">\t\t\t\tNote over Client,Server: 三次握手，建立TCP连接</span><br><span class=\"line\">        Client-&gt;&gt; + Server: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">  rect rgba(0, 0, 255, .1) </span><br><span class=\"line\">   \t\t\tNote over Client,Server:发送HTTP请求， 传输数据</span><br><span class=\"line\">        Client-&gt;&gt; + Server: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br><span class=\"line\">   </span><br><span class=\"line\">   rect rgba(0, 0, 255, .1)  </span><br><span class=\"line\">   \t\t\tNote over Client,Server:四次挥手， 断开连接</span><br><span class=\"line\">        Client-&gt;&gt; + Server: FIN&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"TCP-connection\"><a href=\"#TCP-connection\" class=\"headerlink\" title=\"TCP connection\"></a>TCP connection</h3><p>在客户端向服务器发送HTTP请求的时候，会建立一个<code>TCP connection</code>，HTTP基于<code>TCP connection</code> 通道来进行数据的请求和响应。</p>\n<p><strong><em>建立连接的时候，有三次握手的消耗</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">\tA(user) --TCP connection--&gt; B(server)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不同HTTP版本的TCP-connection\"><a href=\"#不同HTTP版本的TCP-connection\" class=\"headerlink\" title=\"不同HTTP版本的TCP connection\"></a>不同HTTP版本的TCP connection</h4><ul>\n<li><p>HTTP 1.0</p>\n<p>在一个HTTP请求时候则建立，在响应之后连接关闭</p>\n</li>\n<li><p>HTTP 1.1</p>\n<p>在第一个HTTP请求时候则建立，并且不会关闭，第二个请求发送的时候不会重新建立连接，那第二次请求则没有三次握手的开销。</p>\n</li>\n<li><p>HTTP 2.0</p>\n<p>同一个用户对同一个服务器发送网络请求的时候，只需要一个TCP connection 连接，可以并发的进行HTTP请求响应</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><ul>\n<li><p>发生在传输层</p>\n</li>\n<li><p>是TCP连接建立的一个过程</p>\n</li>\n</ul>\n<h4 id=\"为什么建立连接的时候要三次握手\"><a href=\"#为什么建立连接的时候要三次握手\" class=\"headerlink\" title=\"为什么建立连接的时候要三次握手\"></a>为什么建立连接的时候要三次握手</h4><p>防止服务端开启一些无用的连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trect rgba(0, 0, 255, .1)</span><br><span class=\"line\">\t\t\t\tNote over Client,Server: 三次握手，建立TCP连接</span><br><span class=\"line\">        Client-&gt;&gt; + Server: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">  rect rgba(0, 0, 255, .1) </span><br><span class=\"line\">   \t\t\tNote over Client,Server:发送HTTP请求， 传输数据</span><br><span class=\"line\">        Client-&gt;&gt; + Server: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br><span class=\"line\">   </span><br><span class=\"line\">   rect rgba(0, 0, 255, .1)  </span><br><span class=\"line\">   \t\t\tNote over Client,Server:四次挥手， 断开连接</span><br><span class=\"line\">        Client-&gt;&gt; + Server: FIN&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: seq&#x3D;0</span><br><span class=\"line\">   end</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"URI\n\n`Uniform Resource Identifier`/ 统一资源标志符\n\n用来唯一标识互联网上的信息资源\n\n包括URL和URN\n\n## URL\n\n`Uniform Resource Locator` /统一资源定位器\n\nhttp://user:pass@host.com:80/path?query=string#hash\n\n组成：\n\n协议\t域名\t端口\t资源路径\t额外参数\t锚点\n\n`Protocol:// ` `Domain Name` `Port` `Path to the file` `Parameters` `Anchor` \n\n## URN\n\n永久统一资源定位符\n\n在资源移动之后还能找到\n\n目前没有成熟的使用方案\n\n","source":"_posts/HTTP/URI URL URN.md","raw":"URI\n\n`Uniform Resource Identifier`/ 统一资源标志符\n\n用来唯一标识互联网上的信息资源\n\n包括URL和URN\n\n## URL\n\n`Uniform Resource Locator` /统一资源定位器\n\nhttp://user:pass@host.com:80/path?query=string#hash\n\n组成：\n\n协议\t域名\t端口\t资源路径\t额外参数\t锚点\n\n`Protocol:// ` `Domain Name` `Port` `Path to the file` `Parameters` `Anchor` \n\n## URN\n\n永久统一资源定位符\n\n在资源移动之后还能找到\n\n目前没有成熟的使用方案\n\n","slug":"HTTP/URI URL URN","published":1,"date":"2020-06-25T03:10:24.408Z","updated":"2020-06-25T03:10:24.408Z","title":"HTTP/URI URL URN","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnf00053ns6h3zu6vqc","content":"<p>URI</p>\n<p><code>Uniform Resource Identifier</code>/ 统一资源标志符</p>\n<p>用来唯一标识互联网上的信息资源</p>\n<p>包括URL和URN</p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p><code>Uniform Resource Locator</code> /统一资源定位器</p>\n<p><a href=\"http://user:pass@host.com:80/path?query=string#hash\" target=\"_blank\" rel=\"noopener\">http://user:pass@host.com:80/path?query=string#hash</a></p>\n<p>组成：</p>\n<p>协议    域名    端口    资源路径    额外参数    锚点</p>\n<p><code>Protocol://</code> <code>Domain Name</code> <code>Port</code> <code>Path to the file</code> <code>Parameters</code> <code>Anchor</code> </p>\n<h2 id=\"URN\"><a href=\"#URN\" class=\"headerlink\" title=\"URN\"></a>URN</h2><p>永久统一资源定位符</p>\n<p>在资源移动之后还能找到</p>\n<p>目前没有成熟的使用方案</p>\n","site":{"data":{}},"excerpt":"","more":"<p>URI</p>\n<p><code>Uniform Resource Identifier</code>/ 统一资源标志符</p>\n<p>用来唯一标识互联网上的信息资源</p>\n<p>包括URL和URN</p>\n<h2 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a>URL</h2><p><code>Uniform Resource Locator</code> /统一资源定位器</p>\n<p><a href=\"http://user:pass@host.com:80/path?query=string#hash\" target=\"_blank\" rel=\"noopener\">http://user:pass@host.com:80/path?query=string#hash</a></p>\n<p>组成：</p>\n<p>协议    域名    端口    资源路径    额外参数    锚点</p>\n<p><code>Protocol://</code> <code>Domain Name</code> <code>Port</code> <code>Path to the file</code> <code>Parameters</code> <code>Anchor</code> </p>\n<h2 id=\"URN\"><a href=\"#URN\" class=\"headerlink\" title=\"URN\"></a>URN</h2><p>永久统一资源定位符</p>\n<p>在资源移动之后还能找到</p>\n<p>目前没有成熟的使用方案</p>\n"},{"_content":"## 输入地址栏之后\n\n- 域名解析，获取IP地址\n- 三次握手，建立TCP连接\n- HTTP请求，传输数据\n- 四次挥手，关闭TCP连接\n\n## 域名解析，获取IP地址\n\n``` mermaid\ngraph TB \n  A(浏览器DNS缓存查找) --无--> B(操作系统的DNS缓存查找)\n  A --有--> C(结束查找)\n  B --无--> D(操作系统的DNS缓存查找)\n  D --有--> E(结束查找)\n  D --无--> F(操作系统的hosts文件)\n  F --有--> G(结束查找)\n  F --无--> H(浏览器发送域名解析请求到运营商DNS服务器)\n  H --无--> I(各类域名服务器直至根域名服务器)\n  H --有--> J(结束查找)\n  I --结果--> K(通过原路返回告诉浏览器IP/无)\n\n```\n\n\n\n## 三次握手，建立TCP连接\n\n**三次握手，建立TCP连接**\n\n``` mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n        Client->> + Server: Seq=0\n\t\t\t\tServer->>  Client: ACK=Seq+1\n\t\t\t\tClient->> - Server: Seq=ACK+1\n```\n\n![image-20200531221310449](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200531221310449.png)\n\n## 发送HTTP请求\n\n>  建立连接之后，开始发送HTTP请求，与服务器传输数据，如果数据过大会分片传输\n\n**在不同版本的HTTP，传输的过程有不一样**\n\n- HTTP 1.0\n\n  一个连接只能完成一个HTTP请求，比如只能完成一次index.html的响应，而index.html中的 js/css/img则需要另外再建立连接，再重复三次握手的过程\n\n- HTTP 1.1\n\n  一个连接可完成多个HTTP请求，这样index.html中的js/css/img 则不需要再有三次握手的开销，一次TCP连接全搞定\n\n- HTTP 2.0\n\n  一个连接可并发HTTP请求\n\n- HTTP 3.0\n\n\n\n## 四次挥手，关闭请求\n\n可以是客户端发送关闭请求，也可以是服务端关闭\n\n``` mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n        Client->> + Server: FIN=0\n\t\t\t\tServer->>  Client: ACK=Seq+1\n\t\t\t\tClient->>  Server: Seq=ACK+1\n\t\t\t\tClient->> - Server: Seq=ACK+1\n\t\t\t\t\n```\n\n\n\n","source":"_posts/HTTP/在地址栏输入URL后发生了什么.md","raw":"## 输入地址栏之后\n\n- 域名解析，获取IP地址\n- 三次握手，建立TCP连接\n- HTTP请求，传输数据\n- 四次挥手，关闭TCP连接\n\n## 域名解析，获取IP地址\n\n``` mermaid\ngraph TB \n  A(浏览器DNS缓存查找) --无--> B(操作系统的DNS缓存查找)\n  A --有--> C(结束查找)\n  B --无--> D(操作系统的DNS缓存查找)\n  D --有--> E(结束查找)\n  D --无--> F(操作系统的hosts文件)\n  F --有--> G(结束查找)\n  F --无--> H(浏览器发送域名解析请求到运营商DNS服务器)\n  H --无--> I(各类域名服务器直至根域名服务器)\n  H --有--> J(结束查找)\n  I --结果--> K(通过原路返回告诉浏览器IP/无)\n\n```\n\n\n\n## 三次握手，建立TCP连接\n\n**三次握手，建立TCP连接**\n\n``` mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n        Client->> + Server: Seq=0\n\t\t\t\tServer->>  Client: ACK=Seq+1\n\t\t\t\tClient->> - Server: Seq=ACK+1\n```\n\n![image-20200531221310449](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200531221310449.png)\n\n## 发送HTTP请求\n\n>  建立连接之后，开始发送HTTP请求，与服务器传输数据，如果数据过大会分片传输\n\n**在不同版本的HTTP，传输的过程有不一样**\n\n- HTTP 1.0\n\n  一个连接只能完成一个HTTP请求，比如只能完成一次index.html的响应，而index.html中的 js/css/img则需要另外再建立连接，再重复三次握手的过程\n\n- HTTP 1.1\n\n  一个连接可完成多个HTTP请求，这样index.html中的js/css/img 则不需要再有三次握手的开销，一次TCP连接全搞定\n\n- HTTP 2.0\n\n  一个连接可并发HTTP请求\n\n- HTTP 3.0\n\n\n\n## 四次挥手，关闭请求\n\n可以是客户端发送关闭请求，也可以是服务端关闭\n\n``` mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\t\n        Client->> + Server: FIN=0\n\t\t\t\tServer->>  Client: ACK=Seq+1\n\t\t\t\tClient->>  Server: Seq=ACK+1\n\t\t\t\tClient->> - Server: Seq=ACK+1\n\t\t\t\t\n```\n\n\n\n","slug":"HTTP/在地址栏输入URL后发生了什么","published":1,"date":"2020-06-25T03:10:24.408Z","updated":"2020-06-25T03:10:24.408Z","title":"HTTP/在地址栏输入URL后发生了什么","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnh00063ns66xmy8tem","content":"<h2 id=\"输入地址栏之后\"><a href=\"#输入地址栏之后\" class=\"headerlink\" title=\"输入地址栏之后\"></a>输入地址栏之后</h2><ul>\n<li>域名解析，获取IP地址</li>\n<li>三次握手，建立TCP连接</li>\n<li>HTTP请求，传输数据</li>\n<li>四次挥手，关闭TCP连接</li>\n</ul>\n<h2 id=\"域名解析，获取IP地址\"><a href=\"#域名解析，获取IP地址\" class=\"headerlink\" title=\"域名解析，获取IP地址\"></a>域名解析，获取IP地址</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TB </span><br><span class=\"line\">  A(浏览器DNS缓存查找) --无--&gt; B(操作系统的DNS缓存查找)</span><br><span class=\"line\">  A --有--&gt; C(结束查找)</span><br><span class=\"line\">  B --无--&gt; D(操作系统的DNS缓存查找)</span><br><span class=\"line\">  D --有--&gt; E(结束查找)</span><br><span class=\"line\">  D --无--&gt; F(操作系统的hosts文件)</span><br><span class=\"line\">  F --有--&gt; G(结束查找)</span><br><span class=\"line\">  F --无--&gt; H(浏览器发送域名解析请求到运营商DNS服务器)</span><br><span class=\"line\">  H --无--&gt; I(各类域名服务器直至根域名服务器)</span><br><span class=\"line\">  H --有--&gt; J(结束查找)</span><br><span class=\"line\">  I --结果--&gt; K(通过原路返回告诉浏览器IP&#x2F;无)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三次握手，建立TCP连接\"><a href=\"#三次握手，建立TCP连接\" class=\"headerlink\" title=\"三次握手，建立TCP连接\"></a>三次握手，建立TCP连接</h2><p><strong>三次握手，建立TCP连接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">        Client-&gt;&gt; + Server: Seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;Seq+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: Seq&#x3D;ACK+1</span><br></pre></td></tr></table></figure>\n\n<p>![image-20200531221310449](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200531221310449.png)</p>\n<h2 id=\"发送HTTP请求\"><a href=\"#发送HTTP请求\" class=\"headerlink\" title=\"发送HTTP请求\"></a>发送HTTP请求</h2><blockquote>\n<p> 建立连接之后，开始发送HTTP请求，与服务器传输数据，如果数据过大会分片传输</p>\n</blockquote>\n<p><strong>在不同版本的HTTP，传输的过程有不一样</strong></p>\n<ul>\n<li><p>HTTP 1.0</p>\n<p>一个连接只能完成一个HTTP请求，比如只能完成一次index.html的响应，而index.html中的 js/css/img则需要另外再建立连接，再重复三次握手的过程</p>\n</li>\n<li><p>HTTP 1.1</p>\n<p>一个连接可完成多个HTTP请求，这样index.html中的js/css/img 则不需要再有三次握手的开销，一次TCP连接全搞定</p>\n</li>\n<li><p>HTTP 2.0</p>\n<p>一个连接可并发HTTP请求</p>\n</li>\n<li><p>HTTP 3.0</p>\n</li>\n</ul>\n<h2 id=\"四次挥手，关闭请求\"><a href=\"#四次挥手，关闭请求\" class=\"headerlink\" title=\"四次挥手，关闭请求\"></a>四次挥手，关闭请求</h2><p>可以是客户端发送关闭请求，也可以是服务端关闭</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">        Client-&gt;&gt; + Server: FIN&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;Seq+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt;  Server: Seq&#x3D;ACK+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: Seq&#x3D;ACK+1</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"输入地址栏之后\"><a href=\"#输入地址栏之后\" class=\"headerlink\" title=\"输入地址栏之后\"></a>输入地址栏之后</h2><ul>\n<li>域名解析，获取IP地址</li>\n<li>三次握手，建立TCP连接</li>\n<li>HTTP请求，传输数据</li>\n<li>四次挥手，关闭TCP连接</li>\n</ul>\n<h2 id=\"域名解析，获取IP地址\"><a href=\"#域名解析，获取IP地址\" class=\"headerlink\" title=\"域名解析，获取IP地址\"></a>域名解析，获取IP地址</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TB </span><br><span class=\"line\">  A(浏览器DNS缓存查找) --无--&gt; B(操作系统的DNS缓存查找)</span><br><span class=\"line\">  A --有--&gt; C(结束查找)</span><br><span class=\"line\">  B --无--&gt; D(操作系统的DNS缓存查找)</span><br><span class=\"line\">  D --有--&gt; E(结束查找)</span><br><span class=\"line\">  D --无--&gt; F(操作系统的hosts文件)</span><br><span class=\"line\">  F --有--&gt; G(结束查找)</span><br><span class=\"line\">  F --无--&gt; H(浏览器发送域名解析请求到运营商DNS服务器)</span><br><span class=\"line\">  H --无--&gt; I(各类域名服务器直至根域名服务器)</span><br><span class=\"line\">  H --有--&gt; J(结束查找)</span><br><span class=\"line\">  I --结果--&gt; K(通过原路返回告诉浏览器IP&#x2F;无)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三次握手，建立TCP连接\"><a href=\"#三次握手，建立TCP连接\" class=\"headerlink\" title=\"三次握手，建立TCP连接\"></a>三次握手，建立TCP连接</h2><p><strong>三次握手，建立TCP连接</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">        Client-&gt;&gt; + Server: Seq&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;Seq+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: Seq&#x3D;ACK+1</span><br></pre></td></tr></table></figure>\n\n<p>![image-20200531221310449](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200531221310449.png)</p>\n<h2 id=\"发送HTTP请求\"><a href=\"#发送HTTP请求\" class=\"headerlink\" title=\"发送HTTP请求\"></a>发送HTTP请求</h2><blockquote>\n<p> 建立连接之后，开始发送HTTP请求，与服务器传输数据，如果数据过大会分片传输</p>\n</blockquote>\n<p><strong>在不同版本的HTTP，传输的过程有不一样</strong></p>\n<ul>\n<li><p>HTTP 1.0</p>\n<p>一个连接只能完成一个HTTP请求，比如只能完成一次index.html的响应，而index.html中的 js/css/img则需要另外再建立连接，再重复三次握手的过程</p>\n</li>\n<li><p>HTTP 1.1</p>\n<p>一个连接可完成多个HTTP请求，这样index.html中的js/css/img 则不需要再有三次握手的开销，一次TCP连接全搞定</p>\n</li>\n<li><p>HTTP 2.0</p>\n<p>一个连接可并发HTTP请求</p>\n</li>\n<li><p>HTTP 3.0</p>\n</li>\n</ul>\n<h2 id=\"四次挥手，关闭请求\"><a href=\"#四次挥手，关闭请求\" class=\"headerlink\" title=\"四次挥手，关闭请求\"></a>四次挥手，关闭请求</h2><p>可以是客户端发送关闭请求，也可以是服务端关闭</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">\tparticipant Client</span><br><span class=\"line\">\tparticipant Server</span><br><span class=\"line\">\t</span><br><span class=\"line\">        Client-&gt;&gt; + Server: FIN&#x3D;0</span><br><span class=\"line\">\t\t\t\tServer-&gt;&gt;  Client: ACK&#x3D;Seq+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt;  Server: Seq&#x3D;ACK+1</span><br><span class=\"line\">\t\t\t\tClient-&gt;&gt; - Server: Seq&#x3D;ACK+1</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"Accept\n\n​\t\n\nContent\n\n- Content-Type","source":"_posts/HTTP/数据协商.md","raw":"Accept\n\n​\t\n\nContent\n\n- Content-Type","slug":"HTTP/数据协商","published":1,"date":"2020-06-25T03:10:24.408Z","updated":"2020-06-25T03:10:24.408Z","title":"HTTP/数据协商","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wni00073ns67smo2450","content":"<p>Accept</p>\n<p>​    </p>\n<p>Content</p>\n<ul>\n<li>Content-Type</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Accept</p>\n<p>​    </p>\n<p>Content</p>\n<ul>\n<li>Content-Type</li>\n</ul>\n"},{"_content":"HTTP和Web安全模型--[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。\n\n## 关于同域策略\n\n> 不允许浏览器访问跨域的Cookie，ajax请求跨域接口等。同源组成：**协议**，**主机名**，**端口**\n\n同域策略是浏览器的限制，不是服务器限制。服务器会正常的接受和响应来自不同域的请求响应。但浏览器在识别响应头，发现不是同域则会忽略内容并且抛出不是跨域的错误\n\n``` javascript\nAccess to XMLHttpRequest at 'http://127.0.0.1:10000/' from origin 'http://localhost:9999' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n## 跨域限制-预请求\n\n> “需预检的请求”要求必须首先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n### 不会出发预请求的情况\n\n- 请求方法\n  - GET\n  - HEAD\n  - POST\n- [非用户代理自动设置的首部字段](https://fetch.spec.whatwg.org/#forbidden-header-name)\n- 以下三种Content-Type 类型\n  - `text/plain`\n  - `multipart/form-data`\n  - `application/x-www-form-urlencoded`\n- 请求中的任意[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象可以使用 [`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 属性访问。\n- 请求中没有使用 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 对象。\n\n### 预请求的几个部首字段\n\n- Access-Control-Allow-Methods\n\n  表明服务器允许客户端使用的方法发起请求\n\n  ``` HTTP\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 06:58:19 GMT\n  Transfer-Encoding: chunked\n  ```\n\n- Access-Control-Allow-Headers\n\n  表明服务器允许请求中携带的头部字段\n\n  ``` http\n  Access-Control-Allow-Headers: X-TEST-CORS\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 07:01:47 GMT\n  Transfer-Encoding: chunked\n  ```\n\n- Access-Control-Max-Age\n\n  在有效时间内，浏览器无需为同一请求再发起预检请求（减少请求次数）\n\n  ``` http\n  Access-Control-Allow-Headers: X-TEST-CORS\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Access-Control-Max-Age: 1000\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 07:05:16 GMT\n  Transfer-Encoding: chunked\n  ```\n\n  ","source":"_posts/HTTP/浏览器的安全策略.md","raw":"HTTP和Web安全模型--[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。\n\n## 关于同域策略\n\n> 不允许浏览器访问跨域的Cookie，ajax请求跨域接口等。同源组成：**协议**，**主机名**，**端口**\n\n同域策略是浏览器的限制，不是服务器限制。服务器会正常的接受和响应来自不同域的请求响应。但浏览器在识别响应头，发现不是同域则会忽略内容并且抛出不是跨域的错误\n\n``` javascript\nAccess to XMLHttpRequest at 'http://127.0.0.1:10000/' from origin 'http://localhost:9999' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n## 跨域限制-预请求\n\n> “需预检的请求”要求必须首先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n### 不会出发预请求的情况\n\n- 请求方法\n  - GET\n  - HEAD\n  - POST\n- [非用户代理自动设置的首部字段](https://fetch.spec.whatwg.org/#forbidden-header-name)\n- 以下三种Content-Type 类型\n  - `text/plain`\n  - `multipart/form-data`\n  - `application/x-www-form-urlencoded`\n- 请求中的任意[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象可以使用 [`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 属性访问。\n- 请求中没有使用 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 对象。\n\n### 预请求的几个部首字段\n\n- Access-Control-Allow-Methods\n\n  表明服务器允许客户端使用的方法发起请求\n\n  ``` HTTP\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 06:58:19 GMT\n  Transfer-Encoding: chunked\n  ```\n\n- Access-Control-Allow-Headers\n\n  表明服务器允许请求中携带的头部字段\n\n  ``` http\n  Access-Control-Allow-Headers: X-TEST-CORS\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 07:01:47 GMT\n  Transfer-Encoding: chunked\n  ```\n\n- Access-Control-Max-Age\n\n  在有效时间内，浏览器无需为同一请求再发起预检请求（减少请求次数）\n\n  ``` http\n  Access-Control-Allow-Headers: X-TEST-CORS\n  Access-Control-Allow-Methods: PUT\n  Access-Control-Allow-Origin: http://localhost:9999\n  Access-Control-Max-Age: 1000\n  Connection: keep-alive\n  Date: Wed, 10 Jun 2020 07:05:16 GMT\n  Transfer-Encoding: chunked\n  ```\n\n  ","slug":"HTTP/浏览器的安全策略","published":1,"date":"2020-06-25T03:10:24.408Z","updated":"2020-06-25T03:10:24.408Z","title":"HTTP/浏览器的安全策略","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnj00083ns6645k85d3","content":"<p>HTTP和Web安全模型–<a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">同源策略</a>是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。</p>\n<h2 id=\"关于同域策略\"><a href=\"#关于同域策略\" class=\"headerlink\" title=\"关于同域策略\"></a>关于同域策略</h2><blockquote>\n<p>不允许浏览器访问跨域的Cookie，ajax请求跨域接口等。同源组成：<strong>协议</strong>，<strong>主机名</strong>，<strong>端口</strong></p>\n</blockquote>\n<p>同域策略是浏览器的限制，不是服务器限制。服务器会正常的接受和响应来自不同域的请求响应。但浏览器在识别响应头，发现不是同域则会忽略内容并且抛出不是跨域的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access to XMLHttpRequest at <span class=\"string\">'http://127.0.0.1:10000/'</span> <span class=\"keyword\">from</span> origin <span class=\"string\">'http://localhost:9999'</span> has been blocked by CORS policy: No <span class=\"string\">'Access-Control-Allow-Origin'</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"跨域限制-预请求\"><a href=\"#跨域限制-预请求\" class=\"headerlink\" title=\"跨域限制-预请求\"></a>跨域限制-预请求</h2><blockquote>\n<p>“需预检的请求”要求必须首先使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS\" target=\"_blank\" rel=\"noopener\"><code>OPTIONS</code></a>  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n</blockquote>\n<h3 id=\"不会出发预请求的情况\"><a href=\"#不会出发预请求的情况\" class=\"headerlink\" title=\"不会出发预请求的情况\"></a>不会出发预请求的情况</h3><ul>\n<li>请求方法<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n</li>\n<li><a href=\"https://fetch.spec.whatwg.org/#forbidden-header-name\" target=\"_blank\" rel=\"noopener\">非用户代理自动设置的首部字段</a></li>\n<li>以下三种Content-Type 类型<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n<li>请求中的任意<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequest.upload</code></a> 属性访问。</li>\n<li>请求中没有使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\" target=\"_blank\" rel=\"noopener\"><code>ReadableStream</code></a> 对象。</li>\n</ul>\n<h3 id=\"预请求的几个部首字段\"><a href=\"#预请求的几个部首字段\" class=\"headerlink\" title=\"预请求的几个部首字段\"></a>预请求的几个部首字段</h3><ul>\n<li><p>Access-Control-Allow-Methods</p>\n<p>表明服务器允许客户端使用的方法发起请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 06:58:19 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Access-Control-Allow-Headers</p>\n<p>表明服务器允许请求中携带的头部字段</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span>: X-TEST-CORS</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 07:01:47 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Access-Control-Max-Age</p>\n<p>在有效时间内，浏览器无需为同一请求再发起预检请求（减少请求次数）</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span>: X-TEST-CORS</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Max-Age</span>: 1000</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 07:05:16 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP和Web安全模型–<a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener\">同源策略</a>是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的。</p>\n<h2 id=\"关于同域策略\"><a href=\"#关于同域策略\" class=\"headerlink\" title=\"关于同域策略\"></a>关于同域策略</h2><blockquote>\n<p>不允许浏览器访问跨域的Cookie，ajax请求跨域接口等。同源组成：<strong>协议</strong>，<strong>主机名</strong>，<strong>端口</strong></p>\n</blockquote>\n<p>同域策略是浏览器的限制，不是服务器限制。服务器会正常的接受和响应来自不同域的请求响应。但浏览器在识别响应头，发现不是同域则会忽略内容并且抛出不是跨域的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access to XMLHttpRequest at <span class=\"string\">'http://127.0.0.1:10000/'</span> <span class=\"keyword\">from</span> origin <span class=\"string\">'http://localhost:9999'</span> has been blocked by CORS policy: No <span class=\"string\">'Access-Control-Allow-Origin'</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"跨域限制-预请求\"><a href=\"#跨域限制-预请求\" class=\"headerlink\" title=\"跨域限制-预请求\"></a>跨域限制-预请求</h2><blockquote>\n<p>“需预检的请求”要求必须首先使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS\" target=\"_blank\" rel=\"noopener\"><code>OPTIONS</code></a>  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n</blockquote>\n<h3 id=\"不会出发预请求的情况\"><a href=\"#不会出发预请求的情况\" class=\"headerlink\" title=\"不会出发预请求的情况\"></a>不会出发预请求的情况</h3><ul>\n<li>请求方法<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n</li>\n<li><a href=\"https://fetch.spec.whatwg.org/#forbidden-header-name\" target=\"_blank\" rel=\"noopener\">非用户代理自动设置的首部字段</a></li>\n<li>以下三种Content-Type 类型<ul>\n<li><code>text/plain</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>application/x-www-form-urlencoded</code></li>\n</ul>\n</li>\n<li>请求中的任意<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequestUpload</code></a> 对象均没有注册任何事件监听器；<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequestUpload</code></a> 对象可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload\" target=\"_blank\" rel=\"noopener\"><code>XMLHttpRequest.upload</code></a> 属性访问。</li>\n<li>请求中没有使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\" target=\"_blank\" rel=\"noopener\"><code>ReadableStream</code></a> 对象。</li>\n</ul>\n<h3 id=\"预请求的几个部首字段\"><a href=\"#预请求的几个部首字段\" class=\"headerlink\" title=\"预请求的几个部首字段\"></a>预请求的几个部首字段</h3><ul>\n<li><p>Access-Control-Allow-Methods</p>\n<p>表明服务器允许客户端使用的方法发起请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 06:58:19 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Access-Control-Allow-Headers</p>\n<p>表明服务器允许请求中携带的头部字段</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span>: X-TEST-CORS</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 07:01:47 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Access-Control-Max-Age</p>\n<p>在有效时间内，浏览器无需为同一请求再发起预检请求（减少请求次数）</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span>: X-TEST-CORS</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span>: PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span>: http://localhost:9999</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Max-Age</span>: 1000</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Wed, 10 Jun 2020 07:05:16 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n"},{"_content":"专门用于浏览器端，模块加载时异步的\n\n- AMD 历史\n- AMD 规范简介\n- AMD 原理\n- AMD 的特点\n- AMD 相对于 CommonJS 的优缺点\n- AMD 的实现（RequireJS）\n  - NoAMD\n  - RequireJS\n","source":"_posts/JavaScript模块化/AMD.md","raw":"专门用于浏览器端，模块加载时异步的\n\n- AMD 历史\n- AMD 规范简介\n- AMD 原理\n- AMD 的特点\n- AMD 相对于 CommonJS 的优缺点\n- AMD 的实现（RequireJS）\n  - NoAMD\n  - RequireJS\n","slug":"JavaScript模块化/AMD","published":1,"date":"2020-06-25T03:10:24.410Z","updated":"2020-06-25T03:10:24.410Z","title":"JavaScript模块化/AMD","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnk00093ns67x0kc12s","content":"<p>专门用于浏览器端，模块加载时异步的</p>\n<ul>\n<li>AMD 历史</li>\n<li>AMD 规范简介</li>\n<li>AMD 原理</li>\n<li>AMD 的特点</li>\n<li>AMD 相对于 CommonJS 的优缺点</li>\n<li>AMD 的实现（RequireJS）<ul>\n<li>NoAMD</li>\n<li>RequireJS</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>专门用于浏览器端，模块加载时异步的</p>\n<ul>\n<li>AMD 历史</li>\n<li>AMD 规范简介</li>\n<li>AMD 原理</li>\n<li>AMD 的特点</li>\n<li>AMD 相对于 CommonJS 的优缺点</li>\n<li>AMD 的实现（RequireJS）<ul>\n<li>NoAMD</li>\n<li>RequireJS</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"## 引言\n\n> 模块虽然解偶了代码，使得代码易于维护等等好处。但一个项目往往中有若干个以上的模块，模块多以及模块间的依赖导致了<u>HTTP请求响应次数过多</u>以及<u>依赖模糊</u>问题，直接导致项目<u>难以维护</u>，而引发了模块的管理问题。\n\n这时候出现**模块化规范**，则是解决模块化带来的问题。模块化规范的常用几种：\n\n- **CommonJS**\n- **AMD**\n- **CMD**\n- **ES6 **\n\n\n","source":"_posts/JavaScript模块化/模块化的规范.md","raw":"## 引言\n\n> 模块虽然解偶了代码，使得代码易于维护等等好处。但一个项目往往中有若干个以上的模块，模块多以及模块间的依赖导致了<u>HTTP请求响应次数过多</u>以及<u>依赖模糊</u>问题，直接导致项目<u>难以维护</u>，而引发了模块的管理问题。\n\n这时候出现**模块化规范**，则是解决模块化带来的问题。模块化规范的常用几种：\n\n- **CommonJS**\n- **AMD**\n- **CMD**\n- **ES6 **\n\n\n","slug":"JavaScript模块化/模块化的规范","published":1,"date":"2020-06-25T03:10:24.410Z","updated":"2020-06-25T03:10:24.410Z","title":"JavaScript模块化/模块化的规范","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnm000a3ns67664bz7s","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><blockquote>\n<p>模块虽然解偶了代码，使得代码易于维护等等好处。但一个项目往往中有若干个以上的模块，模块多以及模块间的依赖导致了<u>HTTP请求响应次数过多</u>以及<u>依赖模糊</u>问题，直接导致项目<u>难以维护</u>，而引发了模块的管理问题。</p>\n</blockquote>\n<p>这时候出现<strong>模块化规范</strong>，则是解决模块化带来的问题。模块化规范的常用几种：</p>\n<ul>\n<li><strong>CommonJS</strong></li>\n<li><strong>AMD</strong></li>\n<li><strong>CMD</strong></li>\n<li>*<em>ES6 *</em></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><blockquote>\n<p>模块虽然解偶了代码，使得代码易于维护等等好处。但一个项目往往中有若干个以上的模块，模块多以及模块间的依赖导致了<u>HTTP请求响应次数过多</u>以及<u>依赖模糊</u>问题，直接导致项目<u>难以维护</u>，而引发了模块的管理问题。</p>\n</blockquote>\n<p>这时候出现<strong>模块化规范</strong>，则是解决模块化带来的问题。模块化规范的常用几种：</p>\n<ul>\n<li><strong>CommonJS</strong></li>\n<li><strong>AMD</strong></li>\n<li><strong>CMD</strong></li>\n<li>*<em>ES6 *</em></li>\n</ul>\n"},{"_content":"## 历史由来[wiki](https://zh.wikipedia.org/wiki/CommonJS)\n\n> CommonJS 是一个项目，创建的主要原因是当时缺乏普遍可接受形式的 JavaScript 脚本模块单元，模块在与运行 JavaScript 脚本的常规网页浏览器所提供的不同的环境下可以重复使用\n\n2009 年 1 月由[Mozilla](https://zh.wikipedia.org/wiki/Mozilla)工程师 Kevin Dangoor 发起，起初命名“ServerJS”。在 2009 年 8 月，这个项目被改为“CommonJS”来展示其[API](https://zh.wikipedia.org/wiki/API)的广泛的应用性。\n\n2013 年 5 月，[Node.js](https://zh.wikipedia.org/wiki/Node.js)包管理器[npm](https://zh.wikipedia.org/wiki/Npm)的作者 Isaac Z. Schlueter，宣布 Node.js 已经废弃了 CommonJS。后续，NodeJS 在计划使用 [ES6 模块系统](https://nodejs.org/api/esm.html#esm_ecmascript_modules)\n\nJavaScript 一一直没有模块化的概念，直到 2009 年 Node.js 的出现，模块化成了必要实现。因此 Node.js 首先在服务端实现了 CommonJS 规范的模块系统。\n\n而后[Browserify](https://github.com/browserify)实现了浏览器端的 CommonJS 规范，自此之后，使得浏览器端的代码能以以模块化方式运行，并能使用 npm 上传、维护以及使用 JavaScript 模块\n\n## CommonJS 约定简述[Modules/1.1.1](http://wiki.commonjs.org/wiki/Modules/1.1.1)\n\n### 首先简述 CommonJS 中的模块是什么？\n\n每个文件都是一个模块，有自己的作用域。\n\n每个文件里面变量、函数等等都是私有的 ，提供导出功能来选择开发哪些变量、函数等等，并可依赖其他模块。\n\n### CommonJS 规范约定模块的实现\n\n#### Module\n\n每个文件可以看成一个 Module;\n\nModule 是一个对象，\n\n- 包含属性 id：唯一的标识符；\n- 可能具备包含属性 uri，都是用来标识 module 的唯一性。\n\n- Module 包含自由变量`require`\n\n- Module 包含自由变量`exports`，`exports`作为唯一的导出方法，`exports`可以在执行时向其添加 API 的对象。\n\n#### Require\n\n用来加载需要的模块\n\n```javascript\nrequire(module.id / uri)\n```\n\nRequire 是一个函数，接受模块标识符/路径（`module.id`/`uri`），返回外部模块导出 API。\n\n```javascript\nvar path = require('path') // 标识符，一般是引用第三方模块\nvar myCalc = require('./tool/calc') // 路径，一般为项目自定义模块时\n\nvar result = myCalc.add(2, 3) // 使用模块开放的方法\n```\n\n#### exports\n\n也就是向外暴露模块。\n\n作为唯一的导出方法,可以在执行时向其添加 API 的对象。\n\n语法上有两种方式：\n\n###### module.exports = 任意类型\n\n```javascript\nvar foo = function () {\n  // 方法体\n}\nmodule.exports = foo\n```\n\n###### exports.xxx = 任意类型\n\n```javascript\nconst name = 'john'\n\nconst nums = [1, 4, 3, 5]\n\nfunction showName() {\n  console.log(name)\n}\n\nexports.name = name\nexports.nums = nums\nexports.showName = showName\n```\n\n## 具体实现\n\n有一点很重要，CommonJS 模块是同步加载的\n\n- 服务器端，NodeJS 是 CommonJS 规范的实现 - [demo](https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS)\n- 浏览器端，Browserify 是 CommonJS 规范的实现- [demo](https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS)\n","source":"_posts/JavaScript模块化/CommonJS.md","raw":"## 历史由来[wiki](https://zh.wikipedia.org/wiki/CommonJS)\n\n> CommonJS 是一个项目，创建的主要原因是当时缺乏普遍可接受形式的 JavaScript 脚本模块单元，模块在与运行 JavaScript 脚本的常规网页浏览器所提供的不同的环境下可以重复使用\n\n2009 年 1 月由[Mozilla](https://zh.wikipedia.org/wiki/Mozilla)工程师 Kevin Dangoor 发起，起初命名“ServerJS”。在 2009 年 8 月，这个项目被改为“CommonJS”来展示其[API](https://zh.wikipedia.org/wiki/API)的广泛的应用性。\n\n2013 年 5 月，[Node.js](https://zh.wikipedia.org/wiki/Node.js)包管理器[npm](https://zh.wikipedia.org/wiki/Npm)的作者 Isaac Z. Schlueter，宣布 Node.js 已经废弃了 CommonJS。后续，NodeJS 在计划使用 [ES6 模块系统](https://nodejs.org/api/esm.html#esm_ecmascript_modules)\n\nJavaScript 一一直没有模块化的概念，直到 2009 年 Node.js 的出现，模块化成了必要实现。因此 Node.js 首先在服务端实现了 CommonJS 规范的模块系统。\n\n而后[Browserify](https://github.com/browserify)实现了浏览器端的 CommonJS 规范，自此之后，使得浏览器端的代码能以以模块化方式运行，并能使用 npm 上传、维护以及使用 JavaScript 模块\n\n## CommonJS 约定简述[Modules/1.1.1](http://wiki.commonjs.org/wiki/Modules/1.1.1)\n\n### 首先简述 CommonJS 中的模块是什么？\n\n每个文件都是一个模块，有自己的作用域。\n\n每个文件里面变量、函数等等都是私有的 ，提供导出功能来选择开发哪些变量、函数等等，并可依赖其他模块。\n\n### CommonJS 规范约定模块的实现\n\n#### Module\n\n每个文件可以看成一个 Module;\n\nModule 是一个对象，\n\n- 包含属性 id：唯一的标识符；\n- 可能具备包含属性 uri，都是用来标识 module 的唯一性。\n\n- Module 包含自由变量`require`\n\n- Module 包含自由变量`exports`，`exports`作为唯一的导出方法，`exports`可以在执行时向其添加 API 的对象。\n\n#### Require\n\n用来加载需要的模块\n\n```javascript\nrequire(module.id / uri)\n```\n\nRequire 是一个函数，接受模块标识符/路径（`module.id`/`uri`），返回外部模块导出 API。\n\n```javascript\nvar path = require('path') // 标识符，一般是引用第三方模块\nvar myCalc = require('./tool/calc') // 路径，一般为项目自定义模块时\n\nvar result = myCalc.add(2, 3) // 使用模块开放的方法\n```\n\n#### exports\n\n也就是向外暴露模块。\n\n作为唯一的导出方法,可以在执行时向其添加 API 的对象。\n\n语法上有两种方式：\n\n###### module.exports = 任意类型\n\n```javascript\nvar foo = function () {\n  // 方法体\n}\nmodule.exports = foo\n```\n\n###### exports.xxx = 任意类型\n\n```javascript\nconst name = 'john'\n\nconst nums = [1, 4, 3, 5]\n\nfunction showName() {\n  console.log(name)\n}\n\nexports.name = name\nexports.nums = nums\nexports.showName = showName\n```\n\n## 具体实现\n\n有一点很重要，CommonJS 模块是同步加载的\n\n- 服务器端，NodeJS 是 CommonJS 规范的实现 - [demo](https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS)\n- 浏览器端，Browserify 是 CommonJS 规范的实现- [demo](https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS)\n","slug":"JavaScript模块化/CommonJS","published":1,"date":"2020-06-25T03:10:24.410Z","updated":"2020-06-25T15:20:23.532Z","title":"JavaScript模块化/CommonJS","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wno000b3ns65n9le4z4","content":"<h2 id=\"历史由来wiki\"><a href=\"#历史由来wiki\" class=\"headerlink\" title=\"历史由来wiki\"></a>历史由来<a href=\"https://zh.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"noopener\">wiki</a></h2><blockquote>\n<p>CommonJS 是一个项目，创建的主要原因是当时缺乏普遍可接受形式的 JavaScript 脚本模块单元，模块在与运行 JavaScript 脚本的常规网页浏览器所提供的不同的环境下可以重复使用</p>\n</blockquote>\n<p>2009 年 1 月由<a href=\"https://zh.wikipedia.org/wiki/Mozilla\" target=\"_blank\" rel=\"noopener\">Mozilla</a>工程师 Kevin Dangoor 发起，起初命名“ServerJS”。在 2009 年 8 月，这个项目被改为“CommonJS”来展示其<a href=\"https://zh.wikipedia.org/wiki/API\" target=\"_blank\" rel=\"noopener\">API</a>的广泛的应用性。</p>\n<p>2013 年 5 月，<a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">Node.js</a>包管理器<a href=\"https://zh.wikipedia.org/wiki/Npm\" target=\"_blank\" rel=\"noopener\">npm</a>的作者 Isaac Z. Schlueter，宣布 Node.js 已经废弃了 CommonJS。后续，NodeJS 在计划使用 <a href=\"https://nodejs.org/api/esm.html#esm_ecmascript_modules\" target=\"_blank\" rel=\"noopener\">ES6 模块系统</a></p>\n<p>JavaScript 一一直没有模块化的概念，直到 2009 年 Node.js 的出现，模块化成了必要实现。因此 Node.js 首先在服务端实现了 CommonJS 规范的模块系统。</p>\n<p>而后<a href=\"https://github.com/browserify\" target=\"_blank\" rel=\"noopener\">Browserify</a>实现了浏览器端的 CommonJS 规范，自此之后，使得浏览器端的代码能以以模块化方式运行，并能使用 npm 上传、维护以及使用 JavaScript 模块</p>\n<h2 id=\"CommonJS-约定简述Modules-1-1-1\"><a href=\"#CommonJS-约定简述Modules-1-1-1\" class=\"headerlink\" title=\"CommonJS 约定简述Modules/1.1.1\"></a>CommonJS 约定简述<a href=\"http://wiki.commonjs.org/wiki/Modules/1.1.1\" target=\"_blank\" rel=\"noopener\">Modules/1.1.1</a></h2><h3 id=\"首先简述-CommonJS-中的模块是什么？\"><a href=\"#首先简述-CommonJS-中的模块是什么？\" class=\"headerlink\" title=\"首先简述 CommonJS 中的模块是什么？\"></a>首先简述 CommonJS 中的模块是什么？</h3><p>每个文件都是一个模块，有自己的作用域。</p>\n<p>每个文件里面变量、函数等等都是私有的 ，提供导出功能来选择开发哪些变量、函数等等，并可依赖其他模块。</p>\n<h3 id=\"CommonJS-规范约定模块的实现\"><a href=\"#CommonJS-规范约定模块的实现\" class=\"headerlink\" title=\"CommonJS 规范约定模块的实现\"></a>CommonJS 规范约定模块的实现</h3><h4 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h4><p>每个文件可以看成一个 Module;</p>\n<p>Module 是一个对象，</p>\n<ul>\n<li><p>包含属性 id：唯一的标识符；</p>\n</li>\n<li><p>可能具备包含属性 uri，都是用来标识 module 的唯一性。</p>\n</li>\n<li><p>Module 包含自由变量<code>require</code></p>\n</li>\n<li><p>Module 包含自由变量<code>exports</code>，<code>exports</code>作为唯一的导出方法，<code>exports</code>可以在执行时向其添加 API 的对象。</p>\n</li>\n</ul>\n<h4 id=\"Require\"><a href=\"#Require\" class=\"headerlink\" title=\"Require\"></a>Require</h4><p>用来加载需要的模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"built_in\">module</span>.id / uri)</span><br></pre></td></tr></table></figure>\n\n<p>Require 是一个函数，接受模块标识符/路径（<code>module.id</code>/<code>uri</code>），返回外部模块导出 API。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>) <span class=\"comment\">// 标识符，一般是引用第三方模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myCalc = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool/calc'</span>) <span class=\"comment\">// 路径，一般为项目自定义模块时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = myCalc.add(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 使用模块开放的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"exports\"></a>exports</h4><p>也就是向外暴露模块。</p>\n<p>作为唯一的导出方法,可以在执行时向其添加 API 的对象。</p>\n<p>语法上有两种方式：</p>\n<h6 id=\"module-exports-任意类型\"><a href=\"#module-exports-任意类型\" class=\"headerlink\" title=\"module.exports = 任意类型\"></a>module.exports = 任意类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = foo</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"exports-xxx-任意类型\"><a href=\"#exports-xxx-任意类型\" class=\"headerlink\" title=\"exports.xxx = 任意类型\"></a>exports.xxx = 任意类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'john'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.name = name</span><br><span class=\"line\">exports.nums = nums</span><br><span class=\"line\">exports.showName = showName</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>有一点很重要，CommonJS 模块是同步加载的</p>\n<ul>\n<li>服务器端，NodeJS 是 CommonJS 规范的实现 - <a href=\"https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n<li>浏览器端，Browserify 是 CommonJS 规范的实现- <a href=\"https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"历史由来wiki\"><a href=\"#历史由来wiki\" class=\"headerlink\" title=\"历史由来wiki\"></a>历史由来<a href=\"https://zh.wikipedia.org/wiki/CommonJS\" target=\"_blank\" rel=\"noopener\">wiki</a></h2><blockquote>\n<p>CommonJS 是一个项目，创建的主要原因是当时缺乏普遍可接受形式的 JavaScript 脚本模块单元，模块在与运行 JavaScript 脚本的常规网页浏览器所提供的不同的环境下可以重复使用</p>\n</blockquote>\n<p>2009 年 1 月由<a href=\"https://zh.wikipedia.org/wiki/Mozilla\" target=\"_blank\" rel=\"noopener\">Mozilla</a>工程师 Kevin Dangoor 发起，起初命名“ServerJS”。在 2009 年 8 月，这个项目被改为“CommonJS”来展示其<a href=\"https://zh.wikipedia.org/wiki/API\" target=\"_blank\" rel=\"noopener\">API</a>的广泛的应用性。</p>\n<p>2013 年 5 月，<a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">Node.js</a>包管理器<a href=\"https://zh.wikipedia.org/wiki/Npm\" target=\"_blank\" rel=\"noopener\">npm</a>的作者 Isaac Z. Schlueter，宣布 Node.js 已经废弃了 CommonJS。后续，NodeJS 在计划使用 <a href=\"https://nodejs.org/api/esm.html#esm_ecmascript_modules\" target=\"_blank\" rel=\"noopener\">ES6 模块系统</a></p>\n<p>JavaScript 一一直没有模块化的概念，直到 2009 年 Node.js 的出现，模块化成了必要实现。因此 Node.js 首先在服务端实现了 CommonJS 规范的模块系统。</p>\n<p>而后<a href=\"https://github.com/browserify\" target=\"_blank\" rel=\"noopener\">Browserify</a>实现了浏览器端的 CommonJS 规范，自此之后，使得浏览器端的代码能以以模块化方式运行，并能使用 npm 上传、维护以及使用 JavaScript 模块</p>\n<h2 id=\"CommonJS-约定简述Modules-1-1-1\"><a href=\"#CommonJS-约定简述Modules-1-1-1\" class=\"headerlink\" title=\"CommonJS 约定简述Modules/1.1.1\"></a>CommonJS 约定简述<a href=\"http://wiki.commonjs.org/wiki/Modules/1.1.1\" target=\"_blank\" rel=\"noopener\">Modules/1.1.1</a></h2><h3 id=\"首先简述-CommonJS-中的模块是什么？\"><a href=\"#首先简述-CommonJS-中的模块是什么？\" class=\"headerlink\" title=\"首先简述 CommonJS 中的模块是什么？\"></a>首先简述 CommonJS 中的模块是什么？</h3><p>每个文件都是一个模块，有自己的作用域。</p>\n<p>每个文件里面变量、函数等等都是私有的 ，提供导出功能来选择开发哪些变量、函数等等，并可依赖其他模块。</p>\n<h3 id=\"CommonJS-规范约定模块的实现\"><a href=\"#CommonJS-规范约定模块的实现\" class=\"headerlink\" title=\"CommonJS 规范约定模块的实现\"></a>CommonJS 规范约定模块的实现</h3><h4 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h4><p>每个文件可以看成一个 Module;</p>\n<p>Module 是一个对象，</p>\n<ul>\n<li><p>包含属性 id：唯一的标识符；</p>\n</li>\n<li><p>可能具备包含属性 uri，都是用来标识 module 的唯一性。</p>\n</li>\n<li><p>Module 包含自由变量<code>require</code></p>\n</li>\n<li><p>Module 包含自由变量<code>exports</code>，<code>exports</code>作为唯一的导出方法，<code>exports</code>可以在执行时向其添加 API 的对象。</p>\n</li>\n</ul>\n<h4 id=\"Require\"><a href=\"#Require\" class=\"headerlink\" title=\"Require\"></a>Require</h4><p>用来加载需要的模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"built_in\">module</span>.id / uri)</span><br></pre></td></tr></table></figure>\n\n<p>Require 是一个函数，接受模块标识符/路径（<code>module.id</code>/<code>uri</code>），返回外部模块导出 API。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>) <span class=\"comment\">// 标识符，一般是引用第三方模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myCalc = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool/calc'</span>) <span class=\"comment\">// 路径，一般为项目自定义模块时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = myCalc.add(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 使用模块开放的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"exports\"><a href=\"#exports\" class=\"headerlink\" title=\"exports\"></a>exports</h4><p>也就是向外暴露模块。</p>\n<p>作为唯一的导出方法,可以在执行时向其添加 API 的对象。</p>\n<p>语法上有两种方式：</p>\n<h6 id=\"module-exports-任意类型\"><a href=\"#module-exports-任意类型\" class=\"headerlink\" title=\"module.exports = 任意类型\"></a>module.exports = 任意类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = foo</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"exports-xxx-任意类型\"><a href=\"#exports-xxx-任意类型\" class=\"headerlink\" title=\"exports.xxx = 任意类型\"></a>exports.xxx = 任意类型</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'john'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.name = name</span><br><span class=\"line\">exports.nums = nums</span><br><span class=\"line\">exports.showName = showName</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>有一点很重要，CommonJS 模块是同步加载的</p>\n<ul>\n<li>服务器端，NodeJS 是 CommonJS 规范的实现 - <a href=\"https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n<li>浏览器端，Browserify 是 CommonJS 规范的实现- <a href=\"https://github.com/antqi/test/tree/master/JavaScript模块化/5-CommonJS\" target=\"_blank\" rel=\"noopener\">demo</a></li>\n</ul>\n"},{"_content":"## 什么是模块化\n\n#### 什么是模块\n\n将一个复杂的程序，依据一定的规则（规范，业务、功能等等）封装成几个块（文件），并进行组合在一起\n\n块内部数据/实现是私有的，对外暴露一些方法（API）供其他模块调用（通信）\n\nPS：设计原则，高内聚低耦合等等，主要目的为了解偶，减少单个程序的复杂性和增加可维护性。\n\n#### 模块化的进程\n\n##### global，全局模式\n\n方法和变量在全局环境中，当方法越来越多的时候\n\n- 容易造成命名冲突\n- 项目难以维护管理\n- 引发全局污染\n\n``` javascript\n// 全局环境\nfunction foo(){}\n\nfunction bar(){}\n```\n\n##### 简单封装：namespace 命名空间模式\n\n- 减少了global上变量的数量\n- 本质上是对象，可以直接操作变量的属性，数据是不安全的\n\n``` javascript\n// 全局环境\nvar APP={\n  message:'Hi',\n  foo:function(){},\n  bar:function(){\n    console.log(this.message)\n  }\n}\n```\n\n##### 匿名闭包：IIFE模式\n\n- 变量是私有的，除了提供方法外，不能改变\n\n- 其他模块不能是全局的，如果需要依赖其他模块呢？\n\n``` javascript\n// 全局环境\n(function(){\n  let message='Hi';\n  \n  function foo(){\n    console.log(message)\n  }\n  \n  window.foo=foo\n})()\n```\n\n##### IIFE模式plus：引入依赖\n\n- 解决依赖其他模块问题\n\n``` javascript\n// 全局环境\n(function(env,$){\n  let message='Hi';\n  \n  function getEleById(id){\n   \treturn $(id)\n  }\n  \n  env.getEleById=getEleById\n})(window,jQuery)\n```\n\n\n\n## 为什么要模块化\n\n- **解偶，提高可维护性**\n\n  比如：弹窗功能，负责弹窗显示信息，支付模块负责接收订单信息并计算，不需要显示信息。\n\n  如此，弹窗错了，则维护弹窗，不需要修改其他模块信息。支付算法修改，修改支付模块，不需要去改弹窗模块。降低功能间的耦合度，提高代码可维护性\n\n- **减少单个模块的复杂度**\n\n  一个表单具备收集信息、验证信息以及提交信息道服务器功能。\n\n  而这里可以再此拆解出：收集信息模块、验证信息模块、以及提交信息。\n\n  如此，当验证条件有变化的时候，我只需要去修改验证模块。减少整个表单开发的复杂度。\n\n  清晰的归类模块化，减少程序的复杂度。\n\n- **便于部署，减少HTTP请求响应**\n\n  比如纯粹的列表信息显示，完全没必要引入支付模块\n\n\n\n## 模块化的利弊\n\n> **模块化解决了一些代码层面的问题，但也带来了模块管理问题**\n\n#### 利\n\n- 避免命名冲突-（避免命名空间污染）\n- 降低代码耦合度，提高可维护性\n- 复用性强\n- 更好的分类，利于按需加载，减少不必要的HTTP请求响应\n\n#### 弊\n\n``` html\n<script src=\"a.js\"></script>\n<script src=\"b.js\"></script>\n<!-- ... \n\t如果这里有若干个script ，必然会导致HTTP请求响应数过多，从而导致加载渲染时阻塞，影响网页体验\n--> \n<script>\n  // 模块化解决了变量私有，可引入依赖的问题\n  /*\n    这里有两个问题(b依赖a )\n      - 如果a和b调换顺序呢\n      - 在上面的基础上，这里有多大20个模块，并且存在依赖关系的时候呢？\n        这就导致了依赖模糊\n   */\n</script>\n```\n\n\n\n- 请求多\n\n  模块拆解导致原有一个文件，变成了多个文件\n\n- 依赖的模块很多，导致依赖模糊\n\n  依赖顺序模糊，容易出错\n\n- 难以维护\n\n  过多的模块以及模糊的依赖，导致模块化变的难以维护\n\n\n\n> **如何解决模块化带来的弊：<u>规范模块化</u>**\n\n","source":"_posts/JavaScript模块化/模块化进程.md","raw":"## 什么是模块化\n\n#### 什么是模块\n\n将一个复杂的程序，依据一定的规则（规范，业务、功能等等）封装成几个块（文件），并进行组合在一起\n\n块内部数据/实现是私有的，对外暴露一些方法（API）供其他模块调用（通信）\n\nPS：设计原则，高内聚低耦合等等，主要目的为了解偶，减少单个程序的复杂性和增加可维护性。\n\n#### 模块化的进程\n\n##### global，全局模式\n\n方法和变量在全局环境中，当方法越来越多的时候\n\n- 容易造成命名冲突\n- 项目难以维护管理\n- 引发全局污染\n\n``` javascript\n// 全局环境\nfunction foo(){}\n\nfunction bar(){}\n```\n\n##### 简单封装：namespace 命名空间模式\n\n- 减少了global上变量的数量\n- 本质上是对象，可以直接操作变量的属性，数据是不安全的\n\n``` javascript\n// 全局环境\nvar APP={\n  message:'Hi',\n  foo:function(){},\n  bar:function(){\n    console.log(this.message)\n  }\n}\n```\n\n##### 匿名闭包：IIFE模式\n\n- 变量是私有的，除了提供方法外，不能改变\n\n- 其他模块不能是全局的，如果需要依赖其他模块呢？\n\n``` javascript\n// 全局环境\n(function(){\n  let message='Hi';\n  \n  function foo(){\n    console.log(message)\n  }\n  \n  window.foo=foo\n})()\n```\n\n##### IIFE模式plus：引入依赖\n\n- 解决依赖其他模块问题\n\n``` javascript\n// 全局环境\n(function(env,$){\n  let message='Hi';\n  \n  function getEleById(id){\n   \treturn $(id)\n  }\n  \n  env.getEleById=getEleById\n})(window,jQuery)\n```\n\n\n\n## 为什么要模块化\n\n- **解偶，提高可维护性**\n\n  比如：弹窗功能，负责弹窗显示信息，支付模块负责接收订单信息并计算，不需要显示信息。\n\n  如此，弹窗错了，则维护弹窗，不需要修改其他模块信息。支付算法修改，修改支付模块，不需要去改弹窗模块。降低功能间的耦合度，提高代码可维护性\n\n- **减少单个模块的复杂度**\n\n  一个表单具备收集信息、验证信息以及提交信息道服务器功能。\n\n  而这里可以再此拆解出：收集信息模块、验证信息模块、以及提交信息。\n\n  如此，当验证条件有变化的时候，我只需要去修改验证模块。减少整个表单开发的复杂度。\n\n  清晰的归类模块化，减少程序的复杂度。\n\n- **便于部署，减少HTTP请求响应**\n\n  比如纯粹的列表信息显示，完全没必要引入支付模块\n\n\n\n## 模块化的利弊\n\n> **模块化解决了一些代码层面的问题，但也带来了模块管理问题**\n\n#### 利\n\n- 避免命名冲突-（避免命名空间污染）\n- 降低代码耦合度，提高可维护性\n- 复用性强\n- 更好的分类，利于按需加载，减少不必要的HTTP请求响应\n\n#### 弊\n\n``` html\n<script src=\"a.js\"></script>\n<script src=\"b.js\"></script>\n<!-- ... \n\t如果这里有若干个script ，必然会导致HTTP请求响应数过多，从而导致加载渲染时阻塞，影响网页体验\n--> \n<script>\n  // 模块化解决了变量私有，可引入依赖的问题\n  /*\n    这里有两个问题(b依赖a )\n      - 如果a和b调换顺序呢\n      - 在上面的基础上，这里有多大20个模块，并且存在依赖关系的时候呢？\n        这就导致了依赖模糊\n   */\n</script>\n```\n\n\n\n- 请求多\n\n  模块拆解导致原有一个文件，变成了多个文件\n\n- 依赖的模块很多，导致依赖模糊\n\n  依赖顺序模糊，容易出错\n\n- 难以维护\n\n  过多的模块以及模糊的依赖，导致模块化变的难以维护\n\n\n\n> **如何解决模块化带来的弊：<u>规范模块化</u>**\n\n","slug":"JavaScript模块化/模块化进程","published":1,"date":"2020-06-25T03:10:24.411Z","updated":"2020-06-25T03:10:24.411Z","title":"JavaScript模块化/模块化进程","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnp000c3ns6fpdt2peu","content":"<h2 id=\"什么是模块化\"><a href=\"#什么是模块化\" class=\"headerlink\" title=\"什么是模块化\"></a>什么是模块化</h2><h4 id=\"什么是模块\"><a href=\"#什么是模块\" class=\"headerlink\" title=\"什么是模块\"></a>什么是模块</h4><p>将一个复杂的程序，依据一定的规则（规范，业务、功能等等）封装成几个块（文件），并进行组合在一起</p>\n<p>块内部数据/实现是私有的，对外暴露一些方法（API）供其他模块调用（通信）</p>\n<p>PS：设计原则，高内聚低耦合等等，主要目的为了解偶，减少单个程序的复杂性和增加可维护性。</p>\n<h4 id=\"模块化的进程\"><a href=\"#模块化的进程\" class=\"headerlink\" title=\"模块化的进程\"></a>模块化的进程</h4><h5 id=\"global，全局模式\"><a href=\"#global，全局模式\" class=\"headerlink\" title=\"global，全局模式\"></a>global，全局模式</h5><p>方法和变量在全局环境中，当方法越来越多的时候</p>\n<ul>\n<li>容易造成命名冲突</li>\n<li>项目难以维护管理</li>\n<li>引发全局污染</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"简单封装：namespace-命名空间模式\"><a href=\"#简单封装：namespace-命名空间模式\" class=\"headerlink\" title=\"简单封装：namespace 命名空间模式\"></a>简单封装：namespace 命名空间模式</h5><ul>\n<li>减少了global上变量的数量</li>\n<li>本质上是对象，可以直接操作变量的属性，数据是不安全的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> APP=&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">  foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">  bar:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"匿名闭包：IIFE模式\"><a href=\"#匿名闭包：IIFE模式\" class=\"headerlink\" title=\"匿名闭包：IIFE模式\"></a>匿名闭包：IIFE模式</h5><ul>\n<li><p>变量是私有的，除了提供方法外，不能改变</p>\n</li>\n<li><p>其他模块不能是全局的，如果需要依赖其他模块呢？</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> message=<span class=\"string\">'Hi'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">window</span>.foo=foo</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"IIFE模式plus：引入依赖\"><a href=\"#IIFE模式plus：引入依赖\" class=\"headerlink\" title=\"IIFE模式plus：引入依赖\"></a>IIFE模式plus：引入依赖</h5><ul>\n<li>解决依赖其他模块问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env,$</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> message=<span class=\"string\">'Hi'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getEleById</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> $(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  env.getEleById=getEleById</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>,jQuery)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要模块化\"><a href=\"#为什么要模块化\" class=\"headerlink\" title=\"为什么要模块化\"></a>为什么要模块化</h2><ul>\n<li><p><strong>解偶，提高可维护性</strong></p>\n<p>比如：弹窗功能，负责弹窗显示信息，支付模块负责接收订单信息并计算，不需要显示信息。</p>\n<p>如此，弹窗错了，则维护弹窗，不需要修改其他模块信息。支付算法修改，修改支付模块，不需要去改弹窗模块。降低功能间的耦合度，提高代码可维护性</p>\n</li>\n<li><p><strong>减少单个模块的复杂度</strong></p>\n<p>一个表单具备收集信息、验证信息以及提交信息道服务器功能。</p>\n<p>而这里可以再此拆解出：收集信息模块、验证信息模块、以及提交信息。</p>\n<p>如此，当验证条件有变化的时候，我只需要去修改验证模块。减少整个表单开发的复杂度。</p>\n<p>清晰的归类模块化，减少程序的复杂度。</p>\n</li>\n<li><p><strong>便于部署，减少HTTP请求响应</strong></p>\n<p>比如纯粹的列表信息显示，完全没必要引入支付模块</p>\n</li>\n</ul>\n<h2 id=\"模块化的利弊\"><a href=\"#模块化的利弊\" class=\"headerlink\" title=\"模块化的利弊\"></a>模块化的利弊</h2><blockquote>\n<p><strong>模块化解决了一些代码层面的问题，但也带来了模块管理问题</strong></p>\n</blockquote>\n<h4 id=\"利\"><a href=\"#利\" class=\"headerlink\" title=\"利\"></a>利</h4><ul>\n<li>避免命名冲突-（避免命名空间污染）</li>\n<li>降低代码耦合度，提高可维护性</li>\n<li>复用性强</li>\n<li>更好的分类，利于按需加载，减少不必要的HTTP请求响应</li>\n</ul>\n<h4 id=\"弊\"><a href=\"#弊\" class=\"headerlink\" title=\"弊\"></a>弊</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"a.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ... </span></span><br><span class=\"line\"><span class=\"comment\">\t如果这里有若干个script ，必然会导致HTTP请求响应数过多，从而导致加载渲染时阻塞，影响网页体验</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"comment\">// 模块化解决了变量私有，可引入依赖的问题</span></span></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    这里有两个问题(b依赖a )</span><br><span class=\"line\">      - 如果a和b调换顺序呢</span><br><span class=\"line\">      - 在上面的基础上，这里有多大20个模块，并且存在依赖关系的时候呢？</span><br><span class=\"line\">        这就导致了依赖模糊</span><br><span class=\"line\">   */</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>请求多</p>\n<p>模块拆解导致原有一个文件，变成了多个文件</p>\n</li>\n<li><p>依赖的模块很多，导致依赖模糊</p>\n<p>依赖顺序模糊，容易出错</p>\n</li>\n<li><p>难以维护</p>\n<p>过多的模块以及模糊的依赖，导致模块化变的难以维护</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>如何解决模块化带来的弊：<u>规范模块化</u></strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是模块化\"><a href=\"#什么是模块化\" class=\"headerlink\" title=\"什么是模块化\"></a>什么是模块化</h2><h4 id=\"什么是模块\"><a href=\"#什么是模块\" class=\"headerlink\" title=\"什么是模块\"></a>什么是模块</h4><p>将一个复杂的程序，依据一定的规则（规范，业务、功能等等）封装成几个块（文件），并进行组合在一起</p>\n<p>块内部数据/实现是私有的，对外暴露一些方法（API）供其他模块调用（通信）</p>\n<p>PS：设计原则，高内聚低耦合等等，主要目的为了解偶，减少单个程序的复杂性和增加可维护性。</p>\n<h4 id=\"模块化的进程\"><a href=\"#模块化的进程\" class=\"headerlink\" title=\"模块化的进程\"></a>模块化的进程</h4><h5 id=\"global，全局模式\"><a href=\"#global，全局模式\" class=\"headerlink\" title=\"global，全局模式\"></a>global，全局模式</h5><p>方法和变量在全局环境中，当方法越来越多的时候</p>\n<ul>\n<li>容易造成命名冲突</li>\n<li>项目难以维护管理</li>\n<li>引发全局污染</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"简单封装：namespace-命名空间模式\"><a href=\"#简单封装：namespace-命名空间模式\" class=\"headerlink\" title=\"简单封装：namespace 命名空间模式\"></a>简单封装：namespace 命名空间模式</h5><ul>\n<li>减少了global上变量的数量</li>\n<li>本质上是对象，可以直接操作变量的属性，数据是不安全的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> APP=&#123;</span><br><span class=\"line\">  message:<span class=\"string\">'Hi'</span>,</span><br><span class=\"line\">  foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">  bar:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"匿名闭包：IIFE模式\"><a href=\"#匿名闭包：IIFE模式\" class=\"headerlink\" title=\"匿名闭包：IIFE模式\"></a>匿名闭包：IIFE模式</h5><ul>\n<li><p>变量是私有的，除了提供方法外，不能改变</p>\n</li>\n<li><p>其他模块不能是全局的，如果需要依赖其他模块呢？</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> message=<span class=\"string\">'Hi'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(message)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">window</span>.foo=foo</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"IIFE模式plus：引入依赖\"><a href=\"#IIFE模式plus：引入依赖\" class=\"headerlink\" title=\"IIFE模式plus：引入依赖\"></a>IIFE模式plus：引入依赖</h5><ul>\n<li>解决依赖其他模块问题</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局环境</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env,$</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> message=<span class=\"string\">'Hi'</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getEleById</span>(<span class=\"params\">id</span>)</span>&#123;</span><br><span class=\"line\">   \t<span class=\"keyword\">return</span> $(id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  env.getEleById=getEleById</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>,jQuery)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要模块化\"><a href=\"#为什么要模块化\" class=\"headerlink\" title=\"为什么要模块化\"></a>为什么要模块化</h2><ul>\n<li><p><strong>解偶，提高可维护性</strong></p>\n<p>比如：弹窗功能，负责弹窗显示信息，支付模块负责接收订单信息并计算，不需要显示信息。</p>\n<p>如此，弹窗错了，则维护弹窗，不需要修改其他模块信息。支付算法修改，修改支付模块，不需要去改弹窗模块。降低功能间的耦合度，提高代码可维护性</p>\n</li>\n<li><p><strong>减少单个模块的复杂度</strong></p>\n<p>一个表单具备收集信息、验证信息以及提交信息道服务器功能。</p>\n<p>而这里可以再此拆解出：收集信息模块、验证信息模块、以及提交信息。</p>\n<p>如此，当验证条件有变化的时候，我只需要去修改验证模块。减少整个表单开发的复杂度。</p>\n<p>清晰的归类模块化，减少程序的复杂度。</p>\n</li>\n<li><p><strong>便于部署，减少HTTP请求响应</strong></p>\n<p>比如纯粹的列表信息显示，完全没必要引入支付模块</p>\n</li>\n</ul>\n<h2 id=\"模块化的利弊\"><a href=\"#模块化的利弊\" class=\"headerlink\" title=\"模块化的利弊\"></a>模块化的利弊</h2><blockquote>\n<p><strong>模块化解决了一些代码层面的问题，但也带来了模块管理问题</strong></p>\n</blockquote>\n<h4 id=\"利\"><a href=\"#利\" class=\"headerlink\" title=\"利\"></a>利</h4><ul>\n<li>避免命名冲突-（避免命名空间污染）</li>\n<li>降低代码耦合度，提高可维护性</li>\n<li>复用性强</li>\n<li>更好的分类，利于按需加载，减少不必要的HTTP请求响应</li>\n</ul>\n<h4 id=\"弊\"><a href=\"#弊\" class=\"headerlink\" title=\"弊\"></a>弊</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"a.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"b.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- ... </span></span><br><span class=\"line\"><span class=\"comment\">\t如果这里有若干个script ，必然会导致HTTP请求响应数过多，从而导致加载渲染时阻塞，影响网页体验</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"comment\">// 模块化解决了变量私有，可引入依赖的问题</span></span></span><br><span class=\"line\">  /*</span><br><span class=\"line\">    这里有两个问题(b依赖a )</span><br><span class=\"line\">      - 如果a和b调换顺序呢</span><br><span class=\"line\">      - 在上面的基础上，这里有多大20个模块，并且存在依赖关系的时候呢？</span><br><span class=\"line\">        这就导致了依赖模糊</span><br><span class=\"line\">   */</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>请求多</p>\n<p>模块拆解导致原有一个文件，变成了多个文件</p>\n</li>\n<li><p>依赖的模块很多，导致依赖模糊</p>\n<p>依赖顺序模糊，容易出错</p>\n</li>\n<li><p>难以维护</p>\n<p>过多的模块以及模糊的依赖，导致模块化变的难以维护</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>如何解决模块化带来的弊：<u>规范模块化</u></strong></p>\n</blockquote>\n"},{"_content":"## 如何优雅的构建个人知识体系\n\n> **优雅的本质是简洁**\n\n勤奋 VS 数据思维+黑科技\n\n## 为什么要构建个人知识体系\n\n- 个人成长的驱动因素\n- 商业信息不对称，被割韭菜（瑞幸）\n- 职业生涯领域信息不对称，被隔韭菜（职场薪酬，不知道自己值多少钱）\n- 学术领域信息不对称（思维导图笔记，效用不高）\n\n- 普通人的信息源：微信、微博、知乎、喜马拉雅\n\n- 精英人的信息源：图书、论文、调研报告、行业网络、一对一深度沟通\n\n大周期（10年以上）来看，这个距离会越来越大\n\n### 知识是优质的信息\n\n- 智力的差异\n- 信息的差异 \n- 认知的差异 \n\n#### 什么是信息、信息学\n\n有一种情况下能减少不确定的任何事物都叫信息\n\n### 信息分布六大定律\n\n![image-20200527085524129](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085524129.png)\n\n![image-20200527085553584](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085553584.png)\n\nCitespace、Acemap\n\n#### 总结\n\n信息世界浩如烟海，核心信息极其有限，**<u>通过数据分析，掌握核心信息，就掌握了核心优势</u>**\n\n## 信息时代核心思维模型：全局认知\n\n> 全局认知，又称为全局性理解，由帕金斯在《全局学习法》提出。\n>\n> 掌握一个领域100%的信息，是全局性认知，成为专家。掌握任意领域10%的核心信息，就相当于该领域90%价值，这个方法被称为[最小全局认知]，成为业余专家。\n>\n> 获得最小全局认知方法是[对目标数据]检索和抽样。\n\n### 建立最小全局认知三个维度\n\n- 时间维度：最核心的人物（顶级大牛）\n- 空间维度：最核心的图书、论文、出版社、期刊、搜索渠道\n- 变量关系：最核心的概念、原理、模型\n\n### 最小全局认知栗子\n\n- 年月日\n- 化学元素周期表\n- SWOT方法\n\n### 建立全局认知流程\n\n- 信息获取\n- 信息整理\n- 信息加工\n- 信息报告（重点：做输出）\n\n<u>**不要成为学习方法论的爱好者**</u>！\n\n### 全世界最优质的数据源80%以上是开源：\n\n- 英文世界\n  - GitHub-Awesome 清单（Wayback Machine）\n  - Zetero-Translator文件夹\n- 中文世界\n  - 虫部落\n\n### 获取学科最小全局认知\n\n- 时间分布：核心大牛\n- 空间分布：豆瓣、知网（CNKI）\n  - [关键词] site:douban.com/doulist (google或者bing)\n- 自变量与因变量：核心概念、原理、模型\n\nxlore.com 领域关键词\n\n## 使用zotero快速建立知识体系\n\n\n\n## 信息加工——阅读法\n\n![image-20200527115422810](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115422810.png)\n\n![image-20200527115607298](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115607298.png)\n\n>  **教科书是你建立[<u>全局认知</u>]的最强武器**\n\n#### 主题阅读\n\n> 科学的抽样，得到一个近似的集合\n\n- 寻找关键信息：前言，推荐序等\n- 定位核心/优势章节\n- 确定阅读策略\n\n#### 文本细读-小说\n\n## 相关分析——卡片法\n\n> 建立索引，卡片数量大于质量\n>\n> 一卡一事\n>\n> 提取内容形成卡片\n\n### 人名卡\n\n### 术语卡","source":"_posts/LEVEL 1/构建知识体系.md","raw":"## 如何优雅的构建个人知识体系\n\n> **优雅的本质是简洁**\n\n勤奋 VS 数据思维+黑科技\n\n## 为什么要构建个人知识体系\n\n- 个人成长的驱动因素\n- 商业信息不对称，被割韭菜（瑞幸）\n- 职业生涯领域信息不对称，被隔韭菜（职场薪酬，不知道自己值多少钱）\n- 学术领域信息不对称（思维导图笔记，效用不高）\n\n- 普通人的信息源：微信、微博、知乎、喜马拉雅\n\n- 精英人的信息源：图书、论文、调研报告、行业网络、一对一深度沟通\n\n大周期（10年以上）来看，这个距离会越来越大\n\n### 知识是优质的信息\n\n- 智力的差异\n- 信息的差异 \n- 认知的差异 \n\n#### 什么是信息、信息学\n\n有一种情况下能减少不确定的任何事物都叫信息\n\n### 信息分布六大定律\n\n![image-20200527085524129](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085524129.png)\n\n![image-20200527085553584](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085553584.png)\n\nCitespace、Acemap\n\n#### 总结\n\n信息世界浩如烟海，核心信息极其有限，**<u>通过数据分析，掌握核心信息，就掌握了核心优势</u>**\n\n## 信息时代核心思维模型：全局认知\n\n> 全局认知，又称为全局性理解，由帕金斯在《全局学习法》提出。\n>\n> 掌握一个领域100%的信息，是全局性认知，成为专家。掌握任意领域10%的核心信息，就相当于该领域90%价值，这个方法被称为[最小全局认知]，成为业余专家。\n>\n> 获得最小全局认知方法是[对目标数据]检索和抽样。\n\n### 建立最小全局认知三个维度\n\n- 时间维度：最核心的人物（顶级大牛）\n- 空间维度：最核心的图书、论文、出版社、期刊、搜索渠道\n- 变量关系：最核心的概念、原理、模型\n\n### 最小全局认知栗子\n\n- 年月日\n- 化学元素周期表\n- SWOT方法\n\n### 建立全局认知流程\n\n- 信息获取\n- 信息整理\n- 信息加工\n- 信息报告（重点：做输出）\n\n<u>**不要成为学习方法论的爱好者**</u>！\n\n### 全世界最优质的数据源80%以上是开源：\n\n- 英文世界\n  - GitHub-Awesome 清单（Wayback Machine）\n  - Zetero-Translator文件夹\n- 中文世界\n  - 虫部落\n\n### 获取学科最小全局认知\n\n- 时间分布：核心大牛\n- 空间分布：豆瓣、知网（CNKI）\n  - [关键词] site:douban.com/doulist (google或者bing)\n- 自变量与因变量：核心概念、原理、模型\n\nxlore.com 领域关键词\n\n## 使用zotero快速建立知识体系\n\n\n\n## 信息加工——阅读法\n\n![image-20200527115422810](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115422810.png)\n\n![image-20200527115607298](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115607298.png)\n\n>  **教科书是你建立[<u>全局认知</u>]的最强武器**\n\n#### 主题阅读\n\n> 科学的抽样，得到一个近似的集合\n\n- 寻找关键信息：前言，推荐序等\n- 定位核心/优势章节\n- 确定阅读策略\n\n#### 文本细读-小说\n\n## 相关分析——卡片法\n\n> 建立索引，卡片数量大于质量\n>\n> 一卡一事\n>\n> 提取内容形成卡片\n\n### 人名卡\n\n### 术语卡","slug":"LEVEL 1/构建知识体系","published":1,"date":"2020-06-25T03:10:24.440Z","updated":"2020-06-25T03:10:24.440Z","title":"LEVEL 1/构建知识体系","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnr000d3ns64feh59d1","content":"<h2 id=\"如何优雅的构建个人知识体系\"><a href=\"#如何优雅的构建个人知识体系\" class=\"headerlink\" title=\"如何优雅的构建个人知识体系\"></a>如何优雅的构建个人知识体系</h2><blockquote>\n<p><strong>优雅的本质是简洁</strong></p>\n</blockquote>\n<p>勤奋 VS 数据思维+黑科技</p>\n<h2 id=\"为什么要构建个人知识体系\"><a href=\"#为什么要构建个人知识体系\" class=\"headerlink\" title=\"为什么要构建个人知识体系\"></a>为什么要构建个人知识体系</h2><ul>\n<li><p>个人成长的驱动因素</p>\n</li>\n<li><p>商业信息不对称，被割韭菜（瑞幸）</p>\n</li>\n<li><p>职业生涯领域信息不对称，被隔韭菜（职场薪酬，不知道自己值多少钱）</p>\n</li>\n<li><p>学术领域信息不对称（思维导图笔记，效用不高）</p>\n</li>\n<li><p>普通人的信息源：微信、微博、知乎、喜马拉雅</p>\n</li>\n<li><p>精英人的信息源：图书、论文、调研报告、行业网络、一对一深度沟通</p>\n</li>\n</ul>\n<p>大周期（10年以上）来看，这个距离会越来越大</p>\n<h3 id=\"知识是优质的信息\"><a href=\"#知识是优质的信息\" class=\"headerlink\" title=\"知识是优质的信息\"></a>知识是优质的信息</h3><ul>\n<li>智力的差异</li>\n<li>信息的差异 </li>\n<li>认知的差异 </li>\n</ul>\n<h4 id=\"什么是信息、信息学\"><a href=\"#什么是信息、信息学\" class=\"headerlink\" title=\"什么是信息、信息学\"></a>什么是信息、信息学</h4><p>有一种情况下能减少不确定的任何事物都叫信息</p>\n<h3 id=\"信息分布六大定律\"><a href=\"#信息分布六大定律\" class=\"headerlink\" title=\"信息分布六大定律\"></a>信息分布六大定律</h3><p>![image-20200527085524129](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085524129.png)</p>\n<p>![image-20200527085553584](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085553584.png)</p>\n<p>Citespace、Acemap</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>信息世界浩如烟海，核心信息极其有限，<strong><u>通过数据分析，掌握核心信息，就掌握了核心优势</u></strong></p>\n<h2 id=\"信息时代核心思维模型：全局认知\"><a href=\"#信息时代核心思维模型：全局认知\" class=\"headerlink\" title=\"信息时代核心思维模型：全局认知\"></a>信息时代核心思维模型：全局认知</h2><blockquote>\n<p>全局认知，又称为全局性理解，由帕金斯在《全局学习法》提出。</p>\n<p>掌握一个领域100%的信息，是全局性认知，成为专家。掌握任意领域10%的核心信息，就相当于该领域90%价值，这个方法被称为[最小全局认知]，成为业余专家。</p>\n<p>获得最小全局认知方法是[对目标数据]检索和抽样。</p>\n</blockquote>\n<h3 id=\"建立最小全局认知三个维度\"><a href=\"#建立最小全局认知三个维度\" class=\"headerlink\" title=\"建立最小全局认知三个维度\"></a>建立最小全局认知三个维度</h3><ul>\n<li>时间维度：最核心的人物（顶级大牛）</li>\n<li>空间维度：最核心的图书、论文、出版社、期刊、搜索渠道</li>\n<li>变量关系：最核心的概念、原理、模型</li>\n</ul>\n<h3 id=\"最小全局认知栗子\"><a href=\"#最小全局认知栗子\" class=\"headerlink\" title=\"最小全局认知栗子\"></a>最小全局认知栗子</h3><ul>\n<li>年月日</li>\n<li>化学元素周期表</li>\n<li>SWOT方法</li>\n</ul>\n<h3 id=\"建立全局认知流程\"><a href=\"#建立全局认知流程\" class=\"headerlink\" title=\"建立全局认知流程\"></a>建立全局认知流程</h3><ul>\n<li>信息获取</li>\n<li>信息整理</li>\n<li>信息加工</li>\n<li>信息报告（重点：做输出）</li>\n</ul>\n<p><u><strong>不要成为学习方法论的爱好者</strong></u>！</p>\n<h3 id=\"全世界最优质的数据源80-以上是开源：\"><a href=\"#全世界最优质的数据源80-以上是开源：\" class=\"headerlink\" title=\"全世界最优质的数据源80%以上是开源：\"></a>全世界最优质的数据源80%以上是开源：</h3><ul>\n<li>英文世界<ul>\n<li>GitHub-Awesome 清单（Wayback Machine）</li>\n<li>Zetero-Translator文件夹</li>\n</ul>\n</li>\n<li>中文世界<ul>\n<li>虫部落</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"获取学科最小全局认知\"><a href=\"#获取学科最小全局认知\" class=\"headerlink\" title=\"获取学科最小全局认知\"></a>获取学科最小全局认知</h3><ul>\n<li>时间分布：核心大牛</li>\n<li>空间分布：豆瓣、知网（CNKI）<ul>\n<li>[关键词] site:douban.com/doulist (google或者bing)</li>\n</ul>\n</li>\n<li>自变量与因变量：核心概念、原理、模型</li>\n</ul>\n<p>xlore.com 领域关键词</p>\n<h2 id=\"使用zotero快速建立知识体系\"><a href=\"#使用zotero快速建立知识体系\" class=\"headerlink\" title=\"使用zotero快速建立知识体系\"></a>使用zotero快速建立知识体系</h2><h2 id=\"信息加工——阅读法\"><a href=\"#信息加工——阅读法\" class=\"headerlink\" title=\"信息加工——阅读法\"></a>信息加工——阅读法</h2><p>![image-20200527115422810](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115422810.png)</p>\n<p>![image-20200527115607298](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115607298.png)</p>\n<blockquote>\n<p> <strong>教科书是你建立[<u>全局认知</u>]的最强武器</strong></p>\n</blockquote>\n<h4 id=\"主题阅读\"><a href=\"#主题阅读\" class=\"headerlink\" title=\"主题阅读\"></a>主题阅读</h4><blockquote>\n<p>科学的抽样，得到一个近似的集合</p>\n</blockquote>\n<ul>\n<li>寻找关键信息：前言，推荐序等</li>\n<li>定位核心/优势章节</li>\n<li>确定阅读策略</li>\n</ul>\n<h4 id=\"文本细读-小说\"><a href=\"#文本细读-小说\" class=\"headerlink\" title=\"文本细读-小说\"></a>文本细读-小说</h4><h2 id=\"相关分析——卡片法\"><a href=\"#相关分析——卡片法\" class=\"headerlink\" title=\"相关分析——卡片法\"></a>相关分析——卡片法</h2><blockquote>\n<p>建立索引，卡片数量大于质量</p>\n<p>一卡一事</p>\n<p>提取内容形成卡片</p>\n</blockquote>\n<h3 id=\"人名卡\"><a href=\"#人名卡\" class=\"headerlink\" title=\"人名卡\"></a>人名卡</h3><h3 id=\"术语卡\"><a href=\"#术语卡\" class=\"headerlink\" title=\"术语卡\"></a>术语卡</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何优雅的构建个人知识体系\"><a href=\"#如何优雅的构建个人知识体系\" class=\"headerlink\" title=\"如何优雅的构建个人知识体系\"></a>如何优雅的构建个人知识体系</h2><blockquote>\n<p><strong>优雅的本质是简洁</strong></p>\n</blockquote>\n<p>勤奋 VS 数据思维+黑科技</p>\n<h2 id=\"为什么要构建个人知识体系\"><a href=\"#为什么要构建个人知识体系\" class=\"headerlink\" title=\"为什么要构建个人知识体系\"></a>为什么要构建个人知识体系</h2><ul>\n<li><p>个人成长的驱动因素</p>\n</li>\n<li><p>商业信息不对称，被割韭菜（瑞幸）</p>\n</li>\n<li><p>职业生涯领域信息不对称，被隔韭菜（职场薪酬，不知道自己值多少钱）</p>\n</li>\n<li><p>学术领域信息不对称（思维导图笔记，效用不高）</p>\n</li>\n<li><p>普通人的信息源：微信、微博、知乎、喜马拉雅</p>\n</li>\n<li><p>精英人的信息源：图书、论文、调研报告、行业网络、一对一深度沟通</p>\n</li>\n</ul>\n<p>大周期（10年以上）来看，这个距离会越来越大</p>\n<h3 id=\"知识是优质的信息\"><a href=\"#知识是优质的信息\" class=\"headerlink\" title=\"知识是优质的信息\"></a>知识是优质的信息</h3><ul>\n<li>智力的差异</li>\n<li>信息的差异 </li>\n<li>认知的差异 </li>\n</ul>\n<h4 id=\"什么是信息、信息学\"><a href=\"#什么是信息、信息学\" class=\"headerlink\" title=\"什么是信息、信息学\"></a>什么是信息、信息学</h4><p>有一种情况下能减少不确定的任何事物都叫信息</p>\n<h3 id=\"信息分布六大定律\"><a href=\"#信息分布六大定律\" class=\"headerlink\" title=\"信息分布六大定律\"></a>信息分布六大定律</h3><p>![image-20200527085524129](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085524129.png)</p>\n<p>![image-20200527085553584](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527085553584.png)</p>\n<p>Citespace、Acemap</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>信息世界浩如烟海，核心信息极其有限，<strong><u>通过数据分析，掌握核心信息，就掌握了核心优势</u></strong></p>\n<h2 id=\"信息时代核心思维模型：全局认知\"><a href=\"#信息时代核心思维模型：全局认知\" class=\"headerlink\" title=\"信息时代核心思维模型：全局认知\"></a>信息时代核心思维模型：全局认知</h2><blockquote>\n<p>全局认知，又称为全局性理解，由帕金斯在《全局学习法》提出。</p>\n<p>掌握一个领域100%的信息，是全局性认知，成为专家。掌握任意领域10%的核心信息，就相当于该领域90%价值，这个方法被称为[最小全局认知]，成为业余专家。</p>\n<p>获得最小全局认知方法是[对目标数据]检索和抽样。</p>\n</blockquote>\n<h3 id=\"建立最小全局认知三个维度\"><a href=\"#建立最小全局认知三个维度\" class=\"headerlink\" title=\"建立最小全局认知三个维度\"></a>建立最小全局认知三个维度</h3><ul>\n<li>时间维度：最核心的人物（顶级大牛）</li>\n<li>空间维度：最核心的图书、论文、出版社、期刊、搜索渠道</li>\n<li>变量关系：最核心的概念、原理、模型</li>\n</ul>\n<h3 id=\"最小全局认知栗子\"><a href=\"#最小全局认知栗子\" class=\"headerlink\" title=\"最小全局认知栗子\"></a>最小全局认知栗子</h3><ul>\n<li>年月日</li>\n<li>化学元素周期表</li>\n<li>SWOT方法</li>\n</ul>\n<h3 id=\"建立全局认知流程\"><a href=\"#建立全局认知流程\" class=\"headerlink\" title=\"建立全局认知流程\"></a>建立全局认知流程</h3><ul>\n<li>信息获取</li>\n<li>信息整理</li>\n<li>信息加工</li>\n<li>信息报告（重点：做输出）</li>\n</ul>\n<p><u><strong>不要成为学习方法论的爱好者</strong></u>！</p>\n<h3 id=\"全世界最优质的数据源80-以上是开源：\"><a href=\"#全世界最优质的数据源80-以上是开源：\" class=\"headerlink\" title=\"全世界最优质的数据源80%以上是开源：\"></a>全世界最优质的数据源80%以上是开源：</h3><ul>\n<li>英文世界<ul>\n<li>GitHub-Awesome 清单（Wayback Machine）</li>\n<li>Zetero-Translator文件夹</li>\n</ul>\n</li>\n<li>中文世界<ul>\n<li>虫部落</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"获取学科最小全局认知\"><a href=\"#获取学科最小全局认知\" class=\"headerlink\" title=\"获取学科最小全局认知\"></a>获取学科最小全局认知</h3><ul>\n<li>时间分布：核心大牛</li>\n<li>空间分布：豆瓣、知网（CNKI）<ul>\n<li>[关键词] site:douban.com/doulist (google或者bing)</li>\n</ul>\n</li>\n<li>自变量与因变量：核心概念、原理、模型</li>\n</ul>\n<p>xlore.com 领域关键词</p>\n<h2 id=\"使用zotero快速建立知识体系\"><a href=\"#使用zotero快速建立知识体系\" class=\"headerlink\" title=\"使用zotero快速建立知识体系\"></a>使用zotero快速建立知识体系</h2><h2 id=\"信息加工——阅读法\"><a href=\"#信息加工——阅读法\" class=\"headerlink\" title=\"信息加工——阅读法\"></a>信息加工——阅读法</h2><p>![image-20200527115422810](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115422810.png)</p>\n<p>![image-20200527115607298](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200527115607298.png)</p>\n<blockquote>\n<p> <strong>教科书是你建立[<u>全局认知</u>]的最强武器</strong></p>\n</blockquote>\n<h4 id=\"主题阅读\"><a href=\"#主题阅读\" class=\"headerlink\" title=\"主题阅读\"></a>主题阅读</h4><blockquote>\n<p>科学的抽样，得到一个近似的集合</p>\n</blockquote>\n<ul>\n<li>寻找关键信息：前言，推荐序等</li>\n<li>定位核心/优势章节</li>\n<li>确定阅读策略</li>\n</ul>\n<h4 id=\"文本细读-小说\"><a href=\"#文本细读-小说\" class=\"headerlink\" title=\"文本细读-小说\"></a>文本细读-小说</h4><h2 id=\"相关分析——卡片法\"><a href=\"#相关分析——卡片法\" class=\"headerlink\" title=\"相关分析——卡片法\"></a>相关分析——卡片法</h2><blockquote>\n<p>建立索引，卡片数量大于质量</p>\n<p>一卡一事</p>\n<p>提取内容形成卡片</p>\n</blockquote>\n<h3 id=\"人名卡\"><a href=\"#人名卡\" class=\"headerlink\" title=\"人名卡\"></a>人名卡</h3><h3 id=\"术语卡\"><a href=\"#术语卡\" class=\"headerlink\" title=\"术语卡\"></a>术语卡</h3>"},{"_content":"## 隔一秒打印 i 值\n\n### 方式一 - 闭包\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n  ;(function(number) {\n    setTimeout(function() {\n      console.log(number)\n    }, 1000 * number)\n  })(i)\n}\n```\n\n### 方式二 - ES6 箭头函数\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n### 方式三 - Promise\n\n```javascript\nfunction waitTime(i) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(i)\n    }, i * 1000)\n  })\n}\n\nfor (let i = 0; i < 5; i++) {\n  waitTime(i).then(function(res) {\n    console.log(res)\n  })\n}\n```\n\n### 方式四 - 异步方式 async、await & Promise\n\n```javascript\nconst SLEEP_TIME = 1000\n\nfunction sleep(i) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(i)\n    }, SLEEP_TIME)\n  })\n}\n\n;(async function() {\n  for (let i = 0; i < 5; i++) {\n    console.log(await sleep(i))\n  }\n})()\n```\n","source":"_posts/javascript/print-i-one-time.md","raw":"## 隔一秒打印 i 值\n\n### 方式一 - 闭包\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n  ;(function(number) {\n    setTimeout(function() {\n      console.log(number)\n    }, 1000 * number)\n  })(i)\n}\n```\n\n### 方式二 - ES6 箭头函数\n\n```javascript\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n### 方式三 - Promise\n\n```javascript\nfunction waitTime(i) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      resolve(i)\n    }, i * 1000)\n  })\n}\n\nfor (let i = 0; i < 5; i++) {\n  waitTime(i).then(function(res) {\n    console.log(res)\n  })\n}\n```\n\n### 方式四 - 异步方式 async、await & Promise\n\n```javascript\nconst SLEEP_TIME = 1000\n\nfunction sleep(i) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(i)\n    }, SLEEP_TIME)\n  })\n}\n\n;(async function() {\n  for (let i = 0; i < 5; i++) {\n    console.log(await sleep(i))\n  }\n})()\n```\n","slug":"javascript/print-i-one-time","published":1,"date":"2020-06-25T03:10:24.445Z","updated":"2020-06-25T03:10:24.445Z","title":"javascript/print-i-one-time","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wns000e3ns6gbgc7xf5","content":"<h2 id=\"隔一秒打印-i-值\"><a href=\"#隔一秒打印-i-值\" class=\"headerlink\" title=\"隔一秒打印 i 值\"></a>隔一秒打印 i 值</h2><h3 id=\"方式一-闭包\"><a href=\"#方式一-闭包\" class=\"headerlink\" title=\"方式一 - 闭包\"></a>方式一 - 闭包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  ;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(number)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> * number)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-ES6-箭头函数\"><a href=\"#方式二-ES6-箭头函数\" class=\"headerlink\" title=\"方式二 - ES6 箭头函数\"></a>方式二 - ES6 箭头函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, i * <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式三-Promise\"><a href=\"#方式三-Promise\" class=\"headerlink\" title=\"方式三 - Promise\"></a>方式三 - Promise</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitTime</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(i)</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  waitTime(i).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式四-异步方式-async、await-amp-Promise\"><a href=\"#方式四-异步方式-async、await-amp-Promise\" class=\"headerlink\" title=\"方式四 - 异步方式 async、await &amp; Promise\"></a>方式四 - 异步方式 async、await &amp; Promise</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SLEEP_TIME = <span class=\"number\">1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(i)</span><br><span class=\"line\">    &#125;, SLEEP_TIME)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">;(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> sleep(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"隔一秒打印-i-值\"><a href=\"#隔一秒打印-i-值\" class=\"headerlink\" title=\"隔一秒打印 i 值\"></a>隔一秒打印 i 值</h2><h3 id=\"方式一-闭包\"><a href=\"#方式一-闭包\" class=\"headerlink\" title=\"方式一 - 闭包\"></a>方式一 - 闭包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  ;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(number)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> * number)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-ES6-箭头函数\"><a href=\"#方式二-ES6-箭头函数\" class=\"headerlink\" title=\"方式二 - ES6 箭头函数\"></a>方式二 - ES6 箭头函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, i * <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式三-Promise\"><a href=\"#方式三-Promise\" class=\"headerlink\" title=\"方式三 - Promise\"></a>方式三 - Promise</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">waitTime</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(i)</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  waitTime(i).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式四-异步方式-async、await-amp-Promise\"><a href=\"#方式四-异步方式-async、await-amp-Promise\" class=\"headerlink\" title=\"方式四 - 异步方式 async、await &amp; Promise\"></a>方式四 - 异步方式 async、await &amp; Promise</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SLEEP_TIME = <span class=\"number\">1000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(i)</span><br><span class=\"line\">    &#125;, SLEEP_TIME)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">;(<span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> sleep(i))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n"},{"_content":"## this由来\n\n**解析器在调用函数每次都会向函数内部传递一个隐含的参数**\n\n- 这个隐含的参数就是this，this指向一个对象\n\n- 这个对象我们称为函数执行的上下文对象\n\n  \n\n### 根据函数的调用方式的不同，this会指向不同的对象\n\n> this具体指向什么，和函数调用形式有关系，与创建无关\n\n1. 以函数的形式调用，this永远是window\n\n   ``` javascript\n   var name='window'\n   \n   function fun() {\n     console.log(this.name)\n   }\n   \n   var obj = {\n     name:'obj',\n     sayName:fun\n   }\n   \n   fun() // window\n   ```\n\n2. 以方法的形式调用时，this指向调用调用方法的对象\n\n   ``` javascript\n   var name='window'\n   \n   function fun() {\n     console.log(this.name)\n   }\n   \n   var obj = {\n     name:'obj',\n     sayName:fun\n   }\n   \n   obj.sayName() // obj\n   ```\n\n   ","source":"_posts/javascript/this.md","raw":"## this由来\n\n**解析器在调用函数每次都会向函数内部传递一个隐含的参数**\n\n- 这个隐含的参数就是this，this指向一个对象\n\n- 这个对象我们称为函数执行的上下文对象\n\n  \n\n### 根据函数的调用方式的不同，this会指向不同的对象\n\n> this具体指向什么，和函数调用形式有关系，与创建无关\n\n1. 以函数的形式调用，this永远是window\n\n   ``` javascript\n   var name='window'\n   \n   function fun() {\n     console.log(this.name)\n   }\n   \n   var obj = {\n     name:'obj',\n     sayName:fun\n   }\n   \n   fun() // window\n   ```\n\n2. 以方法的形式调用时，this指向调用调用方法的对象\n\n   ``` javascript\n   var name='window'\n   \n   function fun() {\n     console.log(this.name)\n   }\n   \n   var obj = {\n     name:'obj',\n     sayName:fun\n   }\n   \n   obj.sayName() // obj\n   ```\n\n   ","slug":"javascript/this","published":1,"date":"2020-06-25T03:10:24.446Z","updated":"2020-06-25T03:10:24.446Z","title":"javascript/this","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnt000f3ns63i8m3ve3","content":"<h2 id=\"this由来\"><a href=\"#this由来\" class=\"headerlink\" title=\"this由来\"></a>this由来</h2><p><strong>解析器在调用函数每次都会向函数内部传递一个隐含的参数</strong></p>\n<ul>\n<li><p>这个隐含的参数就是this，this指向一个对象</p>\n</li>\n<li><p>这个对象我们称为函数执行的上下文对象</p>\n</li>\n</ul>\n<h3 id=\"根据函数的调用方式的不同，this会指向不同的对象\"><a href=\"#根据函数的调用方式的不同，this会指向不同的对象\" class=\"headerlink\" title=\"根据函数的调用方式的不同，this会指向不同的对象\"></a>根据函数的调用方式的不同，this会指向不同的对象</h3><blockquote>\n<p>this具体指向什么，和函数调用形式有关系，与创建无关</p>\n</blockquote>\n<ol>\n<li><p>以函数的形式调用，this永远是window</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  sayName:fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun() <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以方法的形式调用时，this指向调用调用方法的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  sayName:fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayName() <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"this由来\"><a href=\"#this由来\" class=\"headerlink\" title=\"this由来\"></a>this由来</h2><p><strong>解析器在调用函数每次都会向函数内部传递一个隐含的参数</strong></p>\n<ul>\n<li><p>这个隐含的参数就是this，this指向一个对象</p>\n</li>\n<li><p>这个对象我们称为函数执行的上下文对象</p>\n</li>\n</ul>\n<h3 id=\"根据函数的调用方式的不同，this会指向不同的对象\"><a href=\"#根据函数的调用方式的不同，this会指向不同的对象\" class=\"headerlink\" title=\"根据函数的调用方式的不同，this会指向不同的对象\"></a>根据函数的调用方式的不同，this会指向不同的对象</h3><blockquote>\n<p>this具体指向什么，和函数调用形式有关系，与创建无关</p>\n</blockquote>\n<ol>\n<li><p>以函数的形式调用，this永远是window</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  sayName:fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun() <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以方法的形式调用时，this指向调用调用方法的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  sayName:fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayName() <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n"},{"_content":"## 作用域（scope）\n\n- 指一个变量的作用的范围\n\n- 全局作用域\n\n  - 全局作用域中有一个Window对象或global\n  - 全局中创建的变量/函数都会作为window对象的属性/方法保存\n  - 任意地方都可访问到\n\n- 局部作用域\n\n  - 函数作用域，调用函数时创建，函数调用完毕，函数作用域销毁\n\n  - 每调用一次函数，都会创建一个新的独立的函数作用域\n\n  - 当函数作用域操作一个变量时，会先在自己的作用域中寻找变量，有则直接使用，没有则往上一个作用域找。会一级一级往上找，如果全局作用域也没有，则报错`ReferenceError`\n\n  - 向外找，不会向子作用域找\n\n    \n\n## 变量/函数提前\n\n>  声明和复制是两回事，声明后默认值为undefined\n\n### var-变量\n\n- 使用`var`关键字声明的变量，会在所有的代码执行之前执行\n\n  ``` javascript\n  var a\n  console.log(a) // undefined\n  a = 2\n  ```\n\n- 如果不使用关键字`var`声明变量，则不会提前（严格模式下会报错）\n\n  ``` javascript\n  a \n  console.log(a) // Uncaught ReferenceError: c is not defined (无效的引用)\n  a = 2\n  ```\n\n  \n\n### function-函数\n\n- 使用的函数声明形式创建的函数 `function funcName(){}`，会在所有的代码执行之前就被创建\n\n  ``` javascript\n  fun() // fun\n  \n  function fun(){\n    console.log('fun')\n  }\n  ```\n\n- 在函数作用域中，使用`var`声明的变量也存在变量声明提前\n\n  ``` javascript\n  function func(){\n    cnosole.log(a) // undefined\n    var a = 3\n  }\n  func()\n  ```\n\n- 在函数作用域中，使用函数声明形式创建的函数 `function funcName(){}`，会在所有的代码执行之前就被创建(只在函数作用域中)\n\n  ``` javascript\n  // console.log(func1)  // ReferenceError\n  function func(){\n    func1() // func1\n    function func1(){\n      console.log('func1')\n    }\n  }\n  func()\n  ```\n\n  ","source":"_posts/javascript/作用域.md","raw":"## 作用域（scope）\n\n- 指一个变量的作用的范围\n\n- 全局作用域\n\n  - 全局作用域中有一个Window对象或global\n  - 全局中创建的变量/函数都会作为window对象的属性/方法保存\n  - 任意地方都可访问到\n\n- 局部作用域\n\n  - 函数作用域，调用函数时创建，函数调用完毕，函数作用域销毁\n\n  - 每调用一次函数，都会创建一个新的独立的函数作用域\n\n  - 当函数作用域操作一个变量时，会先在自己的作用域中寻找变量，有则直接使用，没有则往上一个作用域找。会一级一级往上找，如果全局作用域也没有，则报错`ReferenceError`\n\n  - 向外找，不会向子作用域找\n\n    \n\n## 变量/函数提前\n\n>  声明和复制是两回事，声明后默认值为undefined\n\n### var-变量\n\n- 使用`var`关键字声明的变量，会在所有的代码执行之前执行\n\n  ``` javascript\n  var a\n  console.log(a) // undefined\n  a = 2\n  ```\n\n- 如果不使用关键字`var`声明变量，则不会提前（严格模式下会报错）\n\n  ``` javascript\n  a \n  console.log(a) // Uncaught ReferenceError: c is not defined (无效的引用)\n  a = 2\n  ```\n\n  \n\n### function-函数\n\n- 使用的函数声明形式创建的函数 `function funcName(){}`，会在所有的代码执行之前就被创建\n\n  ``` javascript\n  fun() // fun\n  \n  function fun(){\n    console.log('fun')\n  }\n  ```\n\n- 在函数作用域中，使用`var`声明的变量也存在变量声明提前\n\n  ``` javascript\n  function func(){\n    cnosole.log(a) // undefined\n    var a = 3\n  }\n  func()\n  ```\n\n- 在函数作用域中，使用函数声明形式创建的函数 `function funcName(){}`，会在所有的代码执行之前就被创建(只在函数作用域中)\n\n  ``` javascript\n  // console.log(func1)  // ReferenceError\n  function func(){\n    func1() // func1\n    function func1(){\n      console.log('func1')\n    }\n  }\n  func()\n  ```\n\n  ","slug":"javascript/作用域","published":1,"date":"2020-06-25T03:10:24.446Z","updated":"2020-06-25T03:10:24.446Z","title":"javascript/作用域","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnu000g3ns6c4p91e9i","content":"<h2 id=\"作用域（scope）\"><a href=\"#作用域（scope）\" class=\"headerlink\" title=\"作用域（scope）\"></a>作用域（scope）</h2><ul>\n<li><p>指一个变量的作用的范围</p>\n</li>\n<li><p>全局作用域</p>\n<ul>\n<li>全局作用域中有一个Window对象或global</li>\n<li>全局中创建的变量/函数都会作为window对象的属性/方法保存</li>\n<li>任意地方都可访问到</li>\n</ul>\n</li>\n<li><p>局部作用域</p>\n<ul>\n<li><p>函数作用域，调用函数时创建，函数调用完毕，函数作用域销毁</p>\n</li>\n<li><p>每调用一次函数，都会创建一个新的独立的函数作用域</p>\n</li>\n<li><p>当函数作用域操作一个变量时，会先在自己的作用域中寻找变量，有则直接使用，没有则往上一个作用域找。会一级一级往上找，如果全局作用域也没有，则报错<code>ReferenceError</code></p>\n</li>\n<li><p>向外找，不会向子作用域找</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变量-函数提前\"><a href=\"#变量-函数提前\" class=\"headerlink\" title=\"变量/函数提前\"></a>变量/函数提前</h2><blockquote>\n<p> 声明和复制是两回事，声明后默认值为undefined</p>\n</blockquote>\n<h3 id=\"var-变量\"><a href=\"#var-变量\" class=\"headerlink\" title=\"var-变量\"></a>var-变量</h3><ul>\n<li><p>使用<code>var</code>关键字声明的变量，会在所有的代码执行之前执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不使用关键字<code>var</code>声明变量，则不会提前（严格模式下会报错）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: c is not defined (无效的引用)</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h3 id=\"function-函数\"><a href=\"#function-函数\" class=\"headerlink\" title=\"function-函数\"></a>function-函数</h3><ul>\n<li><p>使用的函数声明形式创建的函数 <code>function funcName(){}</code>，会在所有的代码执行之前就被创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun() <span class=\"comment\">// fun</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fun'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在函数作用域中，使用<code>var</code>声明的变量也存在变量声明提前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  cnosole.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在函数作用域中，使用函数声明形式创建的函数 <code>function funcName(){}</code>，会在所有的代码执行之前就被创建(只在函数作用域中)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(func1)  // ReferenceError</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  func1() <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"作用域（scope）\"><a href=\"#作用域（scope）\" class=\"headerlink\" title=\"作用域（scope）\"></a>作用域（scope）</h2><ul>\n<li><p>指一个变量的作用的范围</p>\n</li>\n<li><p>全局作用域</p>\n<ul>\n<li>全局作用域中有一个Window对象或global</li>\n<li>全局中创建的变量/函数都会作为window对象的属性/方法保存</li>\n<li>任意地方都可访问到</li>\n</ul>\n</li>\n<li><p>局部作用域</p>\n<ul>\n<li><p>函数作用域，调用函数时创建，函数调用完毕，函数作用域销毁</p>\n</li>\n<li><p>每调用一次函数，都会创建一个新的独立的函数作用域</p>\n</li>\n<li><p>当函数作用域操作一个变量时，会先在自己的作用域中寻找变量，有则直接使用，没有则往上一个作用域找。会一级一级往上找，如果全局作用域也没有，则报错<code>ReferenceError</code></p>\n</li>\n<li><p>向外找，不会向子作用域找</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"变量-函数提前\"><a href=\"#变量-函数提前\" class=\"headerlink\" title=\"变量/函数提前\"></a>变量/函数提前</h2><blockquote>\n<p> 声明和复制是两回事，声明后默认值为undefined</p>\n</blockquote>\n<h3 id=\"var-变量\"><a href=\"#var-变量\" class=\"headerlink\" title=\"var-变量\"></a>var-变量</h3><ul>\n<li><p>使用<code>var</code>关键字声明的变量，会在所有的代码执行之前执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果不使用关键字<code>var</code>声明变量，则不会提前（严格模式下会报错）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// Uncaught ReferenceError: c is not defined (无效的引用)</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<h3 id=\"function-函数\"><a href=\"#function-函数\" class=\"headerlink\" title=\"function-函数\"></a>function-函数</h3><ul>\n<li><p>使用的函数声明形式创建的函数 <code>function funcName(){}</code>，会在所有的代码执行之前就被创建</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun() <span class=\"comment\">// fun</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fun'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在函数作用域中，使用<code>var</code>声明的变量也存在变量声明提前</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  cnosole.log(a) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在函数作用域中，使用函数声明形式创建的函数 <code>function funcName(){}</code>，会在所有的代码执行之前就被创建(只在函数作用域中)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(func1)  // ReferenceError</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  func1() <span class=\"comment\">// func1</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'func1'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n"},{"_content":"## 函数是什么\n\n- 函数也是一个对象\n- 函数中可以封装一些功能，也可执行一些功能\n- 可以保存一些代码在需要的时候调用\n\n\n\n## 函数的参数\n\n### 形参\n\n- 指定一个或多个形参（形式参数，占个位）\n- 多个形参使用`,`隔开\n- 声明形参相当于在函数内部声明了对应的变量\n- 但是不赋值\n\n### 实参\n\n- 在调用函数的时候，可以指定实参（实际参数）\n- 可以是任意类型\n- 实参将会赋值给函数中对应的形参\n- 调用函数时，解析器不会检查实参类型（但有必要时候需要手动检查）\n- 多余实参不会被赋值给形参，也不会报错\n- 如果实参数量少于形参，则没有对应的实参的形参默认值是undefined\n\n## IIFE（立即调用函数表达式）\n\n函数定义完，立即被调用，往往只执行一次","source":"_posts/javascript/函数.md","raw":"## 函数是什么\n\n- 函数也是一个对象\n- 函数中可以封装一些功能，也可执行一些功能\n- 可以保存一些代码在需要的时候调用\n\n\n\n## 函数的参数\n\n### 形参\n\n- 指定一个或多个形参（形式参数，占个位）\n- 多个形参使用`,`隔开\n- 声明形参相当于在函数内部声明了对应的变量\n- 但是不赋值\n\n### 实参\n\n- 在调用函数的时候，可以指定实参（实际参数）\n- 可以是任意类型\n- 实参将会赋值给函数中对应的形参\n- 调用函数时，解析器不会检查实参类型（但有必要时候需要手动检查）\n- 多余实参不会被赋值给形参，也不会报错\n- 如果实参数量少于形参，则没有对应的实参的形参默认值是undefined\n\n## IIFE（立即调用函数表达式）\n\n函数定义完，立即被调用，往往只执行一次","slug":"javascript/函数","published":1,"date":"2020-06-25T03:10:24.446Z","updated":"2020-06-25T03:10:24.447Z","title":"javascript/函数","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnw000h3ns6f1km6o28","content":"<h2 id=\"函数是什么\"><a href=\"#函数是什么\" class=\"headerlink\" title=\"函数是什么\"></a>函数是什么</h2><ul>\n<li>函数也是一个对象</li>\n<li>函数中可以封装一些功能，也可执行一些功能</li>\n<li>可以保存一些代码在需要的时候调用</li>\n</ul>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li>指定一个或多个形参（形式参数，占个位）</li>\n<li>多个形参使用<code>,</code>隔开</li>\n<li>声明形参相当于在函数内部声明了对应的变量</li>\n<li>但是不赋值</li>\n</ul>\n<h3 id=\"实参\"><a href=\"#实参\" class=\"headerlink\" title=\"实参\"></a>实参</h3><ul>\n<li>在调用函数的时候，可以指定实参（实际参数）</li>\n<li>可以是任意类型</li>\n<li>实参将会赋值给函数中对应的形参</li>\n<li>调用函数时，解析器不会检查实参类型（但有必要时候需要手动检查）</li>\n<li>多余实参不会被赋值给形参，也不会报错</li>\n<li>如果实参数量少于形参，则没有对应的实参的形参默认值是undefined</li>\n</ul>\n<h2 id=\"IIFE（立即调用函数表达式）\"><a href=\"#IIFE（立即调用函数表达式）\" class=\"headerlink\" title=\"IIFE（立即调用函数表达式）\"></a>IIFE（立即调用函数表达式）</h2><p>函数定义完，立即被调用，往往只执行一次</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数是什么\"><a href=\"#函数是什么\" class=\"headerlink\" title=\"函数是什么\"></a>函数是什么</h2><ul>\n<li>函数也是一个对象</li>\n<li>函数中可以封装一些功能，也可执行一些功能</li>\n<li>可以保存一些代码在需要的时候调用</li>\n</ul>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><h3 id=\"形参\"><a href=\"#形参\" class=\"headerlink\" title=\"形参\"></a>形参</h3><ul>\n<li>指定一个或多个形参（形式参数，占个位）</li>\n<li>多个形参使用<code>,</code>隔开</li>\n<li>声明形参相当于在函数内部声明了对应的变量</li>\n<li>但是不赋值</li>\n</ul>\n<h3 id=\"实参\"><a href=\"#实参\" class=\"headerlink\" title=\"实参\"></a>实参</h3><ul>\n<li>在调用函数的时候，可以指定实参（实际参数）</li>\n<li>可以是任意类型</li>\n<li>实参将会赋值给函数中对应的形参</li>\n<li>调用函数时，解析器不会检查实参类型（但有必要时候需要手动检查）</li>\n<li>多余实参不会被赋值给形参，也不会报错</li>\n<li>如果实参数量少于形参，则没有对应的实参的形参默认值是undefined</li>\n</ul>\n<h2 id=\"IIFE（立即调用函数表达式）\"><a href=\"#IIFE（立即调用函数表达式）\" class=\"headerlink\" title=\"IIFE（立即调用函数表达式）\"></a>IIFE（立即调用函数表达式）</h2><p>函数定义完，立即被调用，往往只执行一次</p>\n"},{"_content":"## 原型 Prototype\n\n- **我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`**\n\n  这个属性对应着一个对象，这个对象就是我们所谓的原型\n\n- **如果函数作为一个普通函数调用`prototype`没有任何作用**\n\n- **当函数以构造函数形式调用时，它所创建的对象会有一个隐含的属性`__proto__`** \n\n  指向该构造函数的原型对象，我们可以用过`__proto__`访问\n\n- **原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象**\n\n  可以将对象中共有的内容，统一设置到原型对象中（<u>节省内存</u>）\n\n- **当访问对象的属性方法时，会现在对象自身找，，如果有则直接使用，如果没有则回去原型对象中寻找**\n\n``` javascript\nfunction Person(name){\n  if(name){\n    this.name=name\n  }\n}\n\nPerson.prototype.name = '祖宗'\nPerson.prototype.sayName=function(){\n  console.log(this.name)\n}\n\nvar p1 = new Person('小花')\nvar p2 = new Person('小明')\nvar p3 = new Person()\n\np2.sayName=function(){\n  console.log(this.name,'自己的sayName')\n}\np1.sayName() // 小花\np2.sayName() // 小明 自己的sayName\np3.sayName() // 祖宗\n\n```\n\n```  mermaid\nclassDiagram\nPerson函数对象 --> 原型对象\nPerson函数对象 : name-有条件添加\n通过Person类创建的对象p1 --> 原型对象\n通过Person类创建的对象p2 --> 原型对象\nPerson函数对象 : prototype-->(0x123)\n原型对象 : 内存地址(0x123)\n原型对象 : sayName(){}\n通过Person类创建的对象p1 : __proto__-->(0x123)\n通过Person类创建的对象p1 : name=小花\n通过Person类创建的对象p2 : sayName(){ 自定义}\n通过Person类创建的对象p2 : name=小明\n通过Person类创建的对象p2 : __proto__-->(0x123)\nclass 原型对象{\n \t\tname = 祖宗\n \t\t__proto__\n}\n\n```\n\n","source":"_posts/javascript/原型.md","raw":"## 原型 Prototype\n\n- **我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`**\n\n  这个属性对应着一个对象，这个对象就是我们所谓的原型\n\n- **如果函数作为一个普通函数调用`prototype`没有任何作用**\n\n- **当函数以构造函数形式调用时，它所创建的对象会有一个隐含的属性`__proto__`** \n\n  指向该构造函数的原型对象，我们可以用过`__proto__`访问\n\n- **原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象**\n\n  可以将对象中共有的内容，统一设置到原型对象中（<u>节省内存</u>）\n\n- **当访问对象的属性方法时，会现在对象自身找，，如果有则直接使用，如果没有则回去原型对象中寻找**\n\n``` javascript\nfunction Person(name){\n  if(name){\n    this.name=name\n  }\n}\n\nPerson.prototype.name = '祖宗'\nPerson.prototype.sayName=function(){\n  console.log(this.name)\n}\n\nvar p1 = new Person('小花')\nvar p2 = new Person('小明')\nvar p3 = new Person()\n\np2.sayName=function(){\n  console.log(this.name,'自己的sayName')\n}\np1.sayName() // 小花\np2.sayName() // 小明 自己的sayName\np3.sayName() // 祖宗\n\n```\n\n```  mermaid\nclassDiagram\nPerson函数对象 --> 原型对象\nPerson函数对象 : name-有条件添加\n通过Person类创建的对象p1 --> 原型对象\n通过Person类创建的对象p2 --> 原型对象\nPerson函数对象 : prototype-->(0x123)\n原型对象 : 内存地址(0x123)\n原型对象 : sayName(){}\n通过Person类创建的对象p1 : __proto__-->(0x123)\n通过Person类创建的对象p1 : name=小花\n通过Person类创建的对象p2 : sayName(){ 自定义}\n通过Person类创建的对象p2 : name=小明\n通过Person类创建的对象p2 : __proto__-->(0x123)\nclass 原型对象{\n \t\tname = 祖宗\n \t\t__proto__\n}\n\n```\n\n","slug":"javascript/原型","published":1,"date":"2020-06-25T03:10:24.447Z","updated":"2020-06-25T03:10:24.447Z","title":"javascript/原型","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wnx000i3ns69pxzgwil","content":"<h2 id=\"原型-Prototype\"><a href=\"#原型-Prototype\" class=\"headerlink\" title=\"原型 Prototype\"></a>原型 Prototype</h2><ul>\n<li><p><strong>我们所创建的每一个函数，解析器都会向函数中添加一个属性<code>prototype</code></strong></p>\n<p>这个属性对应着一个对象，这个对象就是我们所谓的原型</p>\n</li>\n<li><p><strong>如果函数作为一个普通函数调用<code>prototype</code>没有任何作用</strong></p>\n</li>\n<li><p><strong>当函数以构造函数形式调用时，它所创建的对象会有一个隐含的属性<code>__proto__</code></strong> </p>\n<p>指向该构造函数的原型对象，我们可以用过<code>__proto__</code>访问</p>\n</li>\n<li><p><strong>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象</strong></p>\n<p>可以将对象中共有的内容，统一设置到原型对象中（<u>节省内存</u>）</p>\n</li>\n<li><p><strong>当访问对象的属性方法时，会现在对象自身找，，如果有则直接使用，如果没有则回去原型对象中寻找</strong></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">'祖宗'</span></span><br><span class=\"line\">Person.prototype.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小花'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小明'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"></span><br><span class=\"line\">p2.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name,<span class=\"string\">'自己的sayName'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p1.sayName() <span class=\"comment\">// 小花</span></span><br><span class=\"line\">p2.sayName() <span class=\"comment\">// 小明 自己的sayName</span></span><br><span class=\"line\">p3.sayName() <span class=\"comment\">// 祖宗</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Person函数对象 --&gt; 原型对象</span><br><span class=\"line\">Person函数对象 : name-有条件添加</span><br><span class=\"line\">通过Person类创建的对象p1 --&gt; 原型对象</span><br><span class=\"line\">通过Person类创建的对象p2 --&gt; 原型对象</span><br><span class=\"line\">Person函数对象 : prototype--&gt;(0x123)</span><br><span class=\"line\">原型对象 : 内存地址(0x123)</span><br><span class=\"line\">原型对象 : sayName()&#123;&#125;</span><br><span class=\"line\">通过Person类创建的对象p1 : __proto__--&gt;(0x123)</span><br><span class=\"line\">通过Person类创建的对象p1 : name&#x3D;小花</span><br><span class=\"line\">通过Person类创建的对象p2 : sayName()&#123; 自定义&#125;</span><br><span class=\"line\">通过Person类创建的对象p2 : name&#x3D;小明</span><br><span class=\"line\">通过Person类创建的对象p2 : __proto__--&gt;(0x123)</span><br><span class=\"line\">class 原型对象&#123;</span><br><span class=\"line\"> \t\tname &#x3D; 祖宗</span><br><span class=\"line\"> \t\t__proto__</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原型-Prototype\"><a href=\"#原型-Prototype\" class=\"headerlink\" title=\"原型 Prototype\"></a>原型 Prototype</h2><ul>\n<li><p><strong>我们所创建的每一个函数，解析器都会向函数中添加一个属性<code>prototype</code></strong></p>\n<p>这个属性对应着一个对象，这个对象就是我们所谓的原型</p>\n</li>\n<li><p><strong>如果函数作为一个普通函数调用<code>prototype</code>没有任何作用</strong></p>\n</li>\n<li><p><strong>当函数以构造函数形式调用时，它所创建的对象会有一个隐含的属性<code>__proto__</code></strong> </p>\n<p>指向该构造函数的原型对象，我们可以用过<code>__proto__</code>访问</p>\n</li>\n<li><p><strong>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象</strong></p>\n<p>可以将对象中共有的内容，统一设置到原型对象中（<u>节省内存</u>）</p>\n</li>\n<li><p><strong>当访问对象的属性方法时，会现在对象自身找，，如果有则直接使用，如果没有则回去原型对象中寻找</strong></p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">'祖宗'</span></span><br><span class=\"line\">Person.prototype.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小花'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'小明'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"></span><br><span class=\"line\">p2.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name,<span class=\"string\">'自己的sayName'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p1.sayName() <span class=\"comment\">// 小花</span></span><br><span class=\"line\">p2.sayName() <span class=\"comment\">// 小明 自己的sayName</span></span><br><span class=\"line\">p3.sayName() <span class=\"comment\">// 祖宗</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classDiagram</span><br><span class=\"line\">Person函数对象 --&gt; 原型对象</span><br><span class=\"line\">Person函数对象 : name-有条件添加</span><br><span class=\"line\">通过Person类创建的对象p1 --&gt; 原型对象</span><br><span class=\"line\">通过Person类创建的对象p2 --&gt; 原型对象</span><br><span class=\"line\">Person函数对象 : prototype--&gt;(0x123)</span><br><span class=\"line\">原型对象 : 内存地址(0x123)</span><br><span class=\"line\">原型对象 : sayName()&#123;&#125;</span><br><span class=\"line\">通过Person类创建的对象p1 : __proto__--&gt;(0x123)</span><br><span class=\"line\">通过Person类创建的对象p1 : name&#x3D;小花</span><br><span class=\"line\">通过Person类创建的对象p2 : sayName()&#123; 自定义&#125;</span><br><span class=\"line\">通过Person类创建的对象p2 : name&#x3D;小明</span><br><span class=\"line\">通过Person类创建的对象p2 : __proto__--&gt;(0x123)</span><br><span class=\"line\">class 原型对象&#123;</span><br><span class=\"line\"> \t\tname &#x3D; 祖宗</span><br><span class=\"line\"> \t\t__proto__</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"## 对象是一种复合的数据类型\n\n在对象中可以保存多个不同数据类型的属性\n\n## 对象分类\n\n1. 内建对象\n\n   由ES标准中定义的对象，在任何的ES中都可以用（Math，Sting等等）\n\n2. 宿主对象\n\n   由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象\n\n   - BOM DOM\n\n3. 自定义对象：自己开发的\n\n## 创建对象\n\n- #### 使用new关键字调用构造函数（constructor）\n\n``` javascript\nvar obj = new Object() \n```\n\n- #### 使用对象字面量 {}\n\n``` javascript\nvar obj = { }\n```\n\n### 向对象添加属性\n\n- 属性名不强制遵守标识规范，但是读取的只能用`[]`形式，否则会报错\n- 属性值可以是任意类型\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\nobj.age='18'\nobj['123']=123  // set\nobj['123']\t\t\t// get\n```\n\n## 查找对象属性\n\n`in`会查找自有属性和自定义属性(包括原型对象的属性)，`hasOwnProperty` 只会查找自定义属性\n\n### in\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\n'name' in a  // true\n'constructor' in a  // true\n```\n\n### hasOwnProperty\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\na.hasOwnProperty('name') // true\na.hasOwnProperty('constructor')  // false\n```\n\n\n\n## 构造函数\n\n创建一个构造函数，专门用来创建对象的。\n\n构造函数和普通函数区别就是调用方式的不同，普通函数直接调用，而构造函数使用new关键字来调用\n\n### 构造函数执行流程\n\n1. 立刻创建一个新的对象\n2. 将新建的对象设置为函数中的this\n3. 逐行执行函数中的代码\n4. 将新建的对象作为返回值返回\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=function(){\n    console.log(this.name)\n  }\n  \n  /** function run(){\n        \tconsole.log(this.name)\n       }\n       console.log(this)\n       run.bind(this)\n       run()\n  */\n}\n\nvar p1=new People('小明',12,'女')\n```\n\n## instanceOf 检查一个对象是否时一个类的实例\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=function(){\n    console.log(this.name)\n  }\n}\n\nvar p1=new People('小明',12,'女')\np1 instanceof People // true\nwindow instanceof People // false\n```\n\n- 所有的对象都是Object的实例（后代）\n\n``` javascript\np1 instanceof Object // true\n```\n\n\n\n## 如何使所有类共享一个方法\n\n> 好处：节省空间\n\n### 方式一\n\n将方法提取出来\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=fun\n}\n\nfunction fun(){\n  console.log(this.name) // 污染了全局作用域，定义在全局作用域很不安全，容易导致被重写\n}\n```\n\n### 方式二  \n\n添加到该类的原型对象中\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=fun\n}\n\nPeople.prototype.fun = function () {\n  console.log(this.name)\n}\n```\n\n","source":"_posts/javascript/对象.md","raw":"## 对象是一种复合的数据类型\n\n在对象中可以保存多个不同数据类型的属性\n\n## 对象分类\n\n1. 内建对象\n\n   由ES标准中定义的对象，在任何的ES中都可以用（Math，Sting等等）\n\n2. 宿主对象\n\n   由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象\n\n   - BOM DOM\n\n3. 自定义对象：自己开发的\n\n## 创建对象\n\n- #### 使用new关键字调用构造函数（constructor）\n\n``` javascript\nvar obj = new Object() \n```\n\n- #### 使用对象字面量 {}\n\n``` javascript\nvar obj = { }\n```\n\n### 向对象添加属性\n\n- 属性名不强制遵守标识规范，但是读取的只能用`[]`形式，否则会报错\n- 属性值可以是任意类型\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\nobj.age='18'\nobj['123']=123  // set\nobj['123']\t\t\t// get\n```\n\n## 查找对象属性\n\n`in`会查找自有属性和自定义属性(包括原型对象的属性)，`hasOwnProperty` 只会查找自定义属性\n\n### in\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\n'name' in a  // true\n'constructor' in a  // true\n```\n\n### hasOwnProperty\n\n``` javascript\nvar obj = new Object() \nobj.name='小明'\na.hasOwnProperty('name') // true\na.hasOwnProperty('constructor')  // false\n```\n\n\n\n## 构造函数\n\n创建一个构造函数，专门用来创建对象的。\n\n构造函数和普通函数区别就是调用方式的不同，普通函数直接调用，而构造函数使用new关键字来调用\n\n### 构造函数执行流程\n\n1. 立刻创建一个新的对象\n2. 将新建的对象设置为函数中的this\n3. 逐行执行函数中的代码\n4. 将新建的对象作为返回值返回\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=function(){\n    console.log(this.name)\n  }\n  \n  /** function run(){\n        \tconsole.log(this.name)\n       }\n       console.log(this)\n       run.bind(this)\n       run()\n  */\n}\n\nvar p1=new People('小明',12,'女')\n```\n\n## instanceOf 检查一个对象是否时一个类的实例\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=function(){\n    console.log(this.name)\n  }\n}\n\nvar p1=new People('小明',12,'女')\np1 instanceof People // true\nwindow instanceof People // false\n```\n\n- 所有的对象都是Object的实例（后代）\n\n``` javascript\np1 instanceof Object // true\n```\n\n\n\n## 如何使所有类共享一个方法\n\n> 好处：节省空间\n\n### 方式一\n\n将方法提取出来\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=fun\n}\n\nfunction fun(){\n  console.log(this.name) // 污染了全局作用域，定义在全局作用域很不安全，容易导致被重写\n}\n```\n\n### 方式二  \n\n添加到该类的原型对象中\n\n``` javascript\nfunction People(name,age,gender){\n  this.name=name\n  this.age=age\n  this.gender=this.gender\n\n  this.sayName=fun\n}\n\nPeople.prototype.fun = function () {\n  console.log(this.name)\n}\n```\n\n","slug":"javascript/对象","published":1,"date":"2020-06-25T03:10:24.447Z","updated":"2020-06-25T03:10:24.447Z","title":"javascript/对象","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wny000j3ns600m1hw6l","content":"<h2 id=\"对象是一种复合的数据类型\"><a href=\"#对象是一种复合的数据类型\" class=\"headerlink\" title=\"对象是一种复合的数据类型\"></a>对象是一种复合的数据类型</h2><p>在对象中可以保存多个不同数据类型的属性</p>\n<h2 id=\"对象分类\"><a href=\"#对象分类\" class=\"headerlink\" title=\"对象分类\"></a>对象分类</h2><ol>\n<li><p>内建对象</p>\n<p>由ES标准中定义的对象，在任何的ES中都可以用（Math，Sting等等）</p>\n</li>\n<li><p>宿主对象</p>\n<p>由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象</p>\n<ul>\n<li>BOM DOM</li>\n</ul>\n</li>\n<li><p>自定义对象：自己开发的</p>\n</li>\n</ol>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li><h4 id=\"使用new关键字调用构造函数（constructor）\"><a href=\"#使用new关键字调用构造函数（constructor）\" class=\"headerlink\" title=\"使用new关键字调用构造函数（constructor）\"></a>使用new关键字调用构造函数（constructor）</h4></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h4 id=\"使用对象字面量\"><a href=\"#使用对象字面量\" class=\"headerlink\" title=\"使用对象字面量 {}\"></a>使用对象字面量 {}</h4></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向对象添加属性\"><a href=\"#向对象添加属性\" class=\"headerlink\" title=\"向对象添加属性\"></a>向对象添加属性</h3><ul>\n<li>属性名不强制遵守标识规范，但是读取的只能用<code>[]</code>形式，否则会报错</li>\n<li>属性值可以是任意类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\">obj.age=<span class=\"string\">'18'</span></span><br><span class=\"line\">obj[<span class=\"string\">'123'</span>]=<span class=\"number\">123</span>  <span class=\"comment\">// set</span></span><br><span class=\"line\">obj[<span class=\"string\">'123'</span>]\t\t\t<span class=\"comment\">// get</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查找对象属性\"><a href=\"#查找对象属性\" class=\"headerlink\" title=\"查找对象属性\"></a>查找对象属性</h2><p><code>in</code>会查找自有属性和自定义属性(包括原型对象的属性)，<code>hasOwnProperty</code> 只会查找自定义属性</p>\n<h3 id=\"in\"><a href=\"#in\" class=\"headerlink\" title=\"in\"></a>in</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> a  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">'constructor'</span> <span class=\"keyword\">in</span> a  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty\"></a>hasOwnProperty</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'constructor'</span>)  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>创建一个构造函数，专门用来创建对象的。</p>\n<p>构造函数和普通函数区别就是调用方式的不同，普通函数直接调用，而构造函数使用new关键字来调用</p>\n<h3 id=\"构造函数执行流程\"><a href=\"#构造函数执行流程\" class=\"headerlink\" title=\"构造函数执行流程\"></a>构造函数执行流程</h3><ol>\n<li>立刻创建一个新的对象</li>\n<li>将新建的对象设置为函数中的this</li>\n<li>逐行执行函数中的代码</li>\n<li>将新建的对象作为返回值返回</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/** function run()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        \tconsole.log(this.name)</span></span><br><span class=\"line\"><span class=\"comment\">       &#125;</span></span><br><span class=\"line\"><span class=\"comment\">       console.log(this)</span></span><br><span class=\"line\"><span class=\"comment\">       run.bind(this)</span></span><br><span class=\"line\"><span class=\"comment\">       run()</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> People(<span class=\"string\">'小明'</span>,<span class=\"number\">12</span>,<span class=\"string\">'女'</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"instanceOf-检查一个对象是否时一个类的实例\"><a href=\"#instanceOf-检查一个对象是否时一个类的实例\" class=\"headerlink\" title=\"instanceOf 检查一个对象是否时一个类的实例\"></a>instanceOf 检查一个对象是否时一个类的实例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> People(<span class=\"string\">'小明'</span>,<span class=\"number\">12</span>,<span class=\"string\">'女'</span>)</span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> People <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">window</span> <span class=\"keyword\">instanceof</span> People <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有的对象都是Object的实例（后代）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何使所有类共享一个方法\"><a href=\"#如何使所有类共享一个方法\" class=\"headerlink\" title=\"如何使所有类共享一个方法\"></a>如何使所有类共享一个方法</h2><blockquote>\n<p>好处：节省空间</p>\n</blockquote>\n<h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>将方法提取出来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// 污染了全局作用域，定义在全局作用域很不安全，容易导致被重写</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>添加到该类的原型对象中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">People.prototype.fun = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对象是一种复合的数据类型\"><a href=\"#对象是一种复合的数据类型\" class=\"headerlink\" title=\"对象是一种复合的数据类型\"></a>对象是一种复合的数据类型</h2><p>在对象中可以保存多个不同数据类型的属性</p>\n<h2 id=\"对象分类\"><a href=\"#对象分类\" class=\"headerlink\" title=\"对象分类\"></a>对象分类</h2><ol>\n<li><p>内建对象</p>\n<p>由ES标准中定义的对象，在任何的ES中都可以用（Math，Sting等等）</p>\n</li>\n<li><p>宿主对象</p>\n<p>由JS的运行环境提供的对象，目前来讲主要由浏览器提供的对象</p>\n<ul>\n<li>BOM DOM</li>\n</ul>\n</li>\n<li><p>自定义对象：自己开发的</p>\n</li>\n</ol>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><ul>\n<li><h4 id=\"使用new关键字调用构造函数（constructor）\"><a href=\"#使用new关键字调用构造函数（constructor）\" class=\"headerlink\" title=\"使用new关键字调用构造函数（constructor）\"></a>使用new关键字调用构造函数（constructor）</h4></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h4 id=\"使用对象字面量\"><a href=\"#使用对象字面量\" class=\"headerlink\" title=\"使用对象字面量 {}\"></a>使用对象字面量 {}</h4></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向对象添加属性\"><a href=\"#向对象添加属性\" class=\"headerlink\" title=\"向对象添加属性\"></a>向对象添加属性</h3><ul>\n<li>属性名不强制遵守标识规范，但是读取的只能用<code>[]</code>形式，否则会报错</li>\n<li>属性值可以是任意类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\">obj.age=<span class=\"string\">'18'</span></span><br><span class=\"line\">obj[<span class=\"string\">'123'</span>]=<span class=\"number\">123</span>  <span class=\"comment\">// set</span></span><br><span class=\"line\">obj[<span class=\"string\">'123'</span>]\t\t\t<span class=\"comment\">// get</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查找对象属性\"><a href=\"#查找对象属性\" class=\"headerlink\" title=\"查找对象属性\"></a>查找对象属性</h2><p><code>in</code>会查找自有属性和自定义属性(包括原型对象的属性)，<code>hasOwnProperty</code> 只会查找自定义属性</p>\n<h3 id=\"in\"><a href=\"#in\" class=\"headerlink\" title=\"in\"></a>in</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> a  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">'constructor'</span> <span class=\"keyword\">in</span> a  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty\"></a>hasOwnProperty</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>() </span><br><span class=\"line\">obj.name=<span class=\"string\">'小明'</span></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'constructor'</span>)  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>创建一个构造函数，专门用来创建对象的。</p>\n<p>构造函数和普通函数区别就是调用方式的不同，普通函数直接调用，而构造函数使用new关键字来调用</p>\n<h3 id=\"构造函数执行流程\"><a href=\"#构造函数执行流程\" class=\"headerlink\" title=\"构造函数执行流程\"></a>构造函数执行流程</h3><ol>\n<li>立刻创建一个新的对象</li>\n<li>将新建的对象设置为函数中的this</li>\n<li>逐行执行函数中的代码</li>\n<li>将新建的对象作为返回值返回</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/** function run()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        \tconsole.log(this.name)</span></span><br><span class=\"line\"><span class=\"comment\">       &#125;</span></span><br><span class=\"line\"><span class=\"comment\">       console.log(this)</span></span><br><span class=\"line\"><span class=\"comment\">       run.bind(this)</span></span><br><span class=\"line\"><span class=\"comment\">       run()</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> People(<span class=\"string\">'小明'</span>,<span class=\"number\">12</span>,<span class=\"string\">'女'</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"instanceOf-检查一个对象是否时一个类的实例\"><a href=\"#instanceOf-检查一个对象是否时一个类的实例\" class=\"headerlink\" title=\"instanceOf 检查一个对象是否时一个类的实例\"></a>instanceOf 检查一个对象是否时一个类的实例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> People(<span class=\"string\">'小明'</span>,<span class=\"number\">12</span>,<span class=\"string\">'女'</span>)</span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> People <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">window</span> <span class=\"keyword\">instanceof</span> People <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有的对象都是Object的实例（后代）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如何使所有类共享一个方法\"><a href=\"#如何使所有类共享一个方法\" class=\"headerlink\" title=\"如何使所有类共享一个方法\"></a>如何使所有类共享一个方法</h2><blockquote>\n<p>好处：节省空间</p>\n</blockquote>\n<h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>将方法提取出来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// 污染了全局作用域，定义在全局作用域很不安全，容易导致被重写</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>添加到该类的原型对象中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name,age,gender</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.gender=<span class=\"keyword\">this</span>.gender</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName=fun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">People.prototype.fun = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":" ## 区别实例对象与函数对象\n\n* new 产生的是实例对象\n\n* 将函数作为对象使用，称为函数对象\n\n```javascript\nfunction Fn() {} // 函数\nconst fn = new Fn()  // Fn 是构造函数 （是不是构造函数看怎么用），fn是实例对象\nFn.bind() // 函数对象 Fn.bind\n// fn.get() // 实例对象的使用 Fn.prototype.get 原型对象\n// $('#id') // 函数\n// $.get('#id') // 函数对象 $.prototype.get\n```\n\n\n\n## 两种类型的回调函数\n\n### 同步回调\n\n立即执行，完全执行完了才结束，不回放入回调队列中\n\n比如：数组遍历相关的回调函数 / Promise的excutor函数\n\n```\tjavascript\nconst arr = [1, 2, 3]\n\narr.forEach((item) => {\n  console.log(item)\n})\nconsole.log('forEach end')\n```\n\n### 异步回调\n\n不会立即执行，会放入回调队列中将来执行\n\n比如：定时器回调 / ajax回调 / Promise的成功｜失败回调\n\n``` javascript\nsetTimeout(() => {\n  console.log('timeout')\n}, 0)\nconsole.log('timeout end')\n```\n\n\n\n### JS中的error 处理\n\n> 没有捕获error ,后面的代码不会执行; throw 会让后面的代码不能执行,但finally会执行\n\n### 常见的错误类型\n\n##### RangeError\n\n   创建一个error实例，表示错误的原因：数值变量或参数超出其有效范围。\n\n##### ReferenceError\n\n   创建一个error实例，表示错误的原因：无效引用。\n\n##### SyntaxError\n\n   创建一个error实例，表示错误的原因：eval()在解析代码的过程中发生的语法错误。\n\n##### TypeError\n\n   创建一个error实例，表示错误的原因：变量或参数不属于有效类型。\n\n``` javascript\ntry {\n  console.log(a)\n} catch (error) {\n  // console.error(error.message)\n  // throw new Error('error 111')\n} finally {\n  console.log('error finally')\n}\n\nconsole.log('----')\n```\n\n","source":"_posts/自定义Promise/01-准备.md","raw":" ## 区别实例对象与函数对象\n\n* new 产生的是实例对象\n\n* 将函数作为对象使用，称为函数对象\n\n```javascript\nfunction Fn() {} // 函数\nconst fn = new Fn()  // Fn 是构造函数 （是不是构造函数看怎么用），fn是实例对象\nFn.bind() // 函数对象 Fn.bind\n// fn.get() // 实例对象的使用 Fn.prototype.get 原型对象\n// $('#id') // 函数\n// $.get('#id') // 函数对象 $.prototype.get\n```\n\n\n\n## 两种类型的回调函数\n\n### 同步回调\n\n立即执行，完全执行完了才结束，不回放入回调队列中\n\n比如：数组遍历相关的回调函数 / Promise的excutor函数\n\n```\tjavascript\nconst arr = [1, 2, 3]\n\narr.forEach((item) => {\n  console.log(item)\n})\nconsole.log('forEach end')\n```\n\n### 异步回调\n\n不会立即执行，会放入回调队列中将来执行\n\n比如：定时器回调 / ajax回调 / Promise的成功｜失败回调\n\n``` javascript\nsetTimeout(() => {\n  console.log('timeout')\n}, 0)\nconsole.log('timeout end')\n```\n\n\n\n### JS中的error 处理\n\n> 没有捕获error ,后面的代码不会执行; throw 会让后面的代码不能执行,但finally会执行\n\n### 常见的错误类型\n\n##### RangeError\n\n   创建一个error实例，表示错误的原因：数值变量或参数超出其有效范围。\n\n##### ReferenceError\n\n   创建一个error实例，表示错误的原因：无效引用。\n\n##### SyntaxError\n\n   创建一个error实例，表示错误的原因：eval()在解析代码的过程中发生的语法错误。\n\n##### TypeError\n\n   创建一个error实例，表示错误的原因：变量或参数不属于有效类型。\n\n``` javascript\ntry {\n  console.log(a)\n} catch (error) {\n  // console.error(error.message)\n  // throw new Error('error 111')\n} finally {\n  console.log('error finally')\n}\n\nconsole.log('----')\n```\n\n","slug":"自定义Promise/01-准备","published":1,"date":"2020-06-25T03:10:24.448Z","updated":"2020-06-25T03:10:24.448Z","title":"自定义Promise/01-准备","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo1000k3ns6cftramaa","content":"<h2 id=\"区别实例对象与函数对象\"><a href=\"#区别实例对象与函数对象\" class=\"headerlink\" title=\"区别实例对象与函数对象\"></a>区别实例对象与函数对象</h2><ul>\n<li><p>new 产生的是实例对象</p>\n</li>\n<li><p>将函数作为对象使用，称为函数对象</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn = <span class=\"keyword\">new</span> Fn()  <span class=\"comment\">// Fn 是构造函数 （是不是构造函数看怎么用），fn是实例对象</span></span><br><span class=\"line\">Fn.bind() <span class=\"comment\">// 函数对象 Fn.bind</span></span><br><span class=\"line\"><span class=\"comment\">// fn.get() // 实例对象的使用 Fn.prototype.get 原型对象</span></span><br><span class=\"line\"><span class=\"comment\">// $('#id') // 函数</span></span><br><span class=\"line\"><span class=\"comment\">// $.get('#id') // 函数对象 $.prototype.get</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"两种类型的回调函数\"><a href=\"#两种类型的回调函数\" class=\"headerlink\" title=\"两种类型的回调函数\"></a>两种类型的回调函数</h2><h3 id=\"同步回调\"><a href=\"#同步回调\" class=\"headerlink\" title=\"同步回调\"></a>同步回调</h3><p>立即执行，完全执行完了才结束，不回放入回调队列中</p>\n<p>比如：数组遍历相关的回调函数 / Promise的excutor函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'forEach end'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异步回调\"><a href=\"#异步回调\" class=\"headerlink\" title=\"异步回调\"></a>异步回调</h3><p>不会立即执行，会放入回调队列中将来执行</p>\n<p>比如：定时器回调 / ajax回调 / Promise的成功｜失败回调</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout end'</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"JS中的error-处理\"><a href=\"#JS中的error-处理\" class=\"headerlink\" title=\"JS中的error 处理\"></a>JS中的error 处理</h3><blockquote>\n<p>没有捕获error ,后面的代码不会执行; throw 会让后面的代码不能执行,但finally会执行</p>\n</blockquote>\n<h3 id=\"常见的错误类型\"><a href=\"#常见的错误类型\" class=\"headerlink\" title=\"常见的错误类型\"></a>常见的错误类型</h3><h5 id=\"RangeError\"><a href=\"#RangeError\" class=\"headerlink\" title=\"RangeError\"></a>RangeError</h5><p>   创建一个error实例，表示错误的原因：数值变量或参数超出其有效范围。</p>\n<h5 id=\"ReferenceError\"><a href=\"#ReferenceError\" class=\"headerlink\" title=\"ReferenceError\"></a>ReferenceError</h5><p>   创建一个error实例，表示错误的原因：无效引用。</p>\n<h5 id=\"SyntaxError\"><a href=\"#SyntaxError\" class=\"headerlink\" title=\"SyntaxError\"></a>SyntaxError</h5><p>   创建一个error实例，表示错误的原因：eval()在解析代码的过程中发生的语法错误。</p>\n<h5 id=\"TypeError\"><a href=\"#TypeError\" class=\"headerlink\" title=\"TypeError\"></a>TypeError</h5><p>   创建一个error实例，表示错误的原因：变量或参数不属于有效类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.error(error.message)</span></span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('error 111')</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'error finally'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'----'</span>)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"区别实例对象与函数对象\"><a href=\"#区别实例对象与函数对象\" class=\"headerlink\" title=\"区别实例对象与函数对象\"></a>区别实例对象与函数对象</h2><ul>\n<li><p>new 产生的是实例对象</p>\n</li>\n<li><p>将函数作为对象使用，称为函数对象</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123;&#125; <span class=\"comment\">// 函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fn = <span class=\"keyword\">new</span> Fn()  <span class=\"comment\">// Fn 是构造函数 （是不是构造函数看怎么用），fn是实例对象</span></span><br><span class=\"line\">Fn.bind() <span class=\"comment\">// 函数对象 Fn.bind</span></span><br><span class=\"line\"><span class=\"comment\">// fn.get() // 实例对象的使用 Fn.prototype.get 原型对象</span></span><br><span class=\"line\"><span class=\"comment\">// $('#id') // 函数</span></span><br><span class=\"line\"><span class=\"comment\">// $.get('#id') // 函数对象 $.prototype.get</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"两种类型的回调函数\"><a href=\"#两种类型的回调函数\" class=\"headerlink\" title=\"两种类型的回调函数\"></a>两种类型的回调函数</h2><h3 id=\"同步回调\"><a href=\"#同步回调\" class=\"headerlink\" title=\"同步回调\"></a>同步回调</h3><p>立即执行，完全执行完了才结束，不回放入回调队列中</p>\n<p>比如：数组遍历相关的回调函数 / Promise的excutor函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'forEach end'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异步回调\"><a href=\"#异步回调\" class=\"headerlink\" title=\"异步回调\"></a>异步回调</h3><p>不会立即执行，会放入回调队列中将来执行</p>\n<p>比如：定时器回调 / ajax回调 / Promise的成功｜失败回调</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout end'</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"JS中的error-处理\"><a href=\"#JS中的error-处理\" class=\"headerlink\" title=\"JS中的error 处理\"></a>JS中的error 处理</h3><blockquote>\n<p>没有捕获error ,后面的代码不会执行; throw 会让后面的代码不能执行,但finally会执行</p>\n</blockquote>\n<h3 id=\"常见的错误类型\"><a href=\"#常见的错误类型\" class=\"headerlink\" title=\"常见的错误类型\"></a>常见的错误类型</h3><h5 id=\"RangeError\"><a href=\"#RangeError\" class=\"headerlink\" title=\"RangeError\"></a>RangeError</h5><p>   创建一个error实例，表示错误的原因：数值变量或参数超出其有效范围。</p>\n<h5 id=\"ReferenceError\"><a href=\"#ReferenceError\" class=\"headerlink\" title=\"ReferenceError\"></a>ReferenceError</h5><p>   创建一个error实例，表示错误的原因：无效引用。</p>\n<h5 id=\"SyntaxError\"><a href=\"#SyntaxError\" class=\"headerlink\" title=\"SyntaxError\"></a>SyntaxError</h5><p>   创建一个error实例，表示错误的原因：eval()在解析代码的过程中发生的语法错误。</p>\n<h5 id=\"TypeError\"><a href=\"#TypeError\" class=\"headerlink\" title=\"TypeError\"></a>TypeError</h5><p>   创建一个error实例，表示错误的原因：变量或参数不属于有效类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.error(error.message)</span></span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('error 111')</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'error finally'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'----'</span>)</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"##   Promise是什么 （what）\n\n### 理解\n\n##### 抽象表达\n\n​     Promise是JS中进行异步编程的新的解决方案（旧的是什么？）\n\n##### 具体表达\n\n     1. 从语法上来说：Promise是一个构造函数\n        2. 从功能上来说：promise对象用来封装一个异步操作并可以获取其结果\n\n##### 旧的JS异步编程方案\n\n​\t纯回调机制-callback\n\n### promise的状态改变\n\n> 初始值是pending；只有两种改变；且一个Promise对象只能改变一次；\n>\n> 无论变为成功还是失败，都会有一个结果数据；\n>\n> 成功的结果数据一般称为value ，失败的结果数据一般称为reason\n\n- pending （初始化）未确定的\n- pending 变为 resolved 成功\n- pending 变为 rejected 失败\n\n### promise的基本流程\n\n``` mermaid\ngraph TD\nA[new Promise] --> |pendding| B{执行异步操作}\nB --> |成功了,执行resolve| C[promise对象: resolved状态]\nB --> |失败了,执行reject| D[promise对象: rejected状态]\nC --> E[then 回调onResolved]\nD --> F[then/catch 回调onRejected]\nE --> G[新的promise对象]\nF --> G[新的promise对象]\n```\n\n\n\n### promise的基本使用\n\n``` javascript\nconst p = new Promise((resolve, reject) => {\n  // 执行器函数  同步回调\n  const time = Date.now()\n  // 执行异步任务\n  if (time % 2 === 0) {\n    // 成功\n    resolve(`偶数: ${time}`)\n  } else {\n    // 失败\n    reject(`奇数: ${time}`)\n    // throw new Error(`奇数: ${time}`)\n  }\n})\n\np.then(\n  (value) => {\n    // 接收成功的value数据\n    console.log(value)\n  },\n  (reason) => {\n    // 接收失败的reason数据\n    console.warn(reason)\n  }\n)\n// .catch((error) => {\n// 会优先then 中的reason\n// console.error('catch', error)\n// })\n// .finally(() => {\n//   console.log('33333')\n// })\n\n```\n\n\n\n ## 为什么要使用Promise (why)\n\n1. 指定回调函数的方式更加灵活\n\n   - 旧的回调机制\n\n     必须在异步任务启动前指定回调函数\n\n   - promise\n\n     启动异步任务 => 返回promise对象 => 给promise对象绑定回调函数（甚至可以在异步任务执行完有了结果后绑定回调函数）\n\n     \n\n   例：发送请求用户想等5秒执行回调函数\n\n   ​\t\t旧的回调怎么实现？只能在回调函数套一个seTimeout,这破坏了回调函数的业务代码。\n\n   ​\t\tpromise则是启动异步任务后，拿到promise对象，你想什么时候执行都行，不需要改回调函数。\n\n   更利于代码可读性和维护性\n\n2. 支持链式调用，可以解决回调地狱问题\n\n   - 什么是回调地狱？\n\n     回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件\n\n   - 回调地狱的缺点？\n\n     不便于阅读/不便于异常处理\n\n   - 终极解决方案？async/await\n\n   - 异常穿透\n\n  ## 如何使用 (how)\n\n","source":"_posts/自定义Promise/02-Promise的理解和使用.md","raw":"##   Promise是什么 （what）\n\n### 理解\n\n##### 抽象表达\n\n​     Promise是JS中进行异步编程的新的解决方案（旧的是什么？）\n\n##### 具体表达\n\n     1. 从语法上来说：Promise是一个构造函数\n        2. 从功能上来说：promise对象用来封装一个异步操作并可以获取其结果\n\n##### 旧的JS异步编程方案\n\n​\t纯回调机制-callback\n\n### promise的状态改变\n\n> 初始值是pending；只有两种改变；且一个Promise对象只能改变一次；\n>\n> 无论变为成功还是失败，都会有一个结果数据；\n>\n> 成功的结果数据一般称为value ，失败的结果数据一般称为reason\n\n- pending （初始化）未确定的\n- pending 变为 resolved 成功\n- pending 变为 rejected 失败\n\n### promise的基本流程\n\n``` mermaid\ngraph TD\nA[new Promise] --> |pendding| B{执行异步操作}\nB --> |成功了,执行resolve| C[promise对象: resolved状态]\nB --> |失败了,执行reject| D[promise对象: rejected状态]\nC --> E[then 回调onResolved]\nD --> F[then/catch 回调onRejected]\nE --> G[新的promise对象]\nF --> G[新的promise对象]\n```\n\n\n\n### promise的基本使用\n\n``` javascript\nconst p = new Promise((resolve, reject) => {\n  // 执行器函数  同步回调\n  const time = Date.now()\n  // 执行异步任务\n  if (time % 2 === 0) {\n    // 成功\n    resolve(`偶数: ${time}`)\n  } else {\n    // 失败\n    reject(`奇数: ${time}`)\n    // throw new Error(`奇数: ${time}`)\n  }\n})\n\np.then(\n  (value) => {\n    // 接收成功的value数据\n    console.log(value)\n  },\n  (reason) => {\n    // 接收失败的reason数据\n    console.warn(reason)\n  }\n)\n// .catch((error) => {\n// 会优先then 中的reason\n// console.error('catch', error)\n// })\n// .finally(() => {\n//   console.log('33333')\n// })\n\n```\n\n\n\n ## 为什么要使用Promise (why)\n\n1. 指定回调函数的方式更加灵活\n\n   - 旧的回调机制\n\n     必须在异步任务启动前指定回调函数\n\n   - promise\n\n     启动异步任务 => 返回promise对象 => 给promise对象绑定回调函数（甚至可以在异步任务执行完有了结果后绑定回调函数）\n\n     \n\n   例：发送请求用户想等5秒执行回调函数\n\n   ​\t\t旧的回调怎么实现？只能在回调函数套一个seTimeout,这破坏了回调函数的业务代码。\n\n   ​\t\tpromise则是启动异步任务后，拿到promise对象，你想什么时候执行都行，不需要改回调函数。\n\n   更利于代码可读性和维护性\n\n2. 支持链式调用，可以解决回调地狱问题\n\n   - 什么是回调地狱？\n\n     回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件\n\n   - 回调地狱的缺点？\n\n     不便于阅读/不便于异常处理\n\n   - 终极解决方案？async/await\n\n   - 异常穿透\n\n  ## 如何使用 (how)\n\n","slug":"自定义Promise/02-Promise的理解和使用","published":1,"date":"2020-06-25T03:10:24.449Z","updated":"2020-06-25T03:10:24.449Z","title":"自定义Promise/02-Promise的理解和使用","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo2000l3ns67dk162kv","content":"<h2 id=\"Promise是什么-（what）\"><a href=\"#Promise是什么-（what）\" class=\"headerlink\" title=\"Promise是什么 （what）\"></a>Promise是什么 （what）</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><h5 id=\"抽象表达\"><a href=\"#抽象表达\" class=\"headerlink\" title=\"抽象表达\"></a>抽象表达</h5><p>​     Promise是JS中进行异步编程的新的解决方案（旧的是什么？）</p>\n<h5 id=\"具体表达\"><a href=\"#具体表达\" class=\"headerlink\" title=\"具体表达\"></a>具体表达</h5><pre><code>1. 从语法上来说：Promise是一个构造函数\n   2. 从功能上来说：promise对象用来封装一个异步操作并可以获取其结果</code></pre><h5 id=\"旧的JS异步编程方案\"><a href=\"#旧的JS异步编程方案\" class=\"headerlink\" title=\"旧的JS异步编程方案\"></a>旧的JS异步编程方案</h5><p>​    纯回调机制-callback</p>\n<h3 id=\"promise的状态改变\"><a href=\"#promise的状态改变\" class=\"headerlink\" title=\"promise的状态改变\"></a>promise的状态改变</h3><blockquote>\n<p>初始值是pending；只有两种改变；且一个Promise对象只能改变一次；</p>\n<p>无论变为成功还是失败，都会有一个结果数据；</p>\n<p>成功的结果数据一般称为value ，失败的结果数据一般称为reason</p>\n</blockquote>\n<ul>\n<li>pending （初始化）未确定的</li>\n<li>pending 变为 resolved 成功</li>\n<li>pending 变为 rejected 失败</li>\n</ul>\n<h3 id=\"promise的基本流程\"><a href=\"#promise的基本流程\" class=\"headerlink\" title=\"promise的基本流程\"></a>promise的基本流程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[new Promise] --&gt; |pendding| B&#123;执行异步操作&#125;</span><br><span class=\"line\">B --&gt; |成功了,执行resolve| C[promise对象: resolved状态]</span><br><span class=\"line\">B --&gt; |失败了,执行reject| D[promise对象: rejected状态]</span><br><span class=\"line\">C --&gt; E[then 回调onResolved]</span><br><span class=\"line\">D --&gt; F[then&#x2F;catch 回调onRejected]</span><br><span class=\"line\">E --&gt; G[新的promise对象]</span><br><span class=\"line\">F --&gt; G[新的promise对象]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"promise的基本使用\"><a href=\"#promise的基本使用\" class=\"headerlink\" title=\"promise的基本使用\"></a>promise的基本使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行器函数  同步回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  <span class=\"comment\">// 执行异步任务</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功</span></span><br><span class=\"line\">    resolve(<span class=\"string\">`偶数: <span class=\"subst\">$&#123;time&#125;</span>`</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 失败</span></span><br><span class=\"line\">    reject(<span class=\"string\">`奇数: <span class=\"subst\">$&#123;time&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"comment\">// throw new Error(`奇数: $&#123;time&#125;`)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  (value) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收成功的value数据</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收失败的reason数据</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(reason)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// .catch((error) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// 会优先then 中的reason</span></span><br><span class=\"line\"><span class=\"comment\">// console.error('catch', error)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// .finally(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log('33333')</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要使用Promise-why\"><a href=\"#为什么要使用Promise-why\" class=\"headerlink\" title=\"为什么要使用Promise (why)\"></a>为什么要使用Promise (why)</h2><ol>\n<li><p>指定回调函数的方式更加灵活</p>\n<ul>\n<li><p>旧的回调机制</p>\n<p>必须在异步任务启动前指定回调函数</p>\n</li>\n<li><p>promise</p>\n<p>启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数（甚至可以在异步任务执行完有了结果后绑定回调函数）</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>   例：发送请求用户想等5秒执行回调函数</p>\n<p>   ​        旧的回调怎么实现？只能在回调函数套一个seTimeout,这破坏了回调函数的业务代码。</p>\n<p>   ​        promise则是启动异步任务后，拿到promise对象，你想什么时候执行都行，不需要改回调函数。</p>\n<p>   更利于代码可读性和维护性</p>\n<ol start=\"2\">\n<li><p>支持链式调用，可以解决回调地狱问题</p>\n<ul>\n<li><p>什么是回调地狱？</p>\n<p>回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p>\n</li>\n<li><p>回调地狱的缺点？</p>\n<p>不便于阅读/不便于异常处理</p>\n</li>\n<li><p>终极解决方案？async/await</p>\n</li>\n<li><p>异常穿透</p>\n</li>\n</ul>\n<h2 id=\"如何使用-how\"><a href=\"#如何使用-how\" class=\"headerlink\" title=\"如何使用 (how)\"></a>如何使用 (how)</h2></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Promise是什么-（what）\"><a href=\"#Promise是什么-（what）\" class=\"headerlink\" title=\"Promise是什么 （what）\"></a>Promise是什么 （what）</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><h5 id=\"抽象表达\"><a href=\"#抽象表达\" class=\"headerlink\" title=\"抽象表达\"></a>抽象表达</h5><p>​     Promise是JS中进行异步编程的新的解决方案（旧的是什么？）</p>\n<h5 id=\"具体表达\"><a href=\"#具体表达\" class=\"headerlink\" title=\"具体表达\"></a>具体表达</h5><pre><code>1. 从语法上来说：Promise是一个构造函数\n   2. 从功能上来说：promise对象用来封装一个异步操作并可以获取其结果</code></pre><h5 id=\"旧的JS异步编程方案\"><a href=\"#旧的JS异步编程方案\" class=\"headerlink\" title=\"旧的JS异步编程方案\"></a>旧的JS异步编程方案</h5><p>​    纯回调机制-callback</p>\n<h3 id=\"promise的状态改变\"><a href=\"#promise的状态改变\" class=\"headerlink\" title=\"promise的状态改变\"></a>promise的状态改变</h3><blockquote>\n<p>初始值是pending；只有两种改变；且一个Promise对象只能改变一次；</p>\n<p>无论变为成功还是失败，都会有一个结果数据；</p>\n<p>成功的结果数据一般称为value ，失败的结果数据一般称为reason</p>\n</blockquote>\n<ul>\n<li>pending （初始化）未确定的</li>\n<li>pending 变为 resolved 成功</li>\n<li>pending 变为 rejected 失败</li>\n</ul>\n<h3 id=\"promise的基本流程\"><a href=\"#promise的基本流程\" class=\"headerlink\" title=\"promise的基本流程\"></a>promise的基本流程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[new Promise] --&gt; |pendding| B&#123;执行异步操作&#125;</span><br><span class=\"line\">B --&gt; |成功了,执行resolve| C[promise对象: resolved状态]</span><br><span class=\"line\">B --&gt; |失败了,执行reject| D[promise对象: rejected状态]</span><br><span class=\"line\">C --&gt; E[then 回调onResolved]</span><br><span class=\"line\">D --&gt; F[then&#x2F;catch 回调onRejected]</span><br><span class=\"line\">E --&gt; G[新的promise对象]</span><br><span class=\"line\">F --&gt; G[新的promise对象]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"promise的基本使用\"><a href=\"#promise的基本使用\" class=\"headerlink\" title=\"promise的基本使用\"></a>promise的基本使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行器函数  同步回调</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  <span class=\"comment\">// 执行异步任务</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (time % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功</span></span><br><span class=\"line\">    resolve(<span class=\"string\">`偶数: <span class=\"subst\">$&#123;time&#125;</span>`</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 失败</span></span><br><span class=\"line\">    reject(<span class=\"string\">`奇数: <span class=\"subst\">$&#123;time&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"comment\">// throw new Error(`奇数: $&#123;time&#125;`)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  (value) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收成功的value数据</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  (reason) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收失败的reason数据</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(reason)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// .catch((error) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// 会优先then 中的reason</span></span><br><span class=\"line\"><span class=\"comment\">// console.error('catch', error)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// .finally(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log('33333')</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要使用Promise-why\"><a href=\"#为什么要使用Promise-why\" class=\"headerlink\" title=\"为什么要使用Promise (why)\"></a>为什么要使用Promise (why)</h2><ol>\n<li><p>指定回调函数的方式更加灵活</p>\n<ul>\n<li><p>旧的回调机制</p>\n<p>必须在异步任务启动前指定回调函数</p>\n</li>\n<li><p>promise</p>\n<p>启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数（甚至可以在异步任务执行完有了结果后绑定回调函数）</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>   例：发送请求用户想等5秒执行回调函数</p>\n<p>   ​        旧的回调怎么实现？只能在回调函数套一个seTimeout,这破坏了回调函数的业务代码。</p>\n<p>   ​        promise则是启动异步任务后，拿到promise对象，你想什么时候执行都行，不需要改回调函数。</p>\n<p>   更利于代码可读性和维护性</p>\n<ol start=\"2\">\n<li><p>支持链式调用，可以解决回调地狱问题</p>\n<ul>\n<li><p>什么是回调地狱？</p>\n<p>回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p>\n</li>\n<li><p>回调地狱的缺点？</p>\n<p>不便于阅读/不便于异常处理</p>\n</li>\n<li><p>终极解决方案？async/await</p>\n</li>\n<li><p>异常穿透</p>\n</li>\n</ul>\n<h2 id=\"如何使用-how\"><a href=\"#如何使用-how\" class=\"headerlink\" title=\"如何使用 (how)\"></a>如何使用 (how)</h2></li>\n</ol>\n"},{"_content":"### Promise构造函数\n\n``` javascript\nPromise (excutor){}\n```\n\n> excutor会在Promise内部立即同步回调，异步操作在执行器中执行\n\n- excutor函数：同步执行 ( resolve , reject ) => { }\n\n- resolved函数：内部定义成功时，调用函数 value => { }\n\n- rejected函数：内部定义失败时，调用函数 reason => { }\n\n  \n\n### Promise.prototype.then\n\n``` javascript\n(onResolved,onRejected) => { }\n```\n\n> 指定用于得到成功value的成功回调和用户得到失败的reason的失败回调返回一个新的promise对象\n\n- onResovled函数：成功的回调函数 (value) => { }\n\n- onRejected函数：失败的回调函数 (reason) => { }\n\n  \n\n### Promise.prototype.catch\n\n``` javascript\n(onRejected) => { }\n```\n\n> then() 的语法糖，相当于：then ( undefined , onRejected ) => { }\n\n- onRejected函数：失败的回调函数 ( reason ) => { }\n\n### Promise.resolve\n\n``` javascript\n(value) => { }\n```\n\n> 返回一个成功/失败的Promise对象\n\n- value : 成功的数据或promise对象\n\n   \n\n### Promise.reject \n\n``` javascript\n(reason) => { }\n```\n\n> 返回一个失败的Promise对象\n\n- reason ：失败的原因\n\n\n\n### Promise.all \n\n``` javascript\n( promises ) => { }\n```\n\n> 返回一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n\n- promises ：包含 N 个promise的数组\n\n\n\n### Promise.race \n\n``` javascript\n( promises ) => { }\n```\n\n> 返回一个新的promise ，第一个完成的promise的结果状态就是最终的结果状态\n\n- promises ：包含 N 个promise的数组\n\n","source":"_posts/自定义Promise/03-Promise API.md","raw":"### Promise构造函数\n\n``` javascript\nPromise (excutor){}\n```\n\n> excutor会在Promise内部立即同步回调，异步操作在执行器中执行\n\n- excutor函数：同步执行 ( resolve , reject ) => { }\n\n- resolved函数：内部定义成功时，调用函数 value => { }\n\n- rejected函数：内部定义失败时，调用函数 reason => { }\n\n  \n\n### Promise.prototype.then\n\n``` javascript\n(onResolved,onRejected) => { }\n```\n\n> 指定用于得到成功value的成功回调和用户得到失败的reason的失败回调返回一个新的promise对象\n\n- onResovled函数：成功的回调函数 (value) => { }\n\n- onRejected函数：失败的回调函数 (reason) => { }\n\n  \n\n### Promise.prototype.catch\n\n``` javascript\n(onRejected) => { }\n```\n\n> then() 的语法糖，相当于：then ( undefined , onRejected ) => { }\n\n- onRejected函数：失败的回调函数 ( reason ) => { }\n\n### Promise.resolve\n\n``` javascript\n(value) => { }\n```\n\n> 返回一个成功/失败的Promise对象\n\n- value : 成功的数据或promise对象\n\n   \n\n### Promise.reject \n\n``` javascript\n(reason) => { }\n```\n\n> 返回一个失败的Promise对象\n\n- reason ：失败的原因\n\n\n\n### Promise.all \n\n``` javascript\n( promises ) => { }\n```\n\n> 返回一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n\n- promises ：包含 N 个promise的数组\n\n\n\n### Promise.race \n\n``` javascript\n( promises ) => { }\n```\n\n> 返回一个新的promise ，第一个完成的promise的结果状态就是最终的结果状态\n\n- promises ：包含 N 个promise的数组\n\n","slug":"自定义Promise/03-Promise API","published":1,"date":"2020-06-25T03:10:24.449Z","updated":"2020-06-25T03:10:24.449Z","title":"自定义Promise/03-Promise API","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo3000m3ns6bn2j2whp","content":"<h3 id=\"Promise构造函数\"><a href=\"#Promise构造函数\" class=\"headerlink\" title=\"Promise构造函数\"></a>Promise构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span> (excutor)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>excutor会在Promise内部立即同步回调，异步操作在执行器中执行</p>\n</blockquote>\n<ul>\n<li><p>excutor函数：同步执行 ( resolve , reject ) =&gt; { }</p>\n</li>\n<li><p>resolved函数：内部定义成功时，调用函数 value =&gt; { }</p>\n</li>\n<li><p>rejected函数：内部定义失败时，调用函数 reason =&gt; { }</p>\n</li>\n</ul>\n<h3 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(onResolved,onRejected) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>指定用于得到成功value的成功回调和用户得到失败的reason的失败回调返回一个新的promise对象</p>\n</blockquote>\n<ul>\n<li><p>onResovled函数：成功的回调函数 (value) =&gt; { }</p>\n</li>\n<li><p>onRejected函数：失败的回调函数 (reason) =&gt; { }</p>\n</li>\n</ul>\n<h3 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(onRejected) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>then() 的语法糖，相当于：then ( undefined , onRejected ) =&gt; { }</p>\n</blockquote>\n<ul>\n<li>onRejected函数：失败的回调函数 ( reason ) =&gt; { }</li>\n</ul>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(value) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个成功/失败的Promise对象</p>\n</blockquote>\n<ul>\n<li>value : 成功的数据或promise对象</li>\n</ul>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(reason) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个失败的Promise对象</p>\n</blockquote>\n<ul>\n<li>reason ：失败的原因</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( promises ) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</p>\n</blockquote>\n<ul>\n<li>promises ：包含 N 个promise的数组</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( promises ) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个新的promise ，第一个完成的promise的结果状态就是最终的结果状态</p>\n</blockquote>\n<ul>\n<li>promises ：包含 N 个promise的数组</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Promise构造函数\"><a href=\"#Promise构造函数\" class=\"headerlink\" title=\"Promise构造函数\"></a>Promise构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span> (excutor)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>excutor会在Promise内部立即同步回调，异步操作在执行器中执行</p>\n</blockquote>\n<ul>\n<li><p>excutor函数：同步执行 ( resolve , reject ) =&gt; { }</p>\n</li>\n<li><p>resolved函数：内部定义成功时，调用函数 value =&gt; { }</p>\n</li>\n<li><p>rejected函数：内部定义失败时，调用函数 reason =&gt; { }</p>\n</li>\n</ul>\n<h3 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(onResolved,onRejected) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>指定用于得到成功value的成功回调和用户得到失败的reason的失败回调返回一个新的promise对象</p>\n</blockquote>\n<ul>\n<li><p>onResovled函数：成功的回调函数 (value) =&gt; { }</p>\n</li>\n<li><p>onRejected函数：失败的回调函数 (reason) =&gt; { }</p>\n</li>\n</ul>\n<h3 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(onRejected) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>then() 的语法糖，相当于：then ( undefined , onRejected ) =&gt; { }</p>\n</blockquote>\n<ul>\n<li>onRejected函数：失败的回调函数 ( reason ) =&gt; { }</li>\n</ul>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(value) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个成功/失败的Promise对象</p>\n</blockquote>\n<ul>\n<li>value : 成功的数据或promise对象</li>\n</ul>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(reason) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个失败的Promise对象</p>\n</blockquote>\n<ul>\n<li>reason ：失败的原因</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( promises ) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</p>\n</blockquote>\n<ul>\n<li>promises ：包含 N 个promise的数组</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( promises ) =&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>返回一个新的promise ，第一个完成的promise的结果状态就是最终的结果状态</p>\n</blockquote>\n<ul>\n<li>promises ：包含 N 个promise的数组</li>\n</ul>\n"},{"_content":"### 1. 如何改变promise的状态？\n\n##### resolve(value) \n\n如果当前时pending就会变为resolved\n\n##### reject(reason) \n\n如果当前时pending就会变为rejected\n\n##### 抛出异常\n\n如果当前时pending就会变为rejected\n\n``` javascript\nconst p = new Promise((resolve,reject)=>{\n  // throw new Error('错了') // rejected 状态，reason为error\n  throw 3  // rejected 状态，reason为3\n})\n```\n\n\n\n### 2. 一个promise指定多个成功/失败回调函数，会调用吗？\n\n当promise改变为对应状态时都会调用\n\n``` javascript\nconst p = new Promise((resolve,reject)=>{\n  // throw new Error('错了') // rejected 状态，reason为error\n  throw 3  // rejected 状态，reason为3\n})\n\np.then(\n  value => {},\n  reason => { console.log('a',reason) }  \n)\n\np.then(\n  value => {},\n  reason => { console.log('b',reason) }\n)\n\n// 结果 a 3 ,b 3  定义的回调函数都会执行\n```\n\n\n\n### 3. 改变promise状态和指定回调函数谁先谁后？\n\n> 都有可能\n\n- ##### 都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\n\n  ``` javascript\n  new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n      resolve(1) // 后改变的状态（同时指定数据），异步执行回调函数\n    },1000)\n  }).then( // 先指定回调函数，保存当前指定的回调函数\n     value => { console.log(value)  },\n     reason => { console.log(reason) }\n  )\n  ```\n\n- ##### 如何先改变状态再指定回调\n\n  1. 在执行器中直接调用resolve() / reject()\n\n     ``` javascript\n     new  Promise((resolve,reject) => {\n       resolve(1) // 先改变状态（同时指定数据）\n     }).then( // 后指定回调函数，异步执行回调函数\n     \tvalue => { console.log(value) }\n     )\n     ```\n\n  2. 延迟更长时间才调用then()\n\n     ``` javascript\n     const p = new  Promise((resolve,reject) =>{\n       resolve(1) // 先改变状态（同时指定数据）\n     })\n     \n     setTimeout(()=>{ // 后指定回调函数，异步执行回调函数\n       p.then( \n           value => { console.log(value)  },\n         \treason => { console.log(reason) }\n        )\n     },1000)\n     ```\n\n- ##### 什么时候才能得到函数？\n\n  1. 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据\n  2. 如果先改变的状态，那当指定回调时，回调函数就会调用，得到函数\n\n  \n\n### 4. promise.then( ) 返回的新promise的结果状态由什么决定？\n\n- ##### 简单表达\n\n  <u>*由then( )指定的回调函数执行结果决定*</u>\n\n- ##### 详细表达\n\n  1. 如果抛出异常，新的promise变为rejected，reason为抛出异常\n  \n     ``` javascript\n     new Promise((resolve, reject) => {\n         // resolve(0)\n         // reject(1)\n         throw 0\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             throw 'onResolved1 抛出了一个异常'\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             throw 'onRejected1 抛出了一个异常'\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n  2. 如果返回的是非promise的任意值，新的promise变为resolved，value为返回的值\n  \n     ``` javascript\n     new Promise((resolve, reject) => {\n         // resolve(0)\n         reject(0)\n         // throw 0\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             return 'onResolved1 1'\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             return 'onRejected1 1'\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n  3. 如果返回的是另一个新的promise，此promise的结果就会成为新promise的结果\n  \n     ``` javascript\n       new Promise((resolve, reject) => {\n         const title = '如果返回的是另一个新的promise'\n         // resolve(title)\n         reject(title)\n         // throw title\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             return new Promise((resolve, reject) => {\n               setTimeout(() => {\n                 resolve('onResolved1的Promise')\n               }, 100)\n             })\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             return new Promise((resolve, reject) => {\n               setTimeout(() => {\n                 resolve('onRejected1的Promise')\n               }, 100)\n             })\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n     \n\n### 5. promise如何串连多个操作任务\n\n1. promise的then( )返回一个新的promise，可以开成then( )的链式调用\n\n2. 通过then的链式调用<u>串连</u>多个同步/异步任务\n\n   - 同步: return  任意数据\n- 异步: return  new Promise()\n\n``` javascript\nnew Promise((resolve, reject) => {\n    resolve(1)\n  })\n    .then(\n      (value) => {\n        console.log('value 1', value)\n        return 'value1'\n      },\n      (reason) => {\n        console.log('reason 1', reason)\n        return Promise.reject('reason1')\n      }\n    )\n    .then(\n      (value) => {\n        console.log('value 2', value)\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            resolve('异步的value2')\n          }, 1000)\n        })\n      },\n      (reason) => {\n        console.log('reason 2', reason)\n      }\n    )\n    .then((value) => {\n      console.log('value 3', value)\n    })\n```\n\n\n\n### 6. promise异常传透\n\n> *不写reason，相当于指定了默认：reason=> throw reason*\n\n1. 当使用promise的then链式调用时，可以在最后指定失败的回调\n\n   ``` javascript\n   new Promise((resolve, reject) => {\n       throw '开始就抛出了异常'\n     })\n       .then((value) => value) // 不写reason，相当于指定了默认：reason=> throw reason\n       .then((value) => value)\n       .then((value) => value)\n       .catch((error) => {\n         console.log('最后catch的接收', error)\n       })\n   ```\n\n2. 前面任何操作出了异常，都会传到最后失败的回调中处理\n\n   ``` javascript\n   new Promise((resolve, reject) => {\n       resolve(0)\n     })\n       .then((value) => value)\n       .then((value) => {\n         throw 'onResolved2 抛出了异常'\n       })\n       .then((value) => value)\n       .catch((error) => {\n         console.log('最后catch的接收', error)\n       })\n   ```\n\n   \n\n### 7. 中断promise链\n\n> 当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数\n\n办法：在回调函数返回一个pending状态的promise对象\n\n``` javascript\nnew Promise((resolve, reject) => {\n    resolve(1)\n  })\n    .then((value) => {\n      console.log('onRejected 1')\n    })\n    .then((value) => {\n      return new Promise(() => {}) // 中断\n    })\n    .then((value) => value)\n    .catch((error) => {\n      console.log('catch', error)\n    })\n    .then((value) => {\n      console.log('最后一个then ', value)\n    })\n}\n```\n\n\n\n","source":"_posts/自定义Promise/04-promise中的关键问题.md","raw":"### 1. 如何改变promise的状态？\n\n##### resolve(value) \n\n如果当前时pending就会变为resolved\n\n##### reject(reason) \n\n如果当前时pending就会变为rejected\n\n##### 抛出异常\n\n如果当前时pending就会变为rejected\n\n``` javascript\nconst p = new Promise((resolve,reject)=>{\n  // throw new Error('错了') // rejected 状态，reason为error\n  throw 3  // rejected 状态，reason为3\n})\n```\n\n\n\n### 2. 一个promise指定多个成功/失败回调函数，会调用吗？\n\n当promise改变为对应状态时都会调用\n\n``` javascript\nconst p = new Promise((resolve,reject)=>{\n  // throw new Error('错了') // rejected 状态，reason为error\n  throw 3  // rejected 状态，reason为3\n})\n\np.then(\n  value => {},\n  reason => { console.log('a',reason) }  \n)\n\np.then(\n  value => {},\n  reason => { console.log('b',reason) }\n)\n\n// 结果 a 3 ,b 3  定义的回调函数都会执行\n```\n\n\n\n### 3. 改变promise状态和指定回调函数谁先谁后？\n\n> 都有可能\n\n- ##### 都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\n\n  ``` javascript\n  new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n      resolve(1) // 后改变的状态（同时指定数据），异步执行回调函数\n    },1000)\n  }).then( // 先指定回调函数，保存当前指定的回调函数\n     value => { console.log(value)  },\n     reason => { console.log(reason) }\n  )\n  ```\n\n- ##### 如何先改变状态再指定回调\n\n  1. 在执行器中直接调用resolve() / reject()\n\n     ``` javascript\n     new  Promise((resolve,reject) => {\n       resolve(1) // 先改变状态（同时指定数据）\n     }).then( // 后指定回调函数，异步执行回调函数\n     \tvalue => { console.log(value) }\n     )\n     ```\n\n  2. 延迟更长时间才调用then()\n\n     ``` javascript\n     const p = new  Promise((resolve,reject) =>{\n       resolve(1) // 先改变状态（同时指定数据）\n     })\n     \n     setTimeout(()=>{ // 后指定回调函数，异步执行回调函数\n       p.then( \n           value => { console.log(value)  },\n         \treason => { console.log(reason) }\n        )\n     },1000)\n     ```\n\n- ##### 什么时候才能得到函数？\n\n  1. 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据\n  2. 如果先改变的状态，那当指定回调时，回调函数就会调用，得到函数\n\n  \n\n### 4. promise.then( ) 返回的新promise的结果状态由什么决定？\n\n- ##### 简单表达\n\n  <u>*由then( )指定的回调函数执行结果决定*</u>\n\n- ##### 详细表达\n\n  1. 如果抛出异常，新的promise变为rejected，reason为抛出异常\n  \n     ``` javascript\n     new Promise((resolve, reject) => {\n         // resolve(0)\n         // reject(1)\n         throw 0\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             throw 'onResolved1 抛出了一个异常'\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             throw 'onRejected1 抛出了一个异常'\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n  2. 如果返回的是非promise的任意值，新的promise变为resolved，value为返回的值\n  \n     ``` javascript\n     new Promise((resolve, reject) => {\n         // resolve(0)\n         reject(0)\n         // throw 0\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             return 'onResolved1 1'\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             return 'onRejected1 1'\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n  3. 如果返回的是另一个新的promise，此promise的结果就会成为新promise的结果\n  \n     ``` javascript\n       new Promise((resolve, reject) => {\n         const title = '如果返回的是另一个新的promise'\n         // resolve(title)\n         reject(title)\n         // throw title\n       })\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态1:', value)\n             return new Promise((resolve, reject) => {\n               setTimeout(() => {\n                 resolve('onResolved1的Promise')\n               }, 100)\n             })\n           },\n           (reason) => {\n             console.log('onRejected 结果状态1:', reason)\n             return new Promise((resolve, reject) => {\n               setTimeout(() => {\n                 resolve('onRejected1的Promise')\n               }, 100)\n             })\n           }\n         )\n         .then(\n           (value) => {\n             console.log('onResolved 结果状态2:', value)\n           },\n           (reason) => {\n             console.log('onRejected 结果状态2:', reason)\n           }\n         )\n     ```\n  \n     \n\n### 5. promise如何串连多个操作任务\n\n1. promise的then( )返回一个新的promise，可以开成then( )的链式调用\n\n2. 通过then的链式调用<u>串连</u>多个同步/异步任务\n\n   - 同步: return  任意数据\n- 异步: return  new Promise()\n\n``` javascript\nnew Promise((resolve, reject) => {\n    resolve(1)\n  })\n    .then(\n      (value) => {\n        console.log('value 1', value)\n        return 'value1'\n      },\n      (reason) => {\n        console.log('reason 1', reason)\n        return Promise.reject('reason1')\n      }\n    )\n    .then(\n      (value) => {\n        console.log('value 2', value)\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            resolve('异步的value2')\n          }, 1000)\n        })\n      },\n      (reason) => {\n        console.log('reason 2', reason)\n      }\n    )\n    .then((value) => {\n      console.log('value 3', value)\n    })\n```\n\n\n\n### 6. promise异常传透\n\n> *不写reason，相当于指定了默认：reason=> throw reason*\n\n1. 当使用promise的then链式调用时，可以在最后指定失败的回调\n\n   ``` javascript\n   new Promise((resolve, reject) => {\n       throw '开始就抛出了异常'\n     })\n       .then((value) => value) // 不写reason，相当于指定了默认：reason=> throw reason\n       .then((value) => value)\n       .then((value) => value)\n       .catch((error) => {\n         console.log('最后catch的接收', error)\n       })\n   ```\n\n2. 前面任何操作出了异常，都会传到最后失败的回调中处理\n\n   ``` javascript\n   new Promise((resolve, reject) => {\n       resolve(0)\n     })\n       .then((value) => value)\n       .then((value) => {\n         throw 'onResolved2 抛出了异常'\n       })\n       .then((value) => value)\n       .catch((error) => {\n         console.log('最后catch的接收', error)\n       })\n   ```\n\n   \n\n### 7. 中断promise链\n\n> 当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数\n\n办法：在回调函数返回一个pending状态的promise对象\n\n``` javascript\nnew Promise((resolve, reject) => {\n    resolve(1)\n  })\n    .then((value) => {\n      console.log('onRejected 1')\n    })\n    .then((value) => {\n      return new Promise(() => {}) // 中断\n    })\n    .then((value) => value)\n    .catch((error) => {\n      console.log('catch', error)\n    })\n    .then((value) => {\n      console.log('最后一个then ', value)\n    })\n}\n```\n\n\n\n","slug":"自定义Promise/04-promise中的关键问题","published":1,"date":"2020-06-25T03:10:24.449Z","updated":"2020-06-25T03:10:24.449Z","title":"自定义Promise/04-promise中的关键问题","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo5000n3ns67mwl2i7o","content":"<h3 id=\"1-如何改变promise的状态？\"><a href=\"#1-如何改变promise的状态？\" class=\"headerlink\" title=\"1. 如何改变promise的状态？\"></a>1. 如何改变promise的状态？</h3><h5 id=\"resolve-value\"><a href=\"#resolve-value\" class=\"headerlink\" title=\"resolve(value)\"></a>resolve(value)</h5><p>如果当前时pending就会变为resolved</p>\n<h5 id=\"reject-reason\"><a href=\"#reject-reason\" class=\"headerlink\" title=\"reject(reason)\"></a>reject(reason)</h5><p>如果当前时pending就会变为rejected</p>\n<h5 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h5><p>如果当前时pending就会变为rejected</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('错了') // rejected 状态，reason为error</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"number\">3</span>  <span class=\"comment\">// rejected 状态，reason为3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-一个promise指定多个成功-失败回调函数，会调用吗？\"><a href=\"#2-一个promise指定多个成功-失败回调函数，会调用吗？\" class=\"headerlink\" title=\"2. 一个promise指定多个成功/失败回调函数，会调用吗？\"></a>2. 一个promise指定多个成功/失败回调函数，会调用吗？</h3><p>当promise改变为对应状态时都会调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('错了') // rejected 状态，reason为error</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"number\">3</span>  <span class=\"comment\">// rejected 状态，reason为3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  value =&gt; &#123;&#125;,</span><br><span class=\"line\">  reason =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>,reason) &#125;  </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  value =&gt; &#123;&#125;,</span><br><span class=\"line\">  reason =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,reason) &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果 a 3 ,b 3  定义的回调函数都会执行</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-改变promise状态和指定回调函数谁先谁后？\"><a href=\"#3-改变promise状态和指定回调函数谁先谁后？\" class=\"headerlink\" title=\"3. 改变promise状态和指定回调函数谁先谁后？\"></a>3. 改变promise状态和指定回调函数谁先谁后？</h3><blockquote>\n<p>都有可能</p>\n</blockquote>\n<ul>\n<li><h5 id=\"都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\"><a href=\"#都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\" class=\"headerlink\" title=\"都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\"></a>都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 后改变的状态（同时指定数据），异步执行回调函数</span></span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then( <span class=\"comment\">// 先指定回调函数，保存当前指定的回调函数</span></span><br><span class=\"line\">   value =&gt; &#123; <span class=\"built_in\">console</span>.log(value)  &#125;,</span><br><span class=\"line\">   reason =&gt; &#123; <span class=\"built_in\">console</span>.log(reason) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"如何先改变状态再指定回调\"><a href=\"#如何先改变状态再指定回调\" class=\"headerlink\" title=\"如何先改变状态再指定回调\"></a>如何先改变状态再指定回调</h5><ol>\n<li><p>在执行器中直接调用resolve() / reject()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span>  <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 先改变状态（同时指定数据）</span></span><br><span class=\"line\">&#125;).then( <span class=\"comment\">// 后指定回调函数，异步执行回调函数</span></span><br><span class=\"line\">\tvalue =&gt; &#123; <span class=\"built_in\">console</span>.log(value) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>延迟更长时间才调用then()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span>  <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 先改变状态（同时指定数据）</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; <span class=\"comment\">// 后指定回调函数，异步执行回调函数</span></span><br><span class=\"line\">  p.then( </span><br><span class=\"line\">      value =&gt; &#123; <span class=\"built_in\">console</span>.log(value)  &#125;,</span><br><span class=\"line\">    \treason =&gt; &#123; <span class=\"built_in\">console</span>.log(reason) &#125;</span><br><span class=\"line\">   )</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><h5 id=\"什么时候才能得到函数？\"><a href=\"#什么时候才能得到函数？\" class=\"headerlink\" title=\"什么时候才能得到函数？\"></a>什么时候才能得到函数？</h5><ol>\n<li>如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</li>\n<li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到函数</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-promise-then-返回的新promise的结果状态由什么决定？\"><a href=\"#4-promise-then-返回的新promise的结果状态由什么决定？\" class=\"headerlink\" title=\"4. promise.then( ) 返回的新promise的结果状态由什么决定？\"></a>4. promise.then( ) 返回的新promise的结果状态由什么决定？</h3><ul>\n<li><h5 id=\"简单表达\"><a href=\"#简单表达\" class=\"headerlink\" title=\"简单表达\"></a>简单表达</h5><p><u><em>由then( )指定的回调函数执行结果决定</em></u></p>\n</li>\n<li><h5 id=\"详细表达\"><a href=\"#详细表达\" class=\"headerlink\" title=\"详细表达\"></a>详细表达</h5><ol>\n<li><p>如果抛出异常，新的promise变为rejected，reason为抛出异常</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(0)</span></span><br><span class=\"line\">    <span class=\"comment\">// reject(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'onResolved1 抛出了一个异常'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'onRejected1 抛出了一个异常'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果返回的是非promise的任意值，新的promise变为resolved，value为返回的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(0)</span></span><br><span class=\"line\">    reject(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// throw 0</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'onResolved1 1'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'onRejected1 1'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果返回的是另一个新的promise，此promise的结果就会成为新promise的结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> title = <span class=\"string\">'如果返回的是另一个新的promise'</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve(title)</span></span><br><span class=\"line\">  reject(title)</span><br><span class=\"line\">  <span class=\"comment\">// throw title</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (value) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(<span class=\"string\">'onResolved1的Promise'</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    (reason) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(<span class=\"string\">'onRejected1的Promise'</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (value) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    (reason) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-promise如何串连多个操作任务\"><a href=\"#5-promise如何串连多个操作任务\" class=\"headerlink\" title=\"5. promise如何串连多个操作任务\"></a>5. promise如何串连多个操作任务</h3><ol>\n<li><p>promise的then( )返回一个新的promise，可以开成then( )的链式调用</p>\n</li>\n<li><p>通过then的链式调用<u>串连</u>多个同步/异步任务</p>\n<ul>\n<li>同步: return  任意数据</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>异步: return  new Promise()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 1'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'value1'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'reason 1'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'reason1'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 2'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">'异步的value2'</span>)</span><br><span class=\"line\">          &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'reason 2'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 3'</span>, value)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-promise异常传透\"><a href=\"#6-promise异常传透\" class=\"headerlink\" title=\"6. promise异常传透\"></a>6. promise异常传透</h3><blockquote>\n<p><em>不写reason，相当于指定了默认：reason=&gt; throw reason</em></p>\n</blockquote>\n<ol>\n<li><p>当使用promise的then链式调用时，可以在最后指定失败的回调</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'开始就抛出了异常'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value) <span class=\"comment\">// 不写reason，相当于指定了默认：reason=&gt; throw reason</span></span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后catch的接收'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前面任何操作出了异常，都会传到最后失败的回调中处理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">'onResolved2 抛出了异常'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后catch的接收'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h3 id=\"7-中断promise链\"><a href=\"#7-中断promise链\" class=\"headerlink\" title=\"7. 中断promise链\"></a>7. 中断promise链</h3><blockquote>\n<p>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</p>\n</blockquote>\n<p>办法：在回调函数返回一个pending状态的promise对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 1'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;) <span class=\"comment\">// 中断</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后一个then '</span>, value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-如何改变promise的状态？\"><a href=\"#1-如何改变promise的状态？\" class=\"headerlink\" title=\"1. 如何改变promise的状态？\"></a>1. 如何改变promise的状态？</h3><h5 id=\"resolve-value\"><a href=\"#resolve-value\" class=\"headerlink\" title=\"resolve(value)\"></a>resolve(value)</h5><p>如果当前时pending就会变为resolved</p>\n<h5 id=\"reject-reason\"><a href=\"#reject-reason\" class=\"headerlink\" title=\"reject(reason)\"></a>reject(reason)</h5><p>如果当前时pending就会变为rejected</p>\n<h5 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h5><p>如果当前时pending就会变为rejected</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('错了') // rejected 状态，reason为error</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"number\">3</span>  <span class=\"comment\">// rejected 状态，reason为3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-一个promise指定多个成功-失败回调函数，会调用吗？\"><a href=\"#2-一个promise指定多个成功-失败回调函数，会调用吗？\" class=\"headerlink\" title=\"2. 一个promise指定多个成功/失败回调函数，会调用吗？\"></a>2. 一个promise指定多个成功/失败回调函数，会调用吗？</h3><p>当promise改变为对应状态时都会调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// throw new Error('错了') // rejected 状态，reason为error</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"number\">3</span>  <span class=\"comment\">// rejected 状态，reason为3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  value =&gt; &#123;&#125;,</span><br><span class=\"line\">  reason =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>,reason) &#125;  </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(</span><br><span class=\"line\">  value =&gt; &#123;&#125;,</span><br><span class=\"line\">  reason =&gt; &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'b'</span>,reason) &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果 a 3 ,b 3  定义的回调函数都会执行</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-改变promise状态和指定回调函数谁先谁后？\"><a href=\"#3-改变promise状态和指定回调函数谁先谁后？\" class=\"headerlink\" title=\"3. 改变promise状态和指定回调函数谁先谁后？\"></a>3. 改变promise状态和指定回调函数谁先谁后？</h3><blockquote>\n<p>都有可能</p>\n</blockquote>\n<ul>\n<li><h5 id=\"都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\"><a href=\"#都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\" class=\"headerlink\" title=\"都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调\"></a>都有可能，正常情况下时先指定回调再改变状态，但也可以先改状态再指定回调</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 后改变的状态（同时指定数据），异步执行回调函数</span></span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then( <span class=\"comment\">// 先指定回调函数，保存当前指定的回调函数</span></span><br><span class=\"line\">   value =&gt; &#123; <span class=\"built_in\">console</span>.log(value)  &#125;,</span><br><span class=\"line\">   reason =&gt; &#123; <span class=\"built_in\">console</span>.log(reason) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><h5 id=\"如何先改变状态再指定回调\"><a href=\"#如何先改变状态再指定回调\" class=\"headerlink\" title=\"如何先改变状态再指定回调\"></a>如何先改变状态再指定回调</h5><ol>\n<li><p>在执行器中直接调用resolve() / reject()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span>  <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 先改变状态（同时指定数据）</span></span><br><span class=\"line\">&#125;).then( <span class=\"comment\">// 后指定回调函数，异步执行回调函数</span></span><br><span class=\"line\">\tvalue =&gt; &#123; <span class=\"built_in\">console</span>.log(value) &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>延迟更长时间才调用then()</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span>  <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class=\"line\">  resolve(<span class=\"number\">1</span>) <span class=\"comment\">// 先改变状态（同时指定数据）</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123; <span class=\"comment\">// 后指定回调函数，异步执行回调函数</span></span><br><span class=\"line\">  p.then( </span><br><span class=\"line\">      value =&gt; &#123; <span class=\"built_in\">console</span>.log(value)  &#125;,</span><br><span class=\"line\">    \treason =&gt; &#123; <span class=\"built_in\">console</span>.log(reason) &#125;</span><br><span class=\"line\">   )</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><h5 id=\"什么时候才能得到函数？\"><a href=\"#什么时候才能得到函数？\" class=\"headerlink\" title=\"什么时候才能得到函数？\"></a>什么时候才能得到函数？</h5><ol>\n<li>如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</li>\n<li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到函数</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"4-promise-then-返回的新promise的结果状态由什么决定？\"><a href=\"#4-promise-then-返回的新promise的结果状态由什么决定？\" class=\"headerlink\" title=\"4. promise.then( ) 返回的新promise的结果状态由什么决定？\"></a>4. promise.then( ) 返回的新promise的结果状态由什么决定？</h3><ul>\n<li><h5 id=\"简单表达\"><a href=\"#简单表达\" class=\"headerlink\" title=\"简单表达\"></a>简单表达</h5><p><u><em>由then( )指定的回调函数执行结果决定</em></u></p>\n</li>\n<li><h5 id=\"详细表达\"><a href=\"#详细表达\" class=\"headerlink\" title=\"详细表达\"></a>详细表达</h5><ol>\n<li><p>如果抛出异常，新的promise变为rejected，reason为抛出异常</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(0)</span></span><br><span class=\"line\">    <span class=\"comment\">// reject(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'onResolved1 抛出了一个异常'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'onRejected1 抛出了一个异常'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果返回的是非promise的任意值，新的promise变为resolved，value为返回的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(0)</span></span><br><span class=\"line\">    reject(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// throw 0</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'onResolved1 1'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'onRejected1 1'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果返回的是另一个新的promise，此promise的结果就会成为新promise的结果</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> title = <span class=\"string\">'如果返回的是另一个新的promise'</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve(title)</span></span><br><span class=\"line\">  reject(title)</span><br><span class=\"line\">  <span class=\"comment\">// throw title</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (value) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态1:'</span>, value)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(<span class=\"string\">'onResolved1的Promise'</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    (reason) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态1:'</span>, reason)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          resolve(<span class=\"string\">'onRejected1的Promise'</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .then(</span><br><span class=\"line\">    (value) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onResolved 结果状态2:'</span>, value)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    (reason) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 结果状态2:'</span>, reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-promise如何串连多个操作任务\"><a href=\"#5-promise如何串连多个操作任务\" class=\"headerlink\" title=\"5. promise如何串连多个操作任务\"></a>5. promise如何串连多个操作任务</h3><ol>\n<li><p>promise的then( )返回一个新的promise，可以开成then( )的链式调用</p>\n</li>\n<li><p>通过then的链式调用<u>串连</u>多个同步/异步任务</p>\n<ul>\n<li>同步: return  任意数据</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>异步: return  new Promise()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 1'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'value1'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'reason 1'</span>, reason)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'reason1'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(</span><br><span class=\"line\">      (value) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 2'</span>, value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">'异步的value2'</span>)</span><br><span class=\"line\">          &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      (reason) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'reason 2'</span>, reason)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'value 3'</span>, value)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"6-promise异常传透\"><a href=\"#6-promise异常传透\" class=\"headerlink\" title=\"6. promise异常传透\"></a>6. promise异常传透</h3><blockquote>\n<p><em>不写reason，相当于指定了默认：reason=&gt; throw reason</em></p>\n</blockquote>\n<ol>\n<li><p>当使用promise的then链式调用时，可以在最后指定失败的回调</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'开始就抛出了异常'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value) <span class=\"comment\">// 不写reason，相当于指定了默认：reason=&gt; throw reason</span></span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后catch的接收'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前面任何操作出了异常，都会传到最后失败的回调中处理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">'onResolved2 抛出了异常'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后catch的接收'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h3 id=\"7-中断promise链\"><a href=\"#7-中断promise链\" class=\"headerlink\" title=\"7. 中断promise链\"></a>7. 中断promise链</h3><blockquote>\n<p>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</p>\n</blockquote>\n<p>办法：在回调函数返回一个pending状态的promise对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'onRejected 1'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;) <span class=\"comment\">// 中断</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> value)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'catch'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'最后一个then '</span>, value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"[Link](https://github.com/antqi/test/blob/master/promise/lib/promise-class.js)\n\n","source":"_posts/自定义Promise/06-自定义Promise-class版本.md","raw":"[Link](https://github.com/antqi/test/blob/master/promise/lib/promise-class.js)\n\n","slug":"自定义Promise/06-自定义Promise-class版本","published":1,"date":"2020-06-25T03:10:24.450Z","updated":"2020-06-25T03:10:24.450Z","title":"自定义Promise/06-自定义Promise-class版本","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo5000o3ns63t7p0rze","content":"<p><a href=\"https://github.com/antqi/test/blob/master/promise/lib/promise-class.js\" target=\"_blank\" rel=\"noopener\">Link</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/antqi/test/blob/master/promise/lib/promise-class.js\" target=\"_blank\" rel=\"noopener\">Link</a></p>\n"},{"_content":"## async函数\n\n- 函数的返回值为promise对象\n- promise对象的结果由async函数执行的返回值决定\n\n## await表达式\n\n- await右侧的表达式一般为promise对象，但也可以是其它的值\n- 如果表达式是promise对象，await返回的是promise成功的值\n- 如果表达式是其它值，直接将此值作为await的返回值\n- await必须写在async函数中，但async函数中可以没有await\n- 如果await的promise失败了，就会抛出异常，需要通过try...catch来捕获处理","source":"_posts/自定义Promise/07-async&await.md","raw":"## async函数\n\n- 函数的返回值为promise对象\n- promise对象的结果由async函数执行的返回值决定\n\n## await表达式\n\n- await右侧的表达式一般为promise对象，但也可以是其它的值\n- 如果表达式是promise对象，await返回的是promise成功的值\n- 如果表达式是其它值，直接将此值作为await的返回值\n- await必须写在async函数中，但async函数中可以没有await\n- 如果await的promise失败了，就会抛出异常，需要通过try...catch来捕获处理","slug":"自定义Promise/07-async&await","published":1,"date":"2020-06-25T03:10:24.451Z","updated":"2020-06-25T03:10:24.451Z","title":"自定义Promise/07-async&await","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo6000p3ns6472b8bzw","content":"<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><ul>\n<li>函数的返回值为promise对象</li>\n<li>promise对象的结果由async函数执行的返回值决定</li>\n</ul>\n<h2 id=\"await表达式\"><a href=\"#await表达式\" class=\"headerlink\" title=\"await表达式\"></a>await表达式</h2><ul>\n<li>await右侧的表达式一般为promise对象，但也可以是其它的值</li>\n<li>如果表达式是promise对象，await返回的是promise成功的值</li>\n<li>如果表达式是其它值，直接将此值作为await的返回值</li>\n<li>await必须写在async函数中，但async函数中可以没有await</li>\n<li>如果await的promise失败了，就会抛出异常，需要通过try…catch来捕获处理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"async函数\"><a href=\"#async函数\" class=\"headerlink\" title=\"async函数\"></a>async函数</h2><ul>\n<li>函数的返回值为promise对象</li>\n<li>promise对象的结果由async函数执行的返回值决定</li>\n</ul>\n<h2 id=\"await表达式\"><a href=\"#await表达式\" class=\"headerlink\" title=\"await表达式\"></a>await表达式</h2><ul>\n<li>await右侧的表达式一般为promise对象，但也可以是其它的值</li>\n<li>如果表达式是promise对象，await返回的是promise成功的值</li>\n<li>如果表达式是其它值，直接将此值作为await的返回值</li>\n<li>await必须写在async函数中，但async函数中可以没有await</li>\n<li>如果await的promise失败了，就会抛出异常，需要通过try…catch来捕获处理</li>\n</ul>\n"},{"_content":"> Event Loop （事件循环），了解Event Loop 先了解它的由来\n\n\n\n## JavaScript运行机制\n\n- JavaScript 为什么是单线程？\n\n  和用途有关，主要用途是与用户互动，以及操作DOM，这就决定了它只能是单线程，否则会带来很复杂的同步问题\n\n- 任务队列\n\n  单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务不得不一直等着。\n\n  而很多时候，CPU是闲着的，IO设备慢（比如Ajax网络请求）导致的任务阻塞。\n\n  这时候主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等IO设备返回了，再把挂起的任务继续执行下去。\n\n  于是任务可以分成两种：<u>同步任务</u>，<u>异步任务</u>\n\n  - 同步任务：在主线程上排队执行的任务，只有但前的任务完成，才能执行后一个任务。\n  - 异步任务：不进入主线程、而进去task queue的任务，只有task queue通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n- 异步执行的运行机制\n\n  - 所有同步任务都在主线程上，形成一个<u>执行栈(execution context stack)</u>。\n  - 主线程之外，还存在一个<u>“任务队列” task queue</u>。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。\n  - 一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n  - 主线程不断重复上面的第三步。只要主线程空了，就会去读取“任务队列”。这就是JavaScript的运行机制\n\n\n\n## 事件和回调函数\n\n- 任务队列\n\n  是一个事件的队列（也称消息队列）。IO设备每完成一项任务，就在任务队列中添加一个事件，比碍事相关的异步任务可以进入执行栈了，等待主线程完成同步任务来读取。\n\n- 任务队列中的事件\n\n  除了IO设备的事件外，用户产生的事件，如：鼠标点击、页面滚动等。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。\n\n任务队列是一个先进先出的数据结构。\n\n`备注：定时器`\n\n\n\n## Event Loop\n\n主线程丛任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<u>Event Loop（事件循环）</u>\n\n主线程运行的时候产生堆(heap)、栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done），只要执行栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。\n\n![image-20200605172837411](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200605172837411.png)\n\n执行栈中的代码（同步任务），总是在读取任务队列（异步任务）之前执行。\n\n``` javascript\nvar req = new XMLHttpRequest()\nreq.open('GET',url)\nreq.onload = function(){}\nreq.onerror = function(){}\nreq.send()\n```\n\n`req.send()`方法是Ajax操作向服务器发送数据，是一个异步任务。也就是说：只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以以上代码等等价于下段代码。\n\n``` javascript\nvar req = new XMLHttpRequest()\nreq.open('GET',url)\nreq.send()\nreq.onload = function(){}\nreq.onerror = function(){}\n```\n\n指定的回调函数`onload` 、`onerror` 在`send` 方法前端或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”\n\n\n\n## 定时器\n\n除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行——“定时器”(timer)功能，也就是定时执行的代码。\n\n定时器功能主要由`setTimeoue()`和 `setInterval()`这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者为反复执行。\n\n`seTimeout( Function callback , time)` 接收两个参数，回调函数、推迟执行的毫秒数\n\n``` javascript\nconsole.log(1)\nsetTimeout(function(){\n  console.log(2)\n},1000)\nconsole.log(3)\n// 1 3 2\n```\n\n``` javascript\nconsole.log(1)\nsetTimeout(function(){\n  console.log(2)\n},0)\n// 2 1\n```\n\n`setTimeout(fn,0)`的含义是：指定某个任务在主线程最早可得的空闲时间执行。它在“任务队列”尾部添加一个事件，等到同步任务和“任务队列”已有的事件处理完毕，得到执行。\n\n对于DOM的变动（尤其是页面重新渲染部分），通常不会立即执行，二是每16毫秒执行一次。这时候使用`requestAnimationFrame()`的效果要好于`setTimeout()`  ，这里可以引申<u>宏任务</u>和<u>微任务</u>\n\n注意的点：`setTimeout()`只是将事件插入了“任务队列”，必须等到执行栈执行完，主线程才会去执行它执行的回调函数。要是当前代码消耗很长，有可能要等很久，所以并没有办法保证，回调函数一定会在`setTimeout() `指定的事件执行\n\n","source":"_posts/自定义Promise/Event Loop.md","raw":"> Event Loop （事件循环），了解Event Loop 先了解它的由来\n\n\n\n## JavaScript运行机制\n\n- JavaScript 为什么是单线程？\n\n  和用途有关，主要用途是与用户互动，以及操作DOM，这就决定了它只能是单线程，否则会带来很复杂的同步问题\n\n- 任务队列\n\n  单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务不得不一直等着。\n\n  而很多时候，CPU是闲着的，IO设备慢（比如Ajax网络请求）导致的任务阻塞。\n\n  这时候主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等IO设备返回了，再把挂起的任务继续执行下去。\n\n  于是任务可以分成两种：<u>同步任务</u>，<u>异步任务</u>\n\n  - 同步任务：在主线程上排队执行的任务，只有但前的任务完成，才能执行后一个任务。\n  - 异步任务：不进入主线程、而进去task queue的任务，只有task queue通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n- 异步执行的运行机制\n\n  - 所有同步任务都在主线程上，形成一个<u>执行栈(execution context stack)</u>。\n  - 主线程之外，还存在一个<u>“任务队列” task queue</u>。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。\n  - 一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n  - 主线程不断重复上面的第三步。只要主线程空了，就会去读取“任务队列”。这就是JavaScript的运行机制\n\n\n\n## 事件和回调函数\n\n- 任务队列\n\n  是一个事件的队列（也称消息队列）。IO设备每完成一项任务，就在任务队列中添加一个事件，比碍事相关的异步任务可以进入执行栈了，等待主线程完成同步任务来读取。\n\n- 任务队列中的事件\n\n  除了IO设备的事件外，用户产生的事件，如：鼠标点击、页面滚动等。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。\n\n任务队列是一个先进先出的数据结构。\n\n`备注：定时器`\n\n\n\n## Event Loop\n\n主线程丛任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<u>Event Loop（事件循环）</u>\n\n主线程运行的时候产生堆(heap)、栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done），只要执行栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。\n\n![image-20200605172837411](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200605172837411.png)\n\n执行栈中的代码（同步任务），总是在读取任务队列（异步任务）之前执行。\n\n``` javascript\nvar req = new XMLHttpRequest()\nreq.open('GET',url)\nreq.onload = function(){}\nreq.onerror = function(){}\nreq.send()\n```\n\n`req.send()`方法是Ajax操作向服务器发送数据，是一个异步任务。也就是说：只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以以上代码等等价于下段代码。\n\n``` javascript\nvar req = new XMLHttpRequest()\nreq.open('GET',url)\nreq.send()\nreq.onload = function(){}\nreq.onerror = function(){}\n```\n\n指定的回调函数`onload` 、`onerror` 在`send` 方法前端或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”\n\n\n\n## 定时器\n\n除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行——“定时器”(timer)功能，也就是定时执行的代码。\n\n定时器功能主要由`setTimeoue()`和 `setInterval()`这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者为反复执行。\n\n`seTimeout( Function callback , time)` 接收两个参数，回调函数、推迟执行的毫秒数\n\n``` javascript\nconsole.log(1)\nsetTimeout(function(){\n  console.log(2)\n},1000)\nconsole.log(3)\n// 1 3 2\n```\n\n``` javascript\nconsole.log(1)\nsetTimeout(function(){\n  console.log(2)\n},0)\n// 2 1\n```\n\n`setTimeout(fn,0)`的含义是：指定某个任务在主线程最早可得的空闲时间执行。它在“任务队列”尾部添加一个事件，等到同步任务和“任务队列”已有的事件处理完毕，得到执行。\n\n对于DOM的变动（尤其是页面重新渲染部分），通常不会立即执行，二是每16毫秒执行一次。这时候使用`requestAnimationFrame()`的效果要好于`setTimeout()`  ，这里可以引申<u>宏任务</u>和<u>微任务</u>\n\n注意的点：`setTimeout()`只是将事件插入了“任务队列”，必须等到执行栈执行完，主线程才会去执行它执行的回调函数。要是当前代码消耗很长，有可能要等很久，所以并没有办法保证，回调函数一定会在`setTimeout() `指定的事件执行\n\n","slug":"自定义Promise/Event Loop","published":1,"date":"2020-06-25T03:10:24.451Z","updated":"2020-06-25T03:15:10.762Z","title":"自定义Promise/Event Loop","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo7000q3ns6fnhv1wyf","content":"<blockquote>\n<p>Event Loop （事件循环），了解Event Loop 先了解它的由来</p>\n</blockquote>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><ul>\n<li><p>JavaScript 为什么是单线程？</p>\n<p>和用途有关，主要用途是与用户互动，以及操作DOM，这就决定了它只能是单线程，否则会带来很复杂的同步问题</p>\n</li>\n<li><p>任务队列</p>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务不得不一直等着。</p>\n<p>而很多时候，CPU是闲着的，IO设备慢（比如Ajax网络请求）导致的任务阻塞。</p>\n<p>这时候主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等IO设备返回了，再把挂起的任务继续执行下去。</p>\n<p>于是任务可以分成两种：<u>同步任务</u>，<u>异步任务</u></p>\n<ul>\n<li>同步任务：在主线程上排队执行的任务，只有但前的任务完成，才能执行后一个任务。</li>\n<li>异步任务：不进入主线程、而进去task queue的任务，只有task queue通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>\n</ul>\n</li>\n<li><p>异步执行的运行机制</p>\n<ul>\n<li>所有同步任务都在主线程上，形成一个<u>执行栈(execution context stack)</u>。</li>\n<li>主线程之外，还存在一个<u>“任务队列” task queue</u>。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li>\n<li>一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>\n<li>主线程不断重复上面的第三步。只要主线程空了，就会去读取“任务队列”。这就是JavaScript的运行机制</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事件和回调函数\"><a href=\"#事件和回调函数\" class=\"headerlink\" title=\"事件和回调函数\"></a>事件和回调函数</h2><ul>\n<li><p>任务队列</p>\n<p>是一个事件的队列（也称消息队列）。IO设备每完成一项任务，就在任务队列中添加一个事件，比碍事相关的异步任务可以进入执行栈了，等待主线程完成同步任务来读取。</p>\n</li>\n<li><p>任务队列中的事件</p>\n<p>除了IO设备的事件外，用户产生的事件，如：鼠标点击、页面滚动等。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。</p>\n</li>\n</ul>\n<p>任务队列是一个先进先出的数据结构。</p>\n<p><code>备注：定时器</code></p>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程丛任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<u>Event Loop（事件循环）</u></p>\n<p>主线程运行的时候产生堆(heap)、栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done），只要执行栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。</p>\n<p>![image-20200605172837411](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200605172837411.png)</p>\n<p>执行栈中的代码（同步任务），总是在读取任务队列（异步任务）之前执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">req.open(<span class=\"string\">'GET'</span>,url)</span><br><span class=\"line\">req.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.send()</span><br></pre></td></tr></table></figure>\n\n<p><code>req.send()</code>方法是Ajax操作向服务器发送数据，是一个异步任务。也就是说：只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以以上代码等等价于下段代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">req.open(<span class=\"string\">'GET'</span>,url)</span><br><span class=\"line\">req.send()</span><br><span class=\"line\">req.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>指定的回调函数<code>onload</code> 、<code>onerror</code> 在<code>send</code> 方法前端或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行——“定时器”(timer)功能，也就是定时执行的代码。</p>\n<p>定时器功能主要由<code>setTimeoue()</code>和 <code>setInterval()</code>这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者为反复执行。</p>\n<p><code>seTimeout( Function callback , time)</code> 接收两个参数，回调函数、推迟执行的毫秒数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// 1 3 2</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 2 1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>setTimeout(fn,0)</code>的含义是：指定某个任务在主线程最早可得的空闲时间执行。它在“任务队列”尾部添加一个事件，等到同步任务和“任务队列”已有的事件处理完毕，得到执行。</p>\n<p>对于DOM的变动（尤其是页面重新渲染部分），通常不会立即执行，二是每16毫秒执行一次。这时候使用<code>requestAnimationFrame()</code>的效果要好于<code>setTimeout()</code>  ，这里可以引申<u>宏任务</u>和<u>微任务</u></p>\n<p>注意的点：<code>setTimeout()</code>只是将事件插入了“任务队列”，必须等到执行栈执行完，主线程才会去执行它执行的回调函数。要是当前代码消耗很长，有可能要等很久，所以并没有办法保证，回调函数一定会在<code>setTimeout()</code>指定的事件执行</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Event Loop （事件循环），了解Event Loop 先了解它的由来</p>\n</blockquote>\n<h2 id=\"JavaScript运行机制\"><a href=\"#JavaScript运行机制\" class=\"headerlink\" title=\"JavaScript运行机制\"></a>JavaScript运行机制</h2><ul>\n<li><p>JavaScript 为什么是单线程？</p>\n<p>和用途有关，主要用途是与用户互动，以及操作DOM，这就决定了它只能是单线程，否则会带来很复杂的同步问题</p>\n</li>\n<li><p>任务队列</p>\n<p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务不得不一直等着。</p>\n<p>而很多时候，CPU是闲着的，IO设备慢（比如Ajax网络请求）导致的任务阻塞。</p>\n<p>这时候主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等IO设备返回了，再把挂起的任务继续执行下去。</p>\n<p>于是任务可以分成两种：<u>同步任务</u>，<u>异步任务</u></p>\n<ul>\n<li>同步任务：在主线程上排队执行的任务，只有但前的任务完成，才能执行后一个任务。</li>\n<li>异步任务：不进入主线程、而进去task queue的任务，只有task queue通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>\n</ul>\n</li>\n<li><p>异步执行的运行机制</p>\n<ul>\n<li>所有同步任务都在主线程上，形成一个<u>执行栈(execution context stack)</u>。</li>\n<li>主线程之外，还存在一个<u>“任务队列” task queue</u>。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li>\n<li>一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>\n<li>主线程不断重复上面的第三步。只要主线程空了，就会去读取“任务队列”。这就是JavaScript的运行机制</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事件和回调函数\"><a href=\"#事件和回调函数\" class=\"headerlink\" title=\"事件和回调函数\"></a>事件和回调函数</h2><ul>\n<li><p>任务队列</p>\n<p>是一个事件的队列（也称消息队列）。IO设备每完成一项任务，就在任务队列中添加一个事件，比碍事相关的异步任务可以进入执行栈了，等待主线程完成同步任务来读取。</p>\n</li>\n<li><p>任务队列中的事件</p>\n<p>除了IO设备的事件外，用户产生的事件，如：鼠标点击、页面滚动等。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。</p>\n</li>\n</ul>\n<p>任务队列是一个先进先出的数据结构。</p>\n<p><code>备注：定时器</code></p>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>主线程丛任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<u>Event Loop（事件循环）</u></p>\n<p>主线程运行的时候产生堆(heap)、栈(stack)，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done），只要执行栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。</p>\n<p>![image-20200605172837411](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200605172837411.png)</p>\n<p>执行栈中的代码（同步任务），总是在读取任务队列（异步任务）之前执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">req.open(<span class=\"string\">'GET'</span>,url)</span><br><span class=\"line\">req.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.send()</span><br></pre></td></tr></table></figure>\n\n<p><code>req.send()</code>方法是Ajax操作向服务器发送数据，是一个异步任务。也就是说：只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以以上代码等等价于下段代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">req.open(<span class=\"string\">'GET'</span>,url)</span><br><span class=\"line\">req.send()</span><br><span class=\"line\">req.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">req.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>指定的回调函数<code>onload</code> 、<code>onerror</code> 在<code>send</code> 方法前端或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”</p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行——“定时器”(timer)功能，也就是定时执行的代码。</p>\n<p>定时器功能主要由<code>setTimeoue()</code>和 <code>setInterval()</code>这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者为反复执行。</p>\n<p><code>seTimeout( Function callback , time)</code> 接收两个参数，回调函数、推迟执行的毫秒数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// 1 3 2</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// 2 1</span></span><br></pre></td></tr></table></figure>\n\n<p><code>setTimeout(fn,0)</code>的含义是：指定某个任务在主线程最早可得的空闲时间执行。它在“任务队列”尾部添加一个事件，等到同步任务和“任务队列”已有的事件处理完毕，得到执行。</p>\n<p>对于DOM的变动（尤其是页面重新渲染部分），通常不会立即执行，二是每16毫秒执行一次。这时候使用<code>requestAnimationFrame()</code>的效果要好于<code>setTimeout()</code>  ，这里可以引申<u>宏任务</u>和<u>微任务</u></p>\n<p>注意的点：<code>setTimeout()</code>只是将事件插入了“任务队列”，必须等到执行栈执行完，主线程才会去执行它执行的回调函数。要是当前代码消耗很长，有可能要等很久，所以并没有办法保证，回调函数一定会在<code>setTimeout()</code>指定的事件执行</p>\n"},{"_content":"## Event Loop是什么\n\n> event loop 是一个**执行模型**，在不同的地方有不同的实现。浏览器和NodeJs基于不同的技术实现了各自的Event Loop\n\n- 浏览器的Event Loop是在[html5的规范](https://www.w3.org/TR/html5/webappapis.html#event-loops)中明确定义。但只是定义了浏览器中Event Loop的模型，具体实现留给了浏览器厂商\n\n- NodeJS的Event Loop是基于libuv实现的。可以参考Node的[官方文档](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)以及libuv的[官方文档](http://docs.libuv.org/en/v1.x/design.html)。并且libuv对Event Loop做出了实现。\n\n\n\n## 宏队列和微队列\n\n**宏队列-macrotask，也叫tasks**。一些异步任务的回调回依次进入macro task queue，等待后续被调用。这些异步任务包括：\n\n- setTimeout\n- setInterval\n- setImmediate(Node独有)\n- requestAnimationFrame(浏览器独有)\n- I/O\n- UI rendering(浏览器独有)\n\n**微队列-microtask，也叫jobs**。另一些异步任务的回调回依次进入micro task queue，等待后续被调用，这些异步任务包括：\n\n- process.nextTick(Node独有)\n\n- Promise\n\n- Object.observe\n\n- MutationObserver\n\n  \n\n## 浏览器的Event Loop\n\n补充图\n\n执行JavaScrept代码的具体流程：\n\n1. 执行全局脚本同步代码，这些同步代码有一些事同步语句，有一些是异步语句（比如setTimeout）；\n2. 全局脚本代码执行完毕后，调用栈Stack会清空；\n3. 从任务队列中取出可执行任务，也就是微队列和宏队列，<u>优先微队列</u>；\n4. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue 长度-1\n5. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推重复，直到microtask queue中的所有任务都执行完毕。如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\n6. microtask queue 中所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n7. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n8. 执行完毕后，调用栈Stack为空；\n9. 重复步骤第3-8；\n\n而以上，则是浏览器的Event Loop（事件循环）\n\n归纳重点：\n\n1. 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微队列中的任务；\n2. 微任务队列中的任务会被一次取出执行，直到microtask queue为空；\n\n## NodeJS中的Event Loop\n\n### libuv \n\n![]( https://user-gold-cdn.xitu.io/2018/9/5/165a8667e0f09fa2?imageslim )\n\n#### 执行宏队列的回调任务有6个阶段（按顺序）\n\n1. timer阶段：执行`setTimeout` 和 `setInterval` 预定的`callbacks`；\n2. I/Ocallbacks阶段：执行除了close事件的callbacks、被timers设定的callbacks、`setImmediate()`设定的callbacks之外的callbacks；\n3. idle，prepare阶段：仅node内部使用；\n4. poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里；\n5. check阶段：执行`setInmmediate()`设定的callbacks；\n6. close callbacks阶段：执行`sockets.on('close',...)`的callbacks\n\n#### 4个主要宏队列（按顺序）\n\n> 浏览器中只有一个宏队列。NodeJS中不同的macrotask会被放置在不同的宏队列中。\n\n1. Timers Queue\n2. I/O  Callbacks Queue\n3. Check Queue\n4. Close Callbacks Queue\n\n#### 2个主要微队列（按顺序）\n\n> 浏览器中只有一个微队列。NodeJS中不同microtask会被放置在不同的微队列中\n\n1. Next Tick Queue ：放置process.nextTick(callback)的回调任务\n2. Other Micro Queue：放置其他microtask，比如Promise\n\n### Event Loop过程\n\n1. 执行全局脚本的同步代码；\n2. 执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务；\n3. 开始执行macrotask宏任务，共6个阶段，从第一阶段开始执行相应的每一个阶段的macrotask中的所有任务。**是执行每个阶段的所有macrotask任务执行完毕后，再开始 step 2**；\n4. Timer Queue --> step 2 --> I/O Queue --> step 2 --> Check Queue --> step 2 --> Close Callback Queue --> step 2 --> Timers Queue ......\n\n\n\n\n\n\n\n","source":"_posts/自定义Promise/宏任务和微任务.md","raw":"## Event Loop是什么\n\n> event loop 是一个**执行模型**，在不同的地方有不同的实现。浏览器和NodeJs基于不同的技术实现了各自的Event Loop\n\n- 浏览器的Event Loop是在[html5的规范](https://www.w3.org/TR/html5/webappapis.html#event-loops)中明确定义。但只是定义了浏览器中Event Loop的模型，具体实现留给了浏览器厂商\n\n- NodeJS的Event Loop是基于libuv实现的。可以参考Node的[官方文档](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)以及libuv的[官方文档](http://docs.libuv.org/en/v1.x/design.html)。并且libuv对Event Loop做出了实现。\n\n\n\n## 宏队列和微队列\n\n**宏队列-macrotask，也叫tasks**。一些异步任务的回调回依次进入macro task queue，等待后续被调用。这些异步任务包括：\n\n- setTimeout\n- setInterval\n- setImmediate(Node独有)\n- requestAnimationFrame(浏览器独有)\n- I/O\n- UI rendering(浏览器独有)\n\n**微队列-microtask，也叫jobs**。另一些异步任务的回调回依次进入micro task queue，等待后续被调用，这些异步任务包括：\n\n- process.nextTick(Node独有)\n\n- Promise\n\n- Object.observe\n\n- MutationObserver\n\n  \n\n## 浏览器的Event Loop\n\n补充图\n\n执行JavaScrept代码的具体流程：\n\n1. 执行全局脚本同步代码，这些同步代码有一些事同步语句，有一些是异步语句（比如setTimeout）；\n2. 全局脚本代码执行完毕后，调用栈Stack会清空；\n3. 从任务队列中取出可执行任务，也就是微队列和宏队列，<u>优先微队列</u>；\n4. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue 长度-1\n5. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推重复，直到microtask queue中的所有任务都执行完毕。如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\n6. microtask queue 中所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n7. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n8. 执行完毕后，调用栈Stack为空；\n9. 重复步骤第3-8；\n\n而以上，则是浏览器的Event Loop（事件循环）\n\n归纳重点：\n\n1. 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微队列中的任务；\n2. 微任务队列中的任务会被一次取出执行，直到microtask queue为空；\n\n## NodeJS中的Event Loop\n\n### libuv \n\n![]( https://user-gold-cdn.xitu.io/2018/9/5/165a8667e0f09fa2?imageslim )\n\n#### 执行宏队列的回调任务有6个阶段（按顺序）\n\n1. timer阶段：执行`setTimeout` 和 `setInterval` 预定的`callbacks`；\n2. I/Ocallbacks阶段：执行除了close事件的callbacks、被timers设定的callbacks、`setImmediate()`设定的callbacks之外的callbacks；\n3. idle，prepare阶段：仅node内部使用；\n4. poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里；\n5. check阶段：执行`setInmmediate()`设定的callbacks；\n6. close callbacks阶段：执行`sockets.on('close',...)`的callbacks\n\n#### 4个主要宏队列（按顺序）\n\n> 浏览器中只有一个宏队列。NodeJS中不同的macrotask会被放置在不同的宏队列中。\n\n1. Timers Queue\n2. I/O  Callbacks Queue\n3. Check Queue\n4. Close Callbacks Queue\n\n#### 2个主要微队列（按顺序）\n\n> 浏览器中只有一个微队列。NodeJS中不同microtask会被放置在不同的微队列中\n\n1. Next Tick Queue ：放置process.nextTick(callback)的回调任务\n2. Other Micro Queue：放置其他microtask，比如Promise\n\n### Event Loop过程\n\n1. 执行全局脚本的同步代码；\n2. 执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务；\n3. 开始执行macrotask宏任务，共6个阶段，从第一阶段开始执行相应的每一个阶段的macrotask中的所有任务。**是执行每个阶段的所有macrotask任务执行完毕后，再开始 step 2**；\n4. Timer Queue --> step 2 --> I/O Queue --> step 2 --> Check Queue --> step 2 --> Close Callback Queue --> step 2 --> Timers Queue ......\n\n\n\n\n\n\n\n","slug":"自定义Promise/宏任务和微任务","published":1,"date":"2020-06-25T03:10:24.452Z","updated":"2020-06-25T03:14:29.800Z","title":"自定义Promise/宏任务和微任务","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wo8000r3ns6cz78emsg","content":"<h2 id=\"Event-Loop是什么\"><a href=\"#Event-Loop是什么\" class=\"headerlink\" title=\"Event Loop是什么\"></a>Event Loop是什么</h2><blockquote>\n<p>event loop 是一个<strong>执行模型</strong>，在不同的地方有不同的实现。浏览器和NodeJs基于不同的技术实现了各自的Event Loop</p>\n</blockquote>\n<ul>\n<li><p>浏览器的Event Loop是在<a href=\"https://www.w3.org/TR/html5/webappapis.html#event-loops\" target=\"_blank\" rel=\"noopener\">html5的规范</a>中明确定义。但只是定义了浏览器中Event Loop的模型，具体实现留给了浏览器厂商</p>\n</li>\n<li><p>NodeJS的Event Loop是基于libuv实现的。可以参考Node的<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">官方文档</a>以及libuv的<a href=\"http://docs.libuv.org/en/v1.x/design.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>。并且libuv对Event Loop做出了实现。</p>\n</li>\n</ul>\n<h2 id=\"宏队列和微队列\"><a href=\"#宏队列和微队列\" class=\"headerlink\" title=\"宏队列和微队列\"></a>宏队列和微队列</h2><p><strong>宏队列-macrotask，也叫tasks</strong>。一些异步任务的回调回依次进入macro task queue，等待后续被调用。这些异步任务包括：</p>\n<ul>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate(Node独有)</li>\n<li>requestAnimationFrame(浏览器独有)</li>\n<li>I/O</li>\n<li>UI rendering(浏览器独有)</li>\n</ul>\n<p><strong>微队列-microtask，也叫jobs</strong>。另一些异步任务的回调回依次进入micro task queue，等待后续被调用，这些异步任务包括：</p>\n<ul>\n<li><p>process.nextTick(Node独有)</p>\n</li>\n<li><p>Promise</p>\n</li>\n<li><p>Object.observe</p>\n</li>\n<li><p>MutationObserver</p>\n</li>\n</ul>\n<h2 id=\"浏览器的Event-Loop\"><a href=\"#浏览器的Event-Loop\" class=\"headerlink\" title=\"浏览器的Event Loop\"></a>浏览器的Event Loop</h2><p>补充图</p>\n<p>执行JavaScrept代码的具体流程：</p>\n<ol>\n<li>执行全局脚本同步代码，这些同步代码有一些事同步语句，有一些是异步语句（比如setTimeout）；</li>\n<li>全局脚本代码执行完毕后，调用栈Stack会清空；</li>\n<li>从任务队列中取出可执行任务，也就是微队列和宏队列，<u>优先微队列</u>；</li>\n<li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue 长度-1</li>\n<li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推重复，直到microtask queue中的所有任务都执行完毕。如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</li>\n<li>microtask queue 中所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li>\n<li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li>\n<li>执行完毕后，调用栈Stack为空；</li>\n<li>重复步骤第3-8；</li>\n</ol>\n<p>而以上，则是浏览器的Event Loop（事件循环）</p>\n<p>归纳重点：</p>\n<ol>\n<li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微队列中的任务；</li>\n<li>微任务队列中的任务会被一次取出执行，直到microtask queue为空；</li>\n</ol>\n<h2 id=\"NodeJS中的Event-Loop\"><a href=\"#NodeJS中的Event-Loop\" class=\"headerlink\" title=\"NodeJS中的Event Loop\"></a>NodeJS中的Event Loop</h2><h3 id=\"libuv\"><a href=\"#libuv\" class=\"headerlink\" title=\"libuv\"></a>libuv</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/9/5/165a8667e0f09fa2?imageslim\" alt=\"\"></p>\n<h4 id=\"执行宏队列的回调任务有6个阶段（按顺序）\"><a href=\"#执行宏队列的回调任务有6个阶段（按顺序）\" class=\"headerlink\" title=\"执行宏队列的回调任务有6个阶段（按顺序）\"></a>执行宏队列的回调任务有6个阶段（按顺序）</h4><ol>\n<li>timer阶段：执行<code>setTimeout</code> 和 <code>setInterval</code> 预定的<code>callbacks</code>；</li>\n<li>I/Ocallbacks阶段：执行除了close事件的callbacks、被timers设定的callbacks、<code>setImmediate()</code>设定的callbacks之外的callbacks；</li>\n<li>idle，prepare阶段：仅node内部使用；</li>\n<li>poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里；</li>\n<li>check阶段：执行<code>setInmmediate()</code>设定的callbacks；</li>\n<li>close callbacks阶段：执行<code>sockets.on(&#39;close&#39;,...)</code>的callbacks</li>\n</ol>\n<h4 id=\"4个主要宏队列（按顺序）\"><a href=\"#4个主要宏队列（按顺序）\" class=\"headerlink\" title=\"4个主要宏队列（按顺序）\"></a>4个主要宏队列（按顺序）</h4><blockquote>\n<p>浏览器中只有一个宏队列。NodeJS中不同的macrotask会被放置在不同的宏队列中。</p>\n</blockquote>\n<ol>\n<li>Timers Queue</li>\n<li>I/O  Callbacks Queue</li>\n<li>Check Queue</li>\n<li>Close Callbacks Queue</li>\n</ol>\n<h4 id=\"2个主要微队列（按顺序）\"><a href=\"#2个主要微队列（按顺序）\" class=\"headerlink\" title=\"2个主要微队列（按顺序）\"></a>2个主要微队列（按顺序）</h4><blockquote>\n<p>浏览器中只有一个微队列。NodeJS中不同microtask会被放置在不同的微队列中</p>\n</blockquote>\n<ol>\n<li>Next Tick Queue ：放置process.nextTick(callback)的回调任务</li>\n<li>Other Micro Queue：放置其他microtask，比如Promise</li>\n</ol>\n<h3 id=\"Event-Loop过程\"><a href=\"#Event-Loop过程\" class=\"headerlink\" title=\"Event Loop过程\"></a>Event Loop过程</h3><ol>\n<li>执行全局脚本的同步代码；</li>\n<li>执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务；</li>\n<li>开始执行macrotask宏任务，共6个阶段，从第一阶段开始执行相应的每一个阶段的macrotask中的所有任务。<strong>是执行每个阶段的所有macrotask任务执行完毕后，再开始 step 2</strong>；</li>\n<li>Timer Queue –&gt; step 2 –&gt; I/O Queue –&gt; step 2 –&gt; Check Queue –&gt; step 2 –&gt; Close Callback Queue –&gt; step 2 –&gt; Timers Queue ……</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Event-Loop是什么\"><a href=\"#Event-Loop是什么\" class=\"headerlink\" title=\"Event Loop是什么\"></a>Event Loop是什么</h2><blockquote>\n<p>event loop 是一个<strong>执行模型</strong>，在不同的地方有不同的实现。浏览器和NodeJs基于不同的技术实现了各自的Event Loop</p>\n</blockquote>\n<ul>\n<li><p>浏览器的Event Loop是在<a href=\"https://www.w3.org/TR/html5/webappapis.html#event-loops\" target=\"_blank\" rel=\"noopener\">html5的规范</a>中明确定义。但只是定义了浏览器中Event Loop的模型，具体实现留给了浏览器厂商</p>\n</li>\n<li><p>NodeJS的Event Loop是基于libuv实现的。可以参考Node的<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noopener\">官方文档</a>以及libuv的<a href=\"http://docs.libuv.org/en/v1.x/design.html\" target=\"_blank\" rel=\"noopener\">官方文档</a>。并且libuv对Event Loop做出了实现。</p>\n</li>\n</ul>\n<h2 id=\"宏队列和微队列\"><a href=\"#宏队列和微队列\" class=\"headerlink\" title=\"宏队列和微队列\"></a>宏队列和微队列</h2><p><strong>宏队列-macrotask，也叫tasks</strong>。一些异步任务的回调回依次进入macro task queue，等待后续被调用。这些异步任务包括：</p>\n<ul>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate(Node独有)</li>\n<li>requestAnimationFrame(浏览器独有)</li>\n<li>I/O</li>\n<li>UI rendering(浏览器独有)</li>\n</ul>\n<p><strong>微队列-microtask，也叫jobs</strong>。另一些异步任务的回调回依次进入micro task queue，等待后续被调用，这些异步任务包括：</p>\n<ul>\n<li><p>process.nextTick(Node独有)</p>\n</li>\n<li><p>Promise</p>\n</li>\n<li><p>Object.observe</p>\n</li>\n<li><p>MutationObserver</p>\n</li>\n</ul>\n<h2 id=\"浏览器的Event-Loop\"><a href=\"#浏览器的Event-Loop\" class=\"headerlink\" title=\"浏览器的Event Loop\"></a>浏览器的Event Loop</h2><p>补充图</p>\n<p>执行JavaScrept代码的具体流程：</p>\n<ol>\n<li>执行全局脚本同步代码，这些同步代码有一些事同步语句，有一些是异步语句（比如setTimeout）；</li>\n<li>全局脚本代码执行完毕后，调用栈Stack会清空；</li>\n<li>从任务队列中取出可执行任务，也就是微队列和宏队列，<u>优先微队列</u>；</li>\n<li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue 长度-1</li>\n<li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推重复，直到microtask queue中的所有任务都执行完毕。如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</li>\n<li>microtask queue 中所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li>\n<li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li>\n<li>执行完毕后，调用栈Stack为空；</li>\n<li>重复步骤第3-8；</li>\n</ol>\n<p>而以上，则是浏览器的Event Loop（事件循环）</p>\n<p>归纳重点：</p>\n<ol>\n<li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微队列中的任务；</li>\n<li>微任务队列中的任务会被一次取出执行，直到microtask queue为空；</li>\n</ol>\n<h2 id=\"NodeJS中的Event-Loop\"><a href=\"#NodeJS中的Event-Loop\" class=\"headerlink\" title=\"NodeJS中的Event Loop\"></a>NodeJS中的Event Loop</h2><h3 id=\"libuv\"><a href=\"#libuv\" class=\"headerlink\" title=\"libuv\"></a>libuv</h3><p><img src=\"https://user-gold-cdn.xitu.io/2018/9/5/165a8667e0f09fa2?imageslim\" alt=\"\"></p>\n<h4 id=\"执行宏队列的回调任务有6个阶段（按顺序）\"><a href=\"#执行宏队列的回调任务有6个阶段（按顺序）\" class=\"headerlink\" title=\"执行宏队列的回调任务有6个阶段（按顺序）\"></a>执行宏队列的回调任务有6个阶段（按顺序）</h4><ol>\n<li>timer阶段：执行<code>setTimeout</code> 和 <code>setInterval</code> 预定的<code>callbacks</code>；</li>\n<li>I/Ocallbacks阶段：执行除了close事件的callbacks、被timers设定的callbacks、<code>setImmediate()</code>设定的callbacks之外的callbacks；</li>\n<li>idle，prepare阶段：仅node内部使用；</li>\n<li>poll阶段：获取新的I/O事件，适当的条件下node将阻塞在这里；</li>\n<li>check阶段：执行<code>setInmmediate()</code>设定的callbacks；</li>\n<li>close callbacks阶段：执行<code>sockets.on(&#39;close&#39;,...)</code>的callbacks</li>\n</ol>\n<h4 id=\"4个主要宏队列（按顺序）\"><a href=\"#4个主要宏队列（按顺序）\" class=\"headerlink\" title=\"4个主要宏队列（按顺序）\"></a>4个主要宏队列（按顺序）</h4><blockquote>\n<p>浏览器中只有一个宏队列。NodeJS中不同的macrotask会被放置在不同的宏队列中。</p>\n</blockquote>\n<ol>\n<li>Timers Queue</li>\n<li>I/O  Callbacks Queue</li>\n<li>Check Queue</li>\n<li>Close Callbacks Queue</li>\n</ol>\n<h4 id=\"2个主要微队列（按顺序）\"><a href=\"#2个主要微队列（按顺序）\" class=\"headerlink\" title=\"2个主要微队列（按顺序）\"></a>2个主要微队列（按顺序）</h4><blockquote>\n<p>浏览器中只有一个微队列。NodeJS中不同microtask会被放置在不同的微队列中</p>\n</blockquote>\n<ol>\n<li>Next Tick Queue ：放置process.nextTick(callback)的回调任务</li>\n<li>Other Micro Queue：放置其他microtask，比如Promise</li>\n</ol>\n<h3 id=\"Event-Loop过程\"><a href=\"#Event-Loop过程\" class=\"headerlink\" title=\"Event Loop过程\"></a>Event Loop过程</h3><ol>\n<li>执行全局脚本的同步代码；</li>\n<li>执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务；</li>\n<li>开始执行macrotask宏任务，共6个阶段，从第一阶段开始执行相应的每一个阶段的macrotask中的所有任务。<strong>是执行每个阶段的所有macrotask任务执行完毕后，再开始 step 2</strong>；</li>\n<li>Timer Queue –&gt; step 2 –&gt; I/O Queue –&gt; step 2 –&gt; Check Queue –&gt; step 2 –&gt; Close Callback Queue –&gt; step 2 –&gt; Timers Queue ……</li>\n</ol>\n"},{"_content":"## 为什么要HTTP缓存？-[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n\n客户端发送HTTP请求到服务端响应成功，中间需要建立TCP连接，三次握手，再是通信数据，再是四次挥手结束响应。这个过程需要的多次的往返通信，拖延了浏览器处理数据的时间，增加了访问者和服务器的流量成本，请求或数据过多时也降低了浏览体验。\n\n而缓存直白一些说\n\n- 可以节省用户的流量\n- 减少服务器资源损耗\n\n那如何缓存呢？\n\n## 如何缓存-缓存控制\n\n这里讲讲如何从HTTP头部字段来缓存，主要`Expires` 和 `Cache-Control`两个头部字段。\n\nExpires是HTTP1.0的时候存在的字段，Cache-Control 则是HTTP/1.1定义。都是请求响应通用头部，但一些指令值有不一样。\n\n- Expires:缓存过期时间\n\n  ``` http\n  Expires:<http-date>\n  ```\n\n- Cache-Control [有多项值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)，这里主要说明一些常见的指令值\n\n  - no-store & no-cache\n\n  - public & private\n\n  - max-age\n\n    \n\n### Expires (HTTP/1.0 +)\n\n服务器在HTTP 响应头部添加`Expires:<http-date>`字段，对象的字段值是缓存过期时间，如：\n\n``` HTTP\nExpires: Thu Jun 11 2020 15:35:38 GMT+0800 \n```\n\n浏览器在解析到HTTP响应头中的`Expires`时，会先将该资源缓存起来。等到下一次再次访问这个资源的时候，浏览器会先检查缓存：<u>*当前时间*是否超过`Expires`</u>，如果没有超过，浏览器不会发送该资源的请求，直接从缓存中读取资源（如图：form disk cache）。\n\n![image-20200611155640808](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611155640808.png)\n\n但有个小问题：浏览器所在的设备是用户设备，这个当前时间是不可靠的。如果用户设置电脑的时间是3000年，那么浏览器得到的‘当前时间’则是3000，岂不是表示缓存永远过期了，那么这个缓存是无意义的？\n\n\n\n### Cache-Control（HTTP/1.1+）\n\nHTTP/1.1 提供了一个<u>请求和响应的通用消息头字段</u> `Cache-Control` ,`Cache-Control`可以解决使用 `Expires`时由用户自动修改本地时间导致的缓存失效问题，并提供了更灵活的缓存机制。\n\nCache-Control提供了[多项属性值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)，来达到灵活控制缓存。\n\n### max-age=<seconds>\n\n而其中的`Cache-Control: max-age=<seconds>`可以解决上述的Expires问题。给响应头设置`Cache-Control: max-age=30` 表示服务器告诉浏览器该资源在30秒之后过期。\n\n如果浏览器在30秒内再次请求该资源，则服务器不会返回内容，并且浏览器读取的是缓存。\n\n![image-20200611172530382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172530382.png)\n\n如果浏览器在30秒后再词请求资源，则会使用服务器返回的内容，并将新的内容缓存。\n\n![image-20200611172742569](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172742569.png)\n\n**当`Cache-Control: max-age=<seconds>`和`Expires`同时设置时，以`Cache-Control: max-age=<seconds>`为准**。[参考](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3)\n\n\n\n### public & private\n\npublic，响应可以被任何对象（发起请求的客户端，代理服务器等）缓存。即使是不可缓存的内容（没有设置max-age、expires等，或者是post请求）。\n\nprivate， 响应只能被单个用户缓存，不能作为共享缓存。私有缓存可以响应内容，比如用户发送请求的浏览器。\n\n\n\n### no-store & no-cache\n\nno-store，没有缓存。\n\n禁止浏览器缓存任何请求及响应的内容。每次客户端请求资源时，都会向服务器发送请求，并下载完整服务器响应的内容。\n\n``` http\nCache-Control: no-store\n```\n\nno-cache，缓存但重新验证。\n\n表示必须先与服务器验证资源是否过期，更具响应结果来决定是否用缓存。若过期返回新的内容，未过期返回 HTTP code 304，告诉浏览器为过期使用本地缓存，避免重新下载资源。\n\n``` http\nCache-Control: no-cache\n```\n\n**强调一点：no-store表示永远不用缓存，no-cache 每次先检查再看是否使用缓存**\n\n<u>那如何验证缓存是否过期呢？</u>\n\n\n\n## 缓存过期了-验证缓存\n\n通过HTTP头部验证缓存有两种方式：\n\n- 响应头部`Last-Modified` & 请求头部 `If-Modified-Since`\n- 响应头部`Etag` & 请求头部`If-None-Match`\n\n\n\n#### Last-Modified & If-Modified-Since|If-Unmodified-Since\n\n##### 如何起作用\n\n我们先看下组合 `Last-Modified & If-Modified-Since`。[If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)与`If-Modified-Since`用法一样，意义相反，所以这里只说`If-Modified-Since`\n\n该组合验证请求资源是否编辑过，如果编辑过则响应304，未编辑则是200。\n\n##### If-Modified-Since是什么\n\n请求头部 [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)，资源最后一次修改时间。需要注意的是`If-Modified-Since`只可以用在 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 或 [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求中\n\n```http\nIf-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n```\n\n##### Last-Modified是什么\n\n响应头部[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)，表示资源的最后一次修改时间\n\n```http\nLast-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n```\n\n**第一次请求响应**\n\nResponse\n\n``` http\ncache-control: max-age=3600\ncontent-type: image/webp\ndate: Tue, 16 Jun 2020 02:38:20 GMT\nexpires: Tue, 16 Jun 2020 03:38:20 GMT\nlast-modified: Tue, 17 Mar 2020 17:03:38 GMT\n```\n\n**第二次请求响应**\n\n请求体中会带有`If-modified-since`  询问服务器该资源是否有编辑\n\nRequest\n\n``` http\nif-modified-since:Tue, 17 Mar 2020 18:31:38 GMT\n```\n\nResponse\n\n```http\nStatus Code: 304 Not Modified\n...\nlast-modified: Tue, 17 Mar 2020 17:03:38 GMT \n```\n\nLast-Modified & If-Modified-Since询问的是资源有没有编辑，如果文件直至打开，键入几个字再删除这几个字，再保存呢，这也是编辑了，但其实内容是无变化的。问题：\n\n<u>如何知道服务器文件内容没有改动？</u>\n\n#### Etag & If-None-Match\n\n##### Etag是什么？\n\nEtag是HTTP响应头的资源的特定版本的标识符。当设置了该头部：\n\n- 如果内容没有改变，Web服务器不需要发送完整的内容\n- 如果内容有修改，Etag则会更新，可以理解为文件的MD5值\n\n##### Etag语法\n\n```\nETag: W/\"<etag_value>\"\nETag: \"<etag_value>\"\n```\n\n- W/  \n\n  可选表示大小写敏感\n\n- <etag_value> \n\n  没有明确指定生成ETag值的方法，可HASH，可MD5 ，可自定义的版本\n\nEtag只是规定了响应的内容唯一标识，而需要真正起到作用，还需要与请求头部 `If-None-Match`配合使用\n\n##### If-None-Match是什么\n\nIf-None-Match是一个条件式请求头部。\n\n- 对于 GET[`GET`](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 和 [`HEAD`](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求方法：\n  - 当服务器没有任何的资源Etag与请求头Etag值相同时候，返回所请求的资源，状态码为200\n  - 而验证失败时，服务器返回304 Not Modified状态码，并且同时生成对应的200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。\n- 对于其他方法：\n  - 当服务器没有任何资源的Etag属性值与请求的Etag属性值相匹配时，才会对请求做出相应处理。\n  - 验证失败时，响应状态码` 412 Precondition Failed`（先决条件失败）表示客户端错误\n\n##### If-None-Match语法\n\n```\nIf-None-Match: <etag_value>\nIf-None-Match: <etag_value>, <etag_value>, …\nIf-None-Match: *\n```\n\n- <etag_value>\n\n  形式是采用双引号括起来的由 ASCII 字符串（如\"675af34563dc-tr34\"）\n\n- *\n\n  可以代表任意资源，只在用在资源上传时，一般用PUT方法，来·检测拥有相同识别ID的资源是否已经上传过了\n\n  \n\n#### If-Modified-Since & If-None-Match \n\n**<u>当与If-Modified-Since一同使用的时候，If-None-Match 优先级更高</u>**\n\n\n\n#### 小总结：\n\n> no-cache 是开启缓存校验的钥匙\n\n设置了过期时间而没有设置no-cache ，在max-age 有效期内，浏览器不会发送该资源请求，直接获取本地缓存\n\n若设置了过期时间，且设置了no-cache ,会发送请求，并做缓存校验","source":"_posts/HTTP/HTTP-缓存.md","raw":"## 为什么要HTTP缓存？-[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n\n客户端发送HTTP请求到服务端响应成功，中间需要建立TCP连接，三次握手，再是通信数据，再是四次挥手结束响应。这个过程需要的多次的往返通信，拖延了浏览器处理数据的时间，增加了访问者和服务器的流量成本，请求或数据过多时也降低了浏览体验。\n\n而缓存直白一些说\n\n- 可以节省用户的流量\n- 减少服务器资源损耗\n\n那如何缓存呢？\n\n## 如何缓存-缓存控制\n\n这里讲讲如何从HTTP头部字段来缓存，主要`Expires` 和 `Cache-Control`两个头部字段。\n\nExpires是HTTP1.0的时候存在的字段，Cache-Control 则是HTTP/1.1定义。都是请求响应通用头部，但一些指令值有不一样。\n\n- Expires:缓存过期时间\n\n  ``` http\n  Expires:<http-date>\n  ```\n\n- Cache-Control [有多项值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)，这里主要说明一些常见的指令值\n\n  - no-store & no-cache\n\n  - public & private\n\n  - max-age\n\n    \n\n### Expires (HTTP/1.0 +)\n\n服务器在HTTP 响应头部添加`Expires:<http-date>`字段，对象的字段值是缓存过期时间，如：\n\n``` HTTP\nExpires: Thu Jun 11 2020 15:35:38 GMT+0800 \n```\n\n浏览器在解析到HTTP响应头中的`Expires`时，会先将该资源缓存起来。等到下一次再次访问这个资源的时候，浏览器会先检查缓存：<u>*当前时间*是否超过`Expires`</u>，如果没有超过，浏览器不会发送该资源的请求，直接从缓存中读取资源（如图：form disk cache）。\n\n![image-20200611155640808](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611155640808.png)\n\n但有个小问题：浏览器所在的设备是用户设备，这个当前时间是不可靠的。如果用户设置电脑的时间是3000年，那么浏览器得到的‘当前时间’则是3000，岂不是表示缓存永远过期了，那么这个缓存是无意义的？\n\n\n\n### Cache-Control（HTTP/1.1+）\n\nHTTP/1.1 提供了一个<u>请求和响应的通用消息头字段</u> `Cache-Control` ,`Cache-Control`可以解决使用 `Expires`时由用户自动修改本地时间导致的缓存失效问题，并提供了更灵活的缓存机制。\n\nCache-Control提供了[多项属性值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)，来达到灵活控制缓存。\n\n### max-age=<seconds>\n\n而其中的`Cache-Control: max-age=<seconds>`可以解决上述的Expires问题。给响应头设置`Cache-Control: max-age=30` 表示服务器告诉浏览器该资源在30秒之后过期。\n\n如果浏览器在30秒内再次请求该资源，则服务器不会返回内容，并且浏览器读取的是缓存。\n\n![image-20200611172530382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172530382.png)\n\n如果浏览器在30秒后再词请求资源，则会使用服务器返回的内容，并将新的内容缓存。\n\n![image-20200611172742569](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172742569.png)\n\n**当`Cache-Control: max-age=<seconds>`和`Expires`同时设置时，以`Cache-Control: max-age=<seconds>`为准**。[参考](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3)\n\n\n\n### public & private\n\npublic，响应可以被任何对象（发起请求的客户端，代理服务器等）缓存。即使是不可缓存的内容（没有设置max-age、expires等，或者是post请求）。\n\nprivate， 响应只能被单个用户缓存，不能作为共享缓存。私有缓存可以响应内容，比如用户发送请求的浏览器。\n\n\n\n### no-store & no-cache\n\nno-store，没有缓存。\n\n禁止浏览器缓存任何请求及响应的内容。每次客户端请求资源时，都会向服务器发送请求，并下载完整服务器响应的内容。\n\n``` http\nCache-Control: no-store\n```\n\nno-cache，缓存但重新验证。\n\n表示必须先与服务器验证资源是否过期，更具响应结果来决定是否用缓存。若过期返回新的内容，未过期返回 HTTP code 304，告诉浏览器为过期使用本地缓存，避免重新下载资源。\n\n``` http\nCache-Control: no-cache\n```\n\n**强调一点：no-store表示永远不用缓存，no-cache 每次先检查再看是否使用缓存**\n\n<u>那如何验证缓存是否过期呢？</u>\n\n\n\n## 缓存过期了-验证缓存\n\n通过HTTP头部验证缓存有两种方式：\n\n- 响应头部`Last-Modified` & 请求头部 `If-Modified-Since`\n- 响应头部`Etag` & 请求头部`If-None-Match`\n\n\n\n#### Last-Modified & If-Modified-Since|If-Unmodified-Since\n\n##### 如何起作用\n\n我们先看下组合 `Last-Modified & If-Modified-Since`。[If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)与`If-Modified-Since`用法一样，意义相反，所以这里只说`If-Modified-Since`\n\n该组合验证请求资源是否编辑过，如果编辑过则响应304，未编辑则是200。\n\n##### If-Modified-Since是什么\n\n请求头部 [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)，资源最后一次修改时间。需要注意的是`If-Modified-Since`只可以用在 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 或 [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求中\n\n```http\nIf-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n```\n\n##### Last-Modified是什么\n\n响应头部[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)，表示资源的最后一次修改时间\n\n```http\nLast-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n```\n\n**第一次请求响应**\n\nResponse\n\n``` http\ncache-control: max-age=3600\ncontent-type: image/webp\ndate: Tue, 16 Jun 2020 02:38:20 GMT\nexpires: Tue, 16 Jun 2020 03:38:20 GMT\nlast-modified: Tue, 17 Mar 2020 17:03:38 GMT\n```\n\n**第二次请求响应**\n\n请求体中会带有`If-modified-since`  询问服务器该资源是否有编辑\n\nRequest\n\n``` http\nif-modified-since:Tue, 17 Mar 2020 18:31:38 GMT\n```\n\nResponse\n\n```http\nStatus Code: 304 Not Modified\n...\nlast-modified: Tue, 17 Mar 2020 17:03:38 GMT \n```\n\nLast-Modified & If-Modified-Since询问的是资源有没有编辑，如果文件直至打开，键入几个字再删除这几个字，再保存呢，这也是编辑了，但其实内容是无变化的。问题：\n\n<u>如何知道服务器文件内容没有改动？</u>\n\n#### Etag & If-None-Match\n\n##### Etag是什么？\n\nEtag是HTTP响应头的资源的特定版本的标识符。当设置了该头部：\n\n- 如果内容没有改变，Web服务器不需要发送完整的内容\n- 如果内容有修改，Etag则会更新，可以理解为文件的MD5值\n\n##### Etag语法\n\n```\nETag: W/\"<etag_value>\"\nETag: \"<etag_value>\"\n```\n\n- W/  \n\n  可选表示大小写敏感\n\n- <etag_value> \n\n  没有明确指定生成ETag值的方法，可HASH，可MD5 ，可自定义的版本\n\nEtag只是规定了响应的内容唯一标识，而需要真正起到作用，还需要与请求头部 `If-None-Match`配合使用\n\n##### If-None-Match是什么\n\nIf-None-Match是一个条件式请求头部。\n\n- 对于 GET[`GET`](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 和 [`HEAD`](https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 请求方法：\n  - 当服务器没有任何的资源Etag与请求头Etag值相同时候，返回所请求的资源，状态码为200\n  - 而验证失败时，服务器返回304 Not Modified状态码，并且同时生成对应的200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。\n- 对于其他方法：\n  - 当服务器没有任何资源的Etag属性值与请求的Etag属性值相匹配时，才会对请求做出相应处理。\n  - 验证失败时，响应状态码` 412 Precondition Failed`（先决条件失败）表示客户端错误\n\n##### If-None-Match语法\n\n```\nIf-None-Match: <etag_value>\nIf-None-Match: <etag_value>, <etag_value>, …\nIf-None-Match: *\n```\n\n- <etag_value>\n\n  形式是采用双引号括起来的由 ASCII 字符串（如\"675af34563dc-tr34\"）\n\n- *\n\n  可以代表任意资源，只在用在资源上传时，一般用PUT方法，来·检测拥有相同识别ID的资源是否已经上传过了\n\n  \n\n#### If-Modified-Since & If-None-Match \n\n**<u>当与If-Modified-Since一同使用的时候，If-None-Match 优先级更高</u>**\n\n\n\n#### 小总结：\n\n> no-cache 是开启缓存校验的钥匙\n\n设置了过期时间而没有设置no-cache ，在max-age 有效期内，浏览器不会发送该资源请求，直接获取本地缓存\n\n若设置了过期时间，且设置了no-cache ,会发送请求，并做缓存校验","slug":"HTTP/HTTP-缓存","published":1,"date":"2020-06-25T03:10:24.404Z","updated":"2020-06-25T03:10:24.406Z","title":"HTTP/HTTP-缓存","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3woe000s3ns66exxfzpi","content":"<h2 id=\"为什么要HTTP缓存？-MDN\"><a href=\"#为什么要HTTP缓存？-MDN\" class=\"headerlink\" title=\"为什么要HTTP缓存？-MDN\"></a>为什么要HTTP缓存？-<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN</a></h2><p>客户端发送HTTP请求到服务端响应成功，中间需要建立TCP连接，三次握手，再是通信数据，再是四次挥手结束响应。这个过程需要的多次的往返通信，拖延了浏览器处理数据的时间，增加了访问者和服务器的流量成本，请求或数据过多时也降低了浏览体验。</p>\n<p>而缓存直白一些说</p>\n<ul>\n<li>可以节省用户的流量</li>\n<li>减少服务器资源损耗</li>\n</ul>\n<p>那如何缓存呢？</p>\n<h2 id=\"如何缓存-缓存控制\"><a href=\"#如何缓存-缓存控制\" class=\"headerlink\" title=\"如何缓存-缓存控制\"></a>如何缓存-缓存控制</h2><p>这里讲讲如何从HTTP头部字段来缓存，主要<code>Expires</code> 和 <code>Cache-Control</code>两个头部字段。</p>\n<p>Expires是HTTP1.0的时候存在的字段，Cache-Control 则是HTTP/1.1定义。都是请求响应通用头部，但一些指令值有不一样。</p>\n<ul>\n<li><p>Expires:缓存过期时间</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Expires:&lt;http-date&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cache-Control <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">有多项值</a>，这里主要说明一些常见的指令值</p>\n<ul>\n<li><p>no-store &amp; no-cache</p>\n</li>\n<li><p>public &amp; private</p>\n</li>\n<li><p>max-age</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Expires-HTTP-1-0\"><a href=\"#Expires-HTTP-1-0\" class=\"headerlink\" title=\"Expires (HTTP/1.0 +)\"></a>Expires (HTTP/1.0 +)</h3><p>服务器在HTTP 响应头部添加<code>Expires:&lt;http-date&gt;</code>字段，对象的字段值是缓存过期时间，如：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Expires</span>: Thu Jun 11 2020 15:35:38 GMT+0800</span><br></pre></td></tr></table></figure>\n\n<p>浏览器在解析到HTTP响应头中的<code>Expires</code>时，会先将该资源缓存起来。等到下一次再次访问这个资源的时候，浏览器会先检查缓存：<u><em>当前时间</em>是否超过<code>Expires</code></u>，如果没有超过，浏览器不会发送该资源的请求，直接从缓存中读取资源（如图：form disk cache）。</p>\n<p>![image-20200611155640808](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611155640808.png)</p>\n<p>但有个小问题：浏览器所在的设备是用户设备，这个当前时间是不可靠的。如果用户设置电脑的时间是3000年，那么浏览器得到的‘当前时间’则是3000，岂不是表示缓存永远过期了，那么这个缓存是无意义的？</p>\n<h3 id=\"Cache-Control（HTTP-1-1-）\"><a href=\"#Cache-Control（HTTP-1-1-）\" class=\"headerlink\" title=\"Cache-Control（HTTP/1.1+）\"></a>Cache-Control（HTTP/1.1+）</h3><p>HTTP/1.1 提供了一个<u>请求和响应的通用消息头字段</u> <code>Cache-Control</code> ,<code>Cache-Control</code>可以解决使用 <code>Expires</code>时由用户自动修改本地时间导致的缓存失效问题，并提供了更灵活的缓存机制。</p>\n<p>Cache-Control提供了<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">多项属性值</a>，来达到灵活控制缓存。</p>\n<h3 id=\"max-age\"><a href=\"#max-age\" class=\"headerlink\" title=\"max-age=\"></a>max-age=<seconds></h3><p>而其中的<code>Cache-Control: max-age=&lt;seconds&gt;</code>可以解决上述的Expires问题。给响应头设置<code>Cache-Control: max-age=30</code> 表示服务器告诉浏览器该资源在30秒之后过期。</p>\n<p>如果浏览器在30秒内再次请求该资源，则服务器不会返回内容，并且浏览器读取的是缓存。</p>\n<p>![image-20200611172530382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172530382.png)</p>\n<p>如果浏览器在30秒后再词请求资源，则会使用服务器返回的内容，并将新的内容缓存。</p>\n<p>![image-20200611172742569](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172742569.png)</p>\n<p><strong>当<code>Cache-Control: max-age=&lt;seconds&gt;</code>和<code>Expires</code>同时设置时，以<code>Cache-Control: max-age=&lt;seconds&gt;</code>为准</strong>。<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"public-amp-private\"><a href=\"#public-amp-private\" class=\"headerlink\" title=\"public &amp; private\"></a>public &amp; private</h3><p>public，响应可以被任何对象（发起请求的客户端，代理服务器等）缓存。即使是不可缓存的内容（没有设置max-age、expires等，或者是post请求）。</p>\n<p>private， 响应只能被单个用户缓存，不能作为共享缓存。私有缓存可以响应内容，比如用户发送请求的浏览器。</p>\n<h3 id=\"no-store-amp-no-cache\"><a href=\"#no-store-amp-no-cache\" class=\"headerlink\" title=\"no-store &amp; no-cache\"></a>no-store &amp; no-cache</h3><p>no-store，没有缓存。</p>\n<p>禁止浏览器缓存任何请求及响应的内容。每次客户端请求资源时，都会向服务器发送请求，并下载完整服务器响应的内容。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-store</span><br></pre></td></tr></table></figure>\n\n<p>no-cache，缓存但重新验证。</p>\n<p>表示必须先与服务器验证资源是否过期，更具响应结果来决定是否用缓存。若过期返回新的内容，未过期返回 HTTP code 304，告诉浏览器为过期使用本地缓存，避免重新下载资源。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-cache</span><br></pre></td></tr></table></figure>\n\n<p><strong>强调一点：no-store表示永远不用缓存，no-cache 每次先检查再看是否使用缓存</strong></p>\n<p><u>那如何验证缓存是否过期呢？</u></p>\n<h2 id=\"缓存过期了-验证缓存\"><a href=\"#缓存过期了-验证缓存\" class=\"headerlink\" title=\"缓存过期了-验证缓存\"></a>缓存过期了-验证缓存</h2><p>通过HTTP头部验证缓存有两种方式：</p>\n<ul>\n<li>响应头部<code>Last-Modified</code> &amp; 请求头部 <code>If-Modified-Since</code></li>\n<li>响应头部<code>Etag</code> &amp; 请求头部<code>If-None-Match</code></li>\n</ul>\n<h4 id=\"Last-Modified-amp-If-Modified-Since-If-Unmodified-Since\"><a href=\"#Last-Modified-amp-If-Modified-Since-If-Unmodified-Since\" class=\"headerlink\" title=\"Last-Modified &amp; If-Modified-Since|If-Unmodified-Since\"></a>Last-Modified &amp; If-Modified-Since|If-Unmodified-Since</h4><h5 id=\"如何起作用\"><a href=\"#如何起作用\" class=\"headerlink\" title=\"如何起作用\"></a>如何起作用</h5><p>我们先看下组合 <code>Last-Modified &amp; If-Modified-Since</code>。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\" target=\"_blank\" rel=\"noopener\">If-Unmodified-Since</a>与<code>If-Modified-Since</code>用法一样，意义相反，所以这里只说<code>If-Modified-Since</code></p>\n<p>该组合验证请求资源是否编辑过，如果编辑过则响应304，未编辑则是200。</p>\n<h5 id=\"If-Modified-Since是什么\"><a href=\"#If-Modified-Since是什么\" class=\"headerlink\" title=\"If-Modified-Since是什么\"></a>If-Modified-Since是什么</h5><p>请求头部 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">If-Modified-Since</a>，资源最后一次修改时间。需要注意的是<code>If-Modified-Since</code>只可以用在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\" target=\"_blank\" rel=\"noopener\"><code>GET</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\" target=\"_blank\" rel=\"noopener\"><code>HEAD</code></a> 请求中</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">If-Modified-Since</span>: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Last-Modified是什么\"><a href=\"#Last-Modified是什么\" class=\"headerlink\" title=\"Last-Modified是什么\"></a>Last-Modified是什么</h5><p>响应头部<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\" target=\"_blank\" rel=\"noopener\">Last-Modified</a>，表示资源的最后一次修改时间</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>第一次请求响应</strong></p>\n<p>Response</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cache-control</span>: max-age=3600</span><br><span class=\"line\"><span class=\"attribute\">content-type</span>: image/webp</span><br><span class=\"line\"><span class=\"attribute\">date</span>: Tue, 16 Jun 2020 02:38:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">expires</span>: Tue, 16 Jun 2020 03:38:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">last-modified</span>: Tue, 17 Mar 2020 17:03:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二次请求响应</strong></p>\n<p>请求体中会带有<code>If-modified-since</code>  询问服务器该资源是否有编辑</p>\n<p>Request</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if-modified-since:Tue, 17 Mar 2020 18:31:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p>Response</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status Code: 304 Not Modified</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"attribute\">last-modified</span>: Tue, 17 Mar 2020 17:03:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p>Last-Modified &amp; If-Modified-Since询问的是资源有没有编辑，如果文件直至打开，键入几个字再删除这几个字，再保存呢，这也是编辑了，但其实内容是无变化的。问题：</p>\n<p><u>如何知道服务器文件内容没有改动？</u></p>\n<h4 id=\"Etag-amp-If-None-Match\"><a href=\"#Etag-amp-If-None-Match\" class=\"headerlink\" title=\"Etag &amp; If-None-Match\"></a>Etag &amp; If-None-Match</h4><h5 id=\"Etag是什么？\"><a href=\"#Etag是什么？\" class=\"headerlink\" title=\"Etag是什么？\"></a>Etag是什么？</h5><p>Etag是HTTP响应头的资源的特定版本的标识符。当设置了该头部：</p>\n<ul>\n<li>如果内容没有改变，Web服务器不需要发送完整的内容</li>\n<li>如果内容有修改，Etag则会更新，可以理解为文件的MD5值</li>\n</ul>\n<h5 id=\"Etag语法\"><a href=\"#Etag语法\" class=\"headerlink\" title=\"Etag语法\"></a>Etag语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: W&#x2F;&quot;&lt;etag_value&gt;&quot;</span><br><span class=\"line\">ETag: &quot;&lt;etag_value&gt;&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>W/  </p>\n<p>可选表示大小写敏感</p>\n</li>\n<li><etag_value> \n\n<p>没有明确指定生成ETag值的方法，可HASH，可MD5 ，可自定义的版本</p>\n</li>\n</ul>\n<p>Etag只是规定了响应的内容唯一标识，而需要真正起到作用，还需要与请求头部 <code>If-None-Match</code>配合使用</p>\n<h5 id=\"If-None-Match是什么\"><a href=\"#If-None-Match是什么\" class=\"headerlink\" title=\"If-None-Match是什么\"></a>If-None-Match是什么</h5><p>If-None-Match是一个条件式请求头部。</p>\n<ul>\n<li>对于 GET<a href=\"https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\" target=\"_blank\" rel=\"noopener\"><code>GET</code></a> 和 <a href=\"https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\" target=\"_blank\" rel=\"noopener\"><code>HEAD</code></a> 请求方法：<ul>\n<li>当服务器没有任何的资源Etag与请求头Etag值相同时候，返回所请求的资源，状态码为200</li>\n<li>而验证失败时，服务器返回304 Not Modified状态码，并且同时生成对应的200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。</li>\n</ul>\n</li>\n<li>对于其他方法：<ul>\n<li>当服务器没有任何资源的Etag属性值与请求的Etag属性值相匹配时，才会对请求做出相应处理。</li>\n<li>验证失败时，响应状态码<code>412 Precondition Failed</code>（先决条件失败）表示客户端错误</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"If-None-Match语法\"><a href=\"#If-None-Match语法\" class=\"headerlink\" title=\"If-None-Match语法\"></a>If-None-Match语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-None-Match: &lt;etag_value&gt;</span><br><span class=\"line\">If-None-Match: &lt;etag_value&gt;, &lt;etag_value&gt;, …</span><br><span class=\"line\">If-None-Match: *</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><etag_value>\n\n<p>形式是采用双引号括起来的由 ASCII 字符串（如”675af34563dc-tr34”）</p>\n</li>\n<li><p>*</p>\n<p>可以代表任意资源，只在用在资源上传时，一般用PUT方法，来·检测拥有相同识别ID的资源是否已经上传过了</p>\n</li>\n</ul>\n<h4 id=\"If-Modified-Since-amp-If-None-Match\"><a href=\"#If-Modified-Since-amp-If-None-Match\" class=\"headerlink\" title=\"If-Modified-Since &amp; If-None-Match\"></a>If-Modified-Since &amp; If-None-Match</h4><p><strong><u>当与If-Modified-Since一同使用的时候，If-None-Match 优先级更高</u></strong></p>\n<h4 id=\"小总结：\"><a href=\"#小总结：\" class=\"headerlink\" title=\"小总结：\"></a>小总结：</h4><blockquote>\n<p>no-cache 是开启缓存校验的钥匙</p>\n</blockquote>\n<p>设置了过期时间而没有设置no-cache ，在max-age 有效期内，浏览器不会发送该资源请求，直接获取本地缓存</p>\n<p>若设置了过期时间，且设置了no-cache ,会发送请求，并做缓存校验</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要HTTP缓存？-MDN\"><a href=\"#为什么要HTTP缓存？-MDN\" class=\"headerlink\" title=\"为什么要HTTP缓存？-MDN\"></a>为什么要HTTP缓存？-<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN</a></h2><p>客户端发送HTTP请求到服务端响应成功，中间需要建立TCP连接，三次握手，再是通信数据，再是四次挥手结束响应。这个过程需要的多次的往返通信，拖延了浏览器处理数据的时间，增加了访问者和服务器的流量成本，请求或数据过多时也降低了浏览体验。</p>\n<p>而缓存直白一些说</p>\n<ul>\n<li>可以节省用户的流量</li>\n<li>减少服务器资源损耗</li>\n</ul>\n<p>那如何缓存呢？</p>\n<h2 id=\"如何缓存-缓存控制\"><a href=\"#如何缓存-缓存控制\" class=\"headerlink\" title=\"如何缓存-缓存控制\"></a>如何缓存-缓存控制</h2><p>这里讲讲如何从HTTP头部字段来缓存，主要<code>Expires</code> 和 <code>Cache-Control</code>两个头部字段。</p>\n<p>Expires是HTTP1.0的时候存在的字段，Cache-Control 则是HTTP/1.1定义。都是请求响应通用头部，但一些指令值有不一样。</p>\n<ul>\n<li><p>Expires:缓存过期时间</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Expires:&lt;http-date&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cache-Control <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">有多项值</a>，这里主要说明一些常见的指令值</p>\n<ul>\n<li><p>no-store &amp; no-cache</p>\n</li>\n<li><p>public &amp; private</p>\n</li>\n<li><p>max-age</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Expires-HTTP-1-0\"><a href=\"#Expires-HTTP-1-0\" class=\"headerlink\" title=\"Expires (HTTP/1.0 +)\"></a>Expires (HTTP/1.0 +)</h3><p>服务器在HTTP 响应头部添加<code>Expires:&lt;http-date&gt;</code>字段，对象的字段值是缓存过期时间，如：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Expires</span>: Thu Jun 11 2020 15:35:38 GMT+0800</span><br></pre></td></tr></table></figure>\n\n<p>浏览器在解析到HTTP响应头中的<code>Expires</code>时，会先将该资源缓存起来。等到下一次再次访问这个资源的时候，浏览器会先检查缓存：<u><em>当前时间</em>是否超过<code>Expires</code></u>，如果没有超过，浏览器不会发送该资源的请求，直接从缓存中读取资源（如图：form disk cache）。</p>\n<p>![image-20200611155640808](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611155640808.png)</p>\n<p>但有个小问题：浏览器所在的设备是用户设备，这个当前时间是不可靠的。如果用户设置电脑的时间是3000年，那么浏览器得到的‘当前时间’则是3000，岂不是表示缓存永远过期了，那么这个缓存是无意义的？</p>\n<h3 id=\"Cache-Control（HTTP-1-1-）\"><a href=\"#Cache-Control（HTTP-1-1-）\" class=\"headerlink\" title=\"Cache-Control（HTTP/1.1+）\"></a>Cache-Control（HTTP/1.1+）</h3><p>HTTP/1.1 提供了一个<u>请求和响应的通用消息头字段</u> <code>Cache-Control</code> ,<code>Cache-Control</code>可以解决使用 <code>Expires</code>时由用户自动修改本地时间导致的缓存失效问题，并提供了更灵活的缓存机制。</p>\n<p>Cache-Control提供了<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">多项属性值</a>，来达到灵活控制缓存。</p>\n<h3 id=\"max-age\"><a href=\"#max-age\" class=\"headerlink\" title=\"max-age=\"></a>max-age=<seconds></h3><p>而其中的<code>Cache-Control: max-age=&lt;seconds&gt;</code>可以解决上述的Expires问题。给响应头设置<code>Cache-Control: max-age=30</code> 表示服务器告诉浏览器该资源在30秒之后过期。</p>\n<p>如果浏览器在30秒内再次请求该资源，则服务器不会返回内容，并且浏览器读取的是缓存。</p>\n<p>![image-20200611172530382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172530382.png)</p>\n<p>如果浏览器在30秒后再词请求资源，则会使用服务器返回的内容，并将新的内容缓存。</p>\n<p>![image-20200611172742569](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200611172742569.png)</p>\n<p><strong>当<code>Cache-Control: max-age=&lt;seconds&gt;</code>和<code>Expires</code>同时设置时，以<code>Cache-Control: max-age=&lt;seconds&gt;</code>为准</strong>。<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h3 id=\"public-amp-private\"><a href=\"#public-amp-private\" class=\"headerlink\" title=\"public &amp; private\"></a>public &amp; private</h3><p>public，响应可以被任何对象（发起请求的客户端，代理服务器等）缓存。即使是不可缓存的内容（没有设置max-age、expires等，或者是post请求）。</p>\n<p>private， 响应只能被单个用户缓存，不能作为共享缓存。私有缓存可以响应内容，比如用户发送请求的浏览器。</p>\n<h3 id=\"no-store-amp-no-cache\"><a href=\"#no-store-amp-no-cache\" class=\"headerlink\" title=\"no-store &amp; no-cache\"></a>no-store &amp; no-cache</h3><p>no-store，没有缓存。</p>\n<p>禁止浏览器缓存任何请求及响应的内容。每次客户端请求资源时，都会向服务器发送请求，并下载完整服务器响应的内容。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-store</span><br></pre></td></tr></table></figure>\n\n<p>no-cache，缓存但重新验证。</p>\n<p>表示必须先与服务器验证资源是否过期，更具响应结果来决定是否用缓存。若过期返回新的内容，未过期返回 HTTP code 304，告诉浏览器为过期使用本地缓存，避免重新下载资源。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-cache</span><br></pre></td></tr></table></figure>\n\n<p><strong>强调一点：no-store表示永远不用缓存，no-cache 每次先检查再看是否使用缓存</strong></p>\n<p><u>那如何验证缓存是否过期呢？</u></p>\n<h2 id=\"缓存过期了-验证缓存\"><a href=\"#缓存过期了-验证缓存\" class=\"headerlink\" title=\"缓存过期了-验证缓存\"></a>缓存过期了-验证缓存</h2><p>通过HTTP头部验证缓存有两种方式：</p>\n<ul>\n<li>响应头部<code>Last-Modified</code> &amp; 请求头部 <code>If-Modified-Since</code></li>\n<li>响应头部<code>Etag</code> &amp; 请求头部<code>If-None-Match</code></li>\n</ul>\n<h4 id=\"Last-Modified-amp-If-Modified-Since-If-Unmodified-Since\"><a href=\"#Last-Modified-amp-If-Modified-Since-If-Unmodified-Since\" class=\"headerlink\" title=\"Last-Modified &amp; If-Modified-Since|If-Unmodified-Since\"></a>Last-Modified &amp; If-Modified-Since|If-Unmodified-Since</h4><h5 id=\"如何起作用\"><a href=\"#如何起作用\" class=\"headerlink\" title=\"如何起作用\"></a>如何起作用</h5><p>我们先看下组合 <code>Last-Modified &amp; If-Modified-Since</code>。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\" target=\"_blank\" rel=\"noopener\">If-Unmodified-Since</a>与<code>If-Modified-Since</code>用法一样，意义相反，所以这里只说<code>If-Modified-Since</code></p>\n<p>该组合验证请求资源是否编辑过，如果编辑过则响应304，未编辑则是200。</p>\n<h5 id=\"If-Modified-Since是什么\"><a href=\"#If-Modified-Since是什么\" class=\"headerlink\" title=\"If-Modified-Since是什么\"></a>If-Modified-Since是什么</h5><p>请求头部 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">If-Modified-Since</a>，资源最后一次修改时间。需要注意的是<code>If-Modified-Since</code>只可以用在 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\" target=\"_blank\" rel=\"noopener\"><code>GET</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\" target=\"_blank\" rel=\"noopener\"><code>HEAD</code></a> 请求中</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">If-Modified-Since</span>: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Last-Modified是什么\"><a href=\"#Last-Modified是什么\" class=\"headerlink\" title=\"Last-Modified是什么\"></a>Last-Modified是什么</h5><p>响应头部<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified\" target=\"_blank\" rel=\"noopener\">Last-Modified</a>，表示资源的最后一次修改时间</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: &lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>第一次请求响应</strong></p>\n<p>Response</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">cache-control</span>: max-age=3600</span><br><span class=\"line\"><span class=\"attribute\">content-type</span>: image/webp</span><br><span class=\"line\"><span class=\"attribute\">date</span>: Tue, 16 Jun 2020 02:38:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">expires</span>: Tue, 16 Jun 2020 03:38:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">last-modified</span>: Tue, 17 Mar 2020 17:03:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二次请求响应</strong></p>\n<p>请求体中会带有<code>If-modified-since</code>  询问服务器该资源是否有编辑</p>\n<p>Request</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if-modified-since:Tue, 17 Mar 2020 18:31:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p>Response</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status Code: 304 Not Modified</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"attribute\">last-modified</span>: Tue, 17 Mar 2020 17:03:38 GMT</span><br></pre></td></tr></table></figure>\n\n<p>Last-Modified &amp; If-Modified-Since询问的是资源有没有编辑，如果文件直至打开，键入几个字再删除这几个字，再保存呢，这也是编辑了，但其实内容是无变化的。问题：</p>\n<p><u>如何知道服务器文件内容没有改动？</u></p>\n<h4 id=\"Etag-amp-If-None-Match\"><a href=\"#Etag-amp-If-None-Match\" class=\"headerlink\" title=\"Etag &amp; If-None-Match\"></a>Etag &amp; If-None-Match</h4><h5 id=\"Etag是什么？\"><a href=\"#Etag是什么？\" class=\"headerlink\" title=\"Etag是什么？\"></a>Etag是什么？</h5><p>Etag是HTTP响应头的资源的特定版本的标识符。当设置了该头部：</p>\n<ul>\n<li>如果内容没有改变，Web服务器不需要发送完整的内容</li>\n<li>如果内容有修改，Etag则会更新，可以理解为文件的MD5值</li>\n</ul>\n<h5 id=\"Etag语法\"><a href=\"#Etag语法\" class=\"headerlink\" title=\"Etag语法\"></a>Etag语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: W&#x2F;&quot;&lt;etag_value&gt;&quot;</span><br><span class=\"line\">ETag: &quot;&lt;etag_value&gt;&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>W/  </p>\n<p>可选表示大小写敏感</p>\n</li>\n<li><etag_value> \n\n<p>没有明确指定生成ETag值的方法，可HASH，可MD5 ，可自定义的版本</p>\n</li>\n</ul>\n<p>Etag只是规定了响应的内容唯一标识，而需要真正起到作用，还需要与请求头部 <code>If-None-Match</code>配合使用</p>\n<h5 id=\"If-None-Match是什么\"><a href=\"#If-None-Match是什么\" class=\"headerlink\" title=\"If-None-Match是什么\"></a>If-None-Match是什么</h5><p>If-None-Match是一个条件式请求头部。</p>\n<ul>\n<li>对于 GET<a href=\"https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\" target=\"_blank\" rel=\"noopener\"><code>GET</code></a> 和 <a href=\"https://wiki.developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD\" target=\"_blank\" rel=\"noopener\"><code>HEAD</code></a> 请求方法：<ul>\n<li>当服务器没有任何的资源Etag与请求头Etag值相同时候，返回所请求的资源，状态码为200</li>\n<li>而验证失败时，服务器返回304 Not Modified状态码，并且同时生成对应的200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。</li>\n</ul>\n</li>\n<li>对于其他方法：<ul>\n<li>当服务器没有任何资源的Etag属性值与请求的Etag属性值相匹配时，才会对请求做出相应处理。</li>\n<li>验证失败时，响应状态码<code>412 Precondition Failed</code>（先决条件失败）表示客户端错误</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"If-None-Match语法\"><a href=\"#If-None-Match语法\" class=\"headerlink\" title=\"If-None-Match语法\"></a>If-None-Match语法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-None-Match: &lt;etag_value&gt;</span><br><span class=\"line\">If-None-Match: &lt;etag_value&gt;, &lt;etag_value&gt;, …</span><br><span class=\"line\">If-None-Match: *</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><etag_value>\n\n<p>形式是采用双引号括起来的由 ASCII 字符串（如”675af34563dc-tr34”）</p>\n</li>\n<li><p>*</p>\n<p>可以代表任意资源，只在用在资源上传时，一般用PUT方法，来·检测拥有相同识别ID的资源是否已经上传过了</p>\n</li>\n</ul>\n<h4 id=\"If-Modified-Since-amp-If-None-Match\"><a href=\"#If-Modified-Since-amp-If-None-Match\" class=\"headerlink\" title=\"If-Modified-Since &amp; If-None-Match\"></a>If-Modified-Since &amp; If-None-Match</h4><p><strong><u>当与If-Modified-Since一同使用的时候，If-None-Match 优先级更高</u></strong></p>\n<h4 id=\"小总结：\"><a href=\"#小总结：\" class=\"headerlink\" title=\"小总结：\"></a>小总结：</h4><blockquote>\n<p>no-cache 是开启缓存校验的钥匙</p>\n</blockquote>\n<p>设置了过期时间而没有设置no-cache ，在max-age 有效期内，浏览器不会发送该资源请求，直接获取本地缓存</p>\n<p>若设置了过期时间，且设置了no-cache ,会发送请求，并做缓存校验</p>\n"},{"_content":"## 实现步骤：\n\n[DEMO](https://github.com/antqi/test/blob/master/promise/lib/promise.js)\n\n1. 定义整个结构\n2. Promise构造函数的实现\n3. Promise.then()/catch()的实现\n4. Promise.resolve()/reject()的实现\n5. Promise.all()/race()的实现\n6. Promise.resolveDelay()/rejectDelay()的实现\n\n\n\n## 1. 定义整体结构\n\n[code](https://github.com/antqi/test/blob/42bdff676a9adb85e96aaa111ba339a6c6aa262f/promise/lib/promise.js)\n\n``` javascript\n;(function (param) {\n  function Promise(excotor) {\n    function resolve() {}\n\n    function reject() {}\n    // excotor，执行器函数\n    excotor(resolve, reject)\n  }\n\n  /**\n   * @desc 指定成功与失败的回调函数\n   * @param {Function} onResolved 成功的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\n  Promise.prototype.then = function (onResolved, onRejected) {}\n\n  /**\n   * @desc 指定失败的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\n  Promise.prototype.catch = function (onRejected) {}\n\n  /**\n   * @desc 静态方法resolve，理解为快捷指定成功回调函数的方法\n   * @param {any} value 指定任意返回的值\n   * @return  被解析过Promise对象\n   */\n  Promise.resolve = function (value) {}\n\n  /**\n   * @desc 静态方法reject，理解为快捷指定失败回调函数的方法\n   * @param {any} reason 指定任意返回的值\n   * @return  带有特定被拒绝原因的Promise对象\n   */\n  Promise.resolve = function (reason) {}\n\n  /**\n   * @desc 启动多个异步任务并发运行 ，并组合返回的结果\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n   */\n  Promise.all = function (promises) {}\n\n  /**\n   * @desc 启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态\n   */\n  Promise.race = function (promises) {}\n\n  // 向外暴露\n  param.Promise = Promise\n})(window)\n```\n\n\n\n## 2. Promise的构造函数的实现\n\n``` javascript\nfunction Promise(excotor) {\n    let _self = this\n    // 状态常量\n    _self.STATUS = {\n      PENDING: 'pending',\n      RESOLVED: 'resolved',\n      REJECTED: 'rejected',\n    }\n    _self.status = _self.STATUS.PENDING // 初始化状态\n    _self.data // 当前状态下的data值\n    _self.callbacks = [] // 回调函数队列，每个元素的结构：{ onResolved(){}, onRejected(){} }\n\n    function resolve(value) {\n      // 状态只能修改一次\n      if (_self.status === _self.STATUS.RESOLVED) {\n        return\n      }\n      _self.status = _self.STATUS.RESOLVED\n      _self.data = value\n\n      if (_self.status === _self.STATUS.RESOLVED) {\n        _self.callbacks.forEach(function (callback) {\n          // 异步执行成功的回调：onResolved\n          setTimeout(function () {\n            callback.onResolved(value)\n          })\n        })\n      }\n    }\n\n    function reject(reason) {\n      // 状态只能修改一次\n      if (_self.status === _self.STATUS.REJECTED) {\n        return\n      }\n      _self.status = _self.STATUS.REJECTED\n      _self.data = reason\n\n      if (_self.status === _self.STATUS.REJECTED) {\n        _self.callbacks.forEach(function (callback) {\n          // 异步执行失败的回调：onRejected\n          setTimeout(function () {\n            callback.onRejected(reason)\n          })\n        })\n      }\n    }\n\n    try {\n      // excotor， 立即同步执行执行器函数\n      excotor(resolve, reject)\n    } catch (error) {\n      // 执行期函数抛出异常，则执行失败的回调函数\n      reject(error)\n    }\n  }\n}\n```\n\n\n\n\n\n## 3. Promise.then()/catch()的实现\n\n#### then\n\n- 先指定回调函数，后改变状态\n- 先改变状态，后指定回调函数\n- 返回一个新的promise，新的promise值有三种情况\n\n``` javascript\n/**\n   * @desc 指定成功与失败的回调函数\n   * @param {Function} onResolved 成功的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\nPromise.prototype.then = function (onResolved, onRejected) {\n  let _self = this\n\n  // 没有指定回调函数的时候\n  onResolved =\n    typeof onResolved === 'function'\n    ? onResolved\n  : function (value) {\n    return value\n  }\n  onRejected =\n    typeof onRejected === 'function'\n    ? onRejected\n  : function (reason) {\n    throw reason\n  }\n\n  // 返回一个新的Promise\n  return new Promise((resolve, reject) => {\n    function handler(callback) {\n     \n      try {\n        const result = callback(_self.data)\n\n        if (result instanceof Promise) {\n          // result是一个Promise\n          result.then(resolve, reject)\n        } else {\n          // result是普通值\n          resolve(result)\n        }\n      } catch (error) {\n        // onRejected抛出异常，则新的promise结果为error\n        reject(error)\n      }\n    }\n    if (_self.status === _self.STATUS.RESOLVED) {\n      // 当前状态是resolved，立即异步执行成功的回调函数\n      setTimeout(handler(onResolved))\n    } else if (_self.status === _self.STATUS.REJECTED) {\n      // 当前状态是rejeted，立即异步执行失败的回调函数\n      setTimeout(handler(onRejected))\n    } else {\n      // 当天状态是pending，将指定的回调函数存储到callbacks\n      _self.callbacks.push({\n        onResolved: function () {\n          handler(onResolved)\n        },\n        onRejected: function () {\n          handler(onRejected)\n        },\n      })\n    }\n  })\n}\n```\n\n#### catch\n\n``` javascript\n/**\n   * @desc 指定失败的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\nPromise.prototype.catch = function (onRejected) {\n  return this.then(undefined, onRejected)\n}\n```\n\n\n\n## 4. Promise.resolve()/reject()的实现\n\n#### resolved\n\n``` javascript\n/**\n   * @desc 静态方法resolve，理解为快捷指定成功回调函数的方法\n   * @param {any} value 指定任意返回的值\n   * @return  被解析过Promise对象\n   */\nPromise.resolve = function (value) {\n  return new Promise(function (resolve, reject) {\n    try {\n      if (value instanceof Promise) {\n        value.then(resolve, reject)\n      } else {\n        resolve(value)\n      }\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n```\n\n#### rejected\n\n``` javascript\n/**\n   * @desc 静态方法reject，理解为快捷指定失败回调函数的方法\n   * @param {any} reason 指定任意返回的值\n   * @return  带有特定被拒绝原因的Promise对象\n   */\nPromise.reject = function (reason) {\n  return new Promise(function (resolve, reject) {\n    reject(reason)\n  })\n}\n```\n\n\n\n## 5. Promise.all()/race()的实现\n\n#### all\n\n``` javascript\n/**\n   * @desc 启动多个异步任务并发运行 ，并组合返回的结果\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n   */\nPromise.all = function (promises) {\n  let values = new Array(promises.length)\n  let count = 0\n  return new Promise(function (resolve, reject) {\n    promises.forEach(function (promise, index) {\n      Promise.resolve(promise).then(\n        function (value) {\n          count++\n          values[index] = value\n          if (count === promises.length) {\n            resolve(values)\n          }\n        },\n        function (reason) {\n          reject(reason)\n        }\n      )\n    })\n  })\n}\n```\n\n#### race\n\n``` javascript\n/**\n   * @desc 启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态\n   */\nPromise.race = function (promises) {\n  return new Promise(function (resolve, reject) {\n    promises.forEach(function (p) {\n      Promise.resolve(p).then(\n        function (value) {\n          resolve(value)\n        },\n        function (reason) {\n          reject(reason)\n        }\n      )\n    })\n  })\n}\n```\n\n\n\n## 6. Promise.resolveDelay()/rejectedDelay()\n\n#### resolveDelay\n\n``` javascript\nPromise.resolveDelay = function (value, time) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      if (value instanceof Promise) {\n        value.then(resolve, reject)\n      } else {\n        resolve(value)\n      }\n    }, time)\n  })\n}\n```\n\n#### rejectedDelay\n\n``` javascript\nPromise.rejectDelay = function (reason, time) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      reject(reason)\n    }, time)\n  })\n}\n```\n\n\n\n## 7. ES5 function 完整版本\n\n\n\n## 8. ES6 class完整版\n\n\n\n","source":"_posts/自定义Promise/05-自定义Promise.md","raw":"## 实现步骤：\n\n[DEMO](https://github.com/antqi/test/blob/master/promise/lib/promise.js)\n\n1. 定义整个结构\n2. Promise构造函数的实现\n3. Promise.then()/catch()的实现\n4. Promise.resolve()/reject()的实现\n5. Promise.all()/race()的实现\n6. Promise.resolveDelay()/rejectDelay()的实现\n\n\n\n## 1. 定义整体结构\n\n[code](https://github.com/antqi/test/blob/42bdff676a9adb85e96aaa111ba339a6c6aa262f/promise/lib/promise.js)\n\n``` javascript\n;(function (param) {\n  function Promise(excotor) {\n    function resolve() {}\n\n    function reject() {}\n    // excotor，执行器函数\n    excotor(resolve, reject)\n  }\n\n  /**\n   * @desc 指定成功与失败的回调函数\n   * @param {Function} onResolved 成功的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\n  Promise.prototype.then = function (onResolved, onRejected) {}\n\n  /**\n   * @desc 指定失败的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\n  Promise.prototype.catch = function (onRejected) {}\n\n  /**\n   * @desc 静态方法resolve，理解为快捷指定成功回调函数的方法\n   * @param {any} value 指定任意返回的值\n   * @return  被解析过Promise对象\n   */\n  Promise.resolve = function (value) {}\n\n  /**\n   * @desc 静态方法reject，理解为快捷指定失败回调函数的方法\n   * @param {any} reason 指定任意返回的值\n   * @return  带有特定被拒绝原因的Promise对象\n   */\n  Promise.resolve = function (reason) {}\n\n  /**\n   * @desc 启动多个异步任务并发运行 ，并组合返回的结果\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n   */\n  Promise.all = function (promises) {}\n\n  /**\n   * @desc 启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态\n   */\n  Promise.race = function (promises) {}\n\n  // 向外暴露\n  param.Promise = Promise\n})(window)\n```\n\n\n\n## 2. Promise的构造函数的实现\n\n``` javascript\nfunction Promise(excotor) {\n    let _self = this\n    // 状态常量\n    _self.STATUS = {\n      PENDING: 'pending',\n      RESOLVED: 'resolved',\n      REJECTED: 'rejected',\n    }\n    _self.status = _self.STATUS.PENDING // 初始化状态\n    _self.data // 当前状态下的data值\n    _self.callbacks = [] // 回调函数队列，每个元素的结构：{ onResolved(){}, onRejected(){} }\n\n    function resolve(value) {\n      // 状态只能修改一次\n      if (_self.status === _self.STATUS.RESOLVED) {\n        return\n      }\n      _self.status = _self.STATUS.RESOLVED\n      _self.data = value\n\n      if (_self.status === _self.STATUS.RESOLVED) {\n        _self.callbacks.forEach(function (callback) {\n          // 异步执行成功的回调：onResolved\n          setTimeout(function () {\n            callback.onResolved(value)\n          })\n        })\n      }\n    }\n\n    function reject(reason) {\n      // 状态只能修改一次\n      if (_self.status === _self.STATUS.REJECTED) {\n        return\n      }\n      _self.status = _self.STATUS.REJECTED\n      _self.data = reason\n\n      if (_self.status === _self.STATUS.REJECTED) {\n        _self.callbacks.forEach(function (callback) {\n          // 异步执行失败的回调：onRejected\n          setTimeout(function () {\n            callback.onRejected(reason)\n          })\n        })\n      }\n    }\n\n    try {\n      // excotor， 立即同步执行执行器函数\n      excotor(resolve, reject)\n    } catch (error) {\n      // 执行期函数抛出异常，则执行失败的回调函数\n      reject(error)\n    }\n  }\n}\n```\n\n\n\n\n\n## 3. Promise.then()/catch()的实现\n\n#### then\n\n- 先指定回调函数，后改变状态\n- 先改变状态，后指定回调函数\n- 返回一个新的promise，新的promise值有三种情况\n\n``` javascript\n/**\n   * @desc 指定成功与失败的回调函数\n   * @param {Function} onResolved 成功的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\nPromise.prototype.then = function (onResolved, onRejected) {\n  let _self = this\n\n  // 没有指定回调函数的时候\n  onResolved =\n    typeof onResolved === 'function'\n    ? onResolved\n  : function (value) {\n    return value\n  }\n  onRejected =\n    typeof onRejected === 'function'\n    ? onRejected\n  : function (reason) {\n    throw reason\n  }\n\n  // 返回一个新的Promise\n  return new Promise((resolve, reject) => {\n    function handler(callback) {\n     \n      try {\n        const result = callback(_self.data)\n\n        if (result instanceof Promise) {\n          // result是一个Promise\n          result.then(resolve, reject)\n        } else {\n          // result是普通值\n          resolve(result)\n        }\n      } catch (error) {\n        // onRejected抛出异常，则新的promise结果为error\n        reject(error)\n      }\n    }\n    if (_self.status === _self.STATUS.RESOLVED) {\n      // 当前状态是resolved，立即异步执行成功的回调函数\n      setTimeout(handler(onResolved))\n    } else if (_self.status === _self.STATUS.REJECTED) {\n      // 当前状态是rejeted，立即异步执行失败的回调函数\n      setTimeout(handler(onRejected))\n    } else {\n      // 当天状态是pending，将指定的回调函数存储到callbacks\n      _self.callbacks.push({\n        onResolved: function () {\n          handler(onResolved)\n        },\n        onRejected: function () {\n          handler(onRejected)\n        },\n      })\n    }\n  })\n}\n```\n\n#### catch\n\n``` javascript\n/**\n   * @desc 指定失败的回调函数\n   * @param {Function} onRejected 失败的回调函数\n   * @return Promise对象\n   */\nPromise.prototype.catch = function (onRejected) {\n  return this.then(undefined, onRejected)\n}\n```\n\n\n\n## 4. Promise.resolve()/reject()的实现\n\n#### resolved\n\n``` javascript\n/**\n   * @desc 静态方法resolve，理解为快捷指定成功回调函数的方法\n   * @param {any} value 指定任意返回的值\n   * @return  被解析过Promise对象\n   */\nPromise.resolve = function (value) {\n  return new Promise(function (resolve, reject) {\n    try {\n      if (value instanceof Promise) {\n        value.then(resolve, reject)\n      } else {\n        resolve(value)\n      }\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n```\n\n#### rejected\n\n``` javascript\n/**\n   * @desc 静态方法reject，理解为快捷指定失败回调函数的方法\n   * @param {any} reason 指定任意返回的值\n   * @return  带有特定被拒绝原因的Promise对象\n   */\nPromise.reject = function (reason) {\n  return new Promise(function (resolve, reject) {\n    reject(reason)\n  })\n}\n```\n\n\n\n## 5. Promise.all()/race()的实现\n\n#### all\n\n``` javascript\n/**\n   * @desc 启动多个异步任务并发运行 ，并组合返回的结果\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败\n   */\nPromise.all = function (promises) {\n  let values = new Array(promises.length)\n  let count = 0\n  return new Promise(function (resolve, reject) {\n    promises.forEach(function (promise, index) {\n      Promise.resolve(promise).then(\n        function (value) {\n          count++\n          values[index] = value\n          if (count === promises.length) {\n            resolve(values)\n          }\n        },\n        function (reason) {\n          reject(reason)\n        }\n      )\n    })\n  })\n}\n```\n\n#### race\n\n``` javascript\n/**\n   * @desc 启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise\n   * @param {Array｜String} promises 多个promise或值组成的数组\n   * @return 一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态\n   */\nPromise.race = function (promises) {\n  return new Promise(function (resolve, reject) {\n    promises.forEach(function (p) {\n      Promise.resolve(p).then(\n        function (value) {\n          resolve(value)\n        },\n        function (reason) {\n          reject(reason)\n        }\n      )\n    })\n  })\n}\n```\n\n\n\n## 6. Promise.resolveDelay()/rejectedDelay()\n\n#### resolveDelay\n\n``` javascript\nPromise.resolveDelay = function (value, time) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      if (value instanceof Promise) {\n        value.then(resolve, reject)\n      } else {\n        resolve(value)\n      }\n    }, time)\n  })\n}\n```\n\n#### rejectedDelay\n\n``` javascript\nPromise.rejectDelay = function (reason, time) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      reject(reason)\n    }, time)\n  })\n}\n```\n\n\n\n## 7. ES5 function 完整版本\n\n\n\n## 8. ES6 class完整版\n\n\n\n","slug":"自定义Promise/05-自定义Promise","published":1,"date":"2020-06-25T03:10:24.450Z","updated":"2020-06-25T03:10:24.450Z","title":"自定义Promise/05-自定义Promise","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wof000t3ns6ayathsl9","content":"<h2 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h2><p><a href=\"https://github.com/antqi/test/blob/master/promise/lib/promise.js\" target=\"_blank\" rel=\"noopener\">DEMO</a></p>\n<ol>\n<li>定义整个结构</li>\n<li>Promise构造函数的实现</li>\n<li>Promise.then()/catch()的实现</li>\n<li>Promise.resolve()/reject()的实现</li>\n<li>Promise.all()/race()的实现</li>\n<li>Promise.resolveDelay()/rejectDelay()的实现</li>\n</ol>\n<h2 id=\"1-定义整体结构\"><a href=\"#1-定义整体结构\" class=\"headerlink\" title=\"1. 定义整体结构\"></a>1. 定义整体结构</h2><p><a href=\"https://github.com/antqi/test/blob/42bdff676a9adb85e96aaa111ba339a6c6aa262f/promise/lib/promise.js\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">excotor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// excotor，执行器函数</span></span><br><span class=\"line\">    excotor(resolve, reject)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定成功与失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onResolved 成功的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法resolve，理解为快捷指定成功回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>value 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>被解析过Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法reject，理解为快捷指定失败回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>reason 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>带有特定被拒绝原因的Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，并组合返回的结果</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向外暴露</span></span><br><span class=\"line\">  param.Promise = <span class=\"built_in\">Promise</span></span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-Promise的构造函数的实现\"><a href=\"#2-Promise的构造函数的实现\" class=\"headerlink\" title=\"2. Promise的构造函数的实现\"></a>2. Promise的构造函数的实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">excotor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态常量</span></span><br><span class=\"line\">    _self.STATUS = &#123;</span><br><span class=\"line\">      PENDING: <span class=\"string\">'pending'</span>,</span><br><span class=\"line\">      RESOLVED: <span class=\"string\">'resolved'</span>,</span><br><span class=\"line\">      REJECTED: <span class=\"string\">'rejected'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _self.status = _self.STATUS.PENDING <span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\">    _self.data <span class=\"comment\">// 当前状态下的data值</span></span><br><span class=\"line\">    _self.callbacks = [] <span class=\"comment\">// 回调函数队列，每个元素的结构：&#123; onResolved()&#123;&#125;, onRejected()&#123;&#125; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 状态只能修改一次</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _self.status = _self.STATUS.RESOLVED</span><br><span class=\"line\">      _self.data = value</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">        _self.callbacks.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 异步执行成功的回调：onResolved</span></span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            callback.onResolved(value)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 状态只能修改一次</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _self.status = _self.STATUS.REJECTED</span><br><span class=\"line\">      _self.data = reason</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">        _self.callbacks.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 异步执行失败的回调：onRejected</span></span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            callback.onRejected(reason)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// excotor， 立即同步执行执行器函数</span></span><br><span class=\"line\">      excotor(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行期函数抛出异常，则执行失败的回调函数</span></span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"3-Promise-then-catch-的实现\"><a href=\"#3-Promise-then-catch-的实现\" class=\"headerlink\" title=\"3. Promise.then()/catch()的实现\"></a>3. Promise.then()/catch()的实现</h2><h4 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then\"></a>then</h4><ul>\n<li>先指定回调函数，后改变状态</li>\n<li>先改变状态，后指定回调函数</li>\n<li>返回一个新的promise，新的promise值有三种情况</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定成功与失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onResolved 成功的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _self = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有指定回调函数的时候</span></span><br><span class=\"line\">  onResolved =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">'function'</span></span><br><span class=\"line\">    ? onResolved</span><br><span class=\"line\">  : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">    ? onRejected</span><br><span class=\"line\">  : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = callback(_self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// result是一个Promise</span></span><br><span class=\"line\">          result.then(resolve, reject)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// result是普通值</span></span><br><span class=\"line\">          resolve(result)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// onRejected抛出异常，则新的promise结果为error</span></span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前状态是resolved，立即异步执行成功的回调函数</span></span><br><span class=\"line\">      setTimeout(handler(onResolved))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前状态是rejeted，立即异步执行失败的回调函数</span></span><br><span class=\"line\">      setTimeout(handler(onRejected))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当天状态是pending，将指定的回调函数存储到callbacks</span></span><br><span class=\"line\">      _self.callbacks.push(&#123;</span><br><span class=\"line\">        onResolved: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          handler(onResolved)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        onRejected: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          handler(onRejected)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-Promise-resolve-reject-的实现\"><a href=\"#4-Promise-resolve-reject-的实现\" class=\"headerlink\" title=\"4. Promise.resolve()/reject()的实现\"></a>4. Promise.resolve()/reject()的实现</h2><h4 id=\"resolved\"><a href=\"#resolved\" class=\"headerlink\" title=\"resolved\"></a>resolved</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法resolve，理解为快捷指定成功回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>value 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>被解析过Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">        value.then(resolve, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rejected\"><a href=\"#rejected\" class=\"headerlink\" title=\"rejected\"></a>rejected</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法reject，理解为快捷指定失败回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>reason 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>带有特定被拒绝原因的Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(reason)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-Promise-all-race-的实现\"><a href=\"#5-Promise-all-race-的实现\" class=\"headerlink\" title=\"5. Promise.all()/race()的实现\"></a>5. Promise.all()/race()的实现</h2><h4 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all\"></a>all</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，并组合返回的结果</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> values = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(promises.length)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, index</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(promise).then(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          count++</span><br><span class=\"line\">          values[index] = value</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (count === promises.length) &#123;</span><br><span class=\"line\">            resolve(values)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">          reject(reason)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\"race\"></a>race</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(p).then(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          resolve(value)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">          reject(reason)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-Promise-resolveDelay-rejectedDelay\"><a href=\"#6-Promise-resolveDelay-rejectedDelay\" class=\"headerlink\" title=\"6. Promise.resolveDelay()/rejectedDelay()\"></a>6. Promise.resolveDelay()/rejectedDelay()</h2><h4 id=\"resolveDelay\"><a href=\"#resolveDelay\" class=\"headerlink\" title=\"resolveDelay\"></a>resolveDelay</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolveDelay = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">        value.then(resolve, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rejectedDelay\"><a href=\"#rejectedDelay\" class=\"headerlink\" title=\"rejectedDelay\"></a>rejectedDelay</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.rejectDelay = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(reason)</span><br><span class=\"line\">    &#125;, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"7-ES5-function-完整版本\"><a href=\"#7-ES5-function-完整版本\" class=\"headerlink\" title=\"7. ES5 function 完整版本\"></a>7. ES5 function 完整版本</h2><h2 id=\"8-ES6-class完整版\"><a href=\"#8-ES6-class完整版\" class=\"headerlink\" title=\"8. ES6 class完整版\"></a>8. ES6 class完整版</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h2><p><a href=\"https://github.com/antqi/test/blob/master/promise/lib/promise.js\" target=\"_blank\" rel=\"noopener\">DEMO</a></p>\n<ol>\n<li>定义整个结构</li>\n<li>Promise构造函数的实现</li>\n<li>Promise.then()/catch()的实现</li>\n<li>Promise.resolve()/reject()的实现</li>\n<li>Promise.all()/race()的实现</li>\n<li>Promise.resolveDelay()/rejectDelay()的实现</li>\n</ol>\n<h2 id=\"1-定义整体结构\"><a href=\"#1-定义整体结构\" class=\"headerlink\" title=\"1. 定义整体结构\"></a>1. 定义整体结构</h2><p><a href=\"https://github.com/antqi/test/blob/42bdff676a9adb85e96aaa111ba339a6c6aa262f/promise/lib/promise.js\" target=\"_blank\" rel=\"noopener\">code</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">excotor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// excotor，执行器函数</span></span><br><span class=\"line\">    excotor(resolve, reject)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定成功与失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onResolved 成功的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法resolve，理解为快捷指定成功回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>value 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>被解析过Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法reject，理解为快捷指定失败回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>reason 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>带有特定被拒绝原因的Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，并组合返回的结果</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向外暴露</span></span><br><span class=\"line\">  param.Promise = <span class=\"built_in\">Promise</span></span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-Promise的构造函数的实现\"><a href=\"#2-Promise的构造函数的实现\" class=\"headerlink\" title=\"2. Promise的构造函数的实现\"></a>2. Promise的构造函数的实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">excotor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态常量</span></span><br><span class=\"line\">    _self.STATUS = &#123;</span><br><span class=\"line\">      PENDING: <span class=\"string\">'pending'</span>,</span><br><span class=\"line\">      RESOLVED: <span class=\"string\">'resolved'</span>,</span><br><span class=\"line\">      REJECTED: <span class=\"string\">'rejected'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _self.status = _self.STATUS.PENDING <span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\">    _self.data <span class=\"comment\">// 当前状态下的data值</span></span><br><span class=\"line\">    _self.callbacks = [] <span class=\"comment\">// 回调函数队列，每个元素的结构：&#123; onResolved()&#123;&#125;, onRejected()&#123;&#125; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 状态只能修改一次</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _self.status = _self.STATUS.RESOLVED</span><br><span class=\"line\">      _self.data = value</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">        _self.callbacks.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 异步执行成功的回调：onResolved</span></span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            callback.onResolved(value)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 状态只能修改一次</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _self.status = _self.STATUS.REJECTED</span><br><span class=\"line\">      _self.data = reason</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">        _self.callbacks.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 异步执行失败的回调：onRejected</span></span><br><span class=\"line\">          setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            callback.onRejected(reason)</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// excotor， 立即同步执行执行器函数</span></span><br><span class=\"line\">      excotor(resolve, reject)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行期函数抛出异常，则执行失败的回调函数</span></span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"3-Promise-then-catch-的实现\"><a href=\"#3-Promise-then-catch-的实现\" class=\"headerlink\" title=\"3. Promise.then()/catch()的实现\"></a>3. Promise.then()/catch()的实现</h2><h4 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then\"></a>then</h4><ul>\n<li>先指定回调函数，后改变状态</li>\n<li>先改变状态，后指定回调函数</li>\n<li>返回一个新的promise，新的promise值有三种情况</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定成功与失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onResolved 成功的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _self = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 没有指定回调函数的时候</span></span><br><span class=\"line\">  onResolved =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">'function'</span></span><br><span class=\"line\">    ? onResolved</span><br><span class=\"line\">  : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onRejected =</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span></span><br><span class=\"line\">    ? onRejected</span><br><span class=\"line\">  : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个新的Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = callback(_self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// result是一个Promise</span></span><br><span class=\"line\">          result.then(resolve, reject)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// result是普通值</span></span><br><span class=\"line\">          resolve(result)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// onRejected抛出异常，则新的promise结果为error</span></span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_self.status === _self.STATUS.RESOLVED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前状态是resolved，立即异步执行成功的回调函数</span></span><br><span class=\"line\">      setTimeout(handler(onResolved))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (_self.status === _self.STATUS.REJECTED) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当前状态是rejeted，立即异步执行失败的回调函数</span></span><br><span class=\"line\">      setTimeout(handler(onRejected))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当天状态是pending，将指定的回调函数存储到callbacks</span></span><br><span class=\"line\">      _self.callbacks.push(&#123;</span><br><span class=\"line\">        onResolved: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          handler(onResolved)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        onRejected: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          handler(onRejected)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>指定失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>onRejected 失败的回调函数</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-Promise-resolve-reject-的实现\"><a href=\"#4-Promise-resolve-reject-的实现\" class=\"headerlink\" title=\"4. Promise.resolve()/reject()的实现\"></a>4. Promise.resolve()/reject()的实现</h2><h4 id=\"resolved\"><a href=\"#resolved\" class=\"headerlink\" title=\"resolved\"></a>resolved</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法resolve，理解为快捷指定成功回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>value 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>被解析过Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">        value.then(resolve, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rejected\"><a href=\"#rejected\" class=\"headerlink\" title=\"rejected\"></a>rejected</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>静态方法reject，理解为快捷指定失败回调函数的方法</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;any&#125;</span> </span>reason 指定任意返回的值</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return  </span>带有特定被拒绝原因的Promise对象</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(reason)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-Promise-all-race-的实现\"><a href=\"#5-Promise-all-race-的实现\" class=\"headerlink\" title=\"5. Promise.all()/race()的实现\"></a>5. Promise.all()/race()的实现</h2><h4 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all\"></a>all</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，并组合返回的结果</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的Promise，只有所有的Promise都成功才成功，只要有一个失败了就直接失败</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> values = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(promises.length)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, index</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(promise).then(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          count++</span><br><span class=\"line\">          values[index] = value</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (count === promises.length) &#123;</span><br><span class=\"line\">            resolve(values)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">          reject(reason)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\"race\"></a>race</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@desc </span>启动多个异步任务并发运行 ，第一个解决或拒绝的promise的结果状态组成的新的promise</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Array｜String&#125;</span> </span>promises 多个promise或值组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return </span>一个新的promise ，第一个解决或拒绝的promise的结果状态就是最终的结果状态</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">Promise</span>.resolve(p).then(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          resolve(value)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">          reject(reason)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-Promise-resolveDelay-rejectedDelay\"><a href=\"#6-Promise-resolveDelay-rejectedDelay\" class=\"headerlink\" title=\"6. Promise.resolveDelay()/rejectedDelay()\"></a>6. Promise.resolveDelay()/rejectedDelay()</h2><h4 id=\"resolveDelay\"><a href=\"#resolveDelay\" class=\"headerlink\" title=\"resolveDelay\"></a>resolveDelay</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolveDelay = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">        value.then(resolve, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rejectedDelay\"><a href=\"#rejectedDelay\" class=\"headerlink\" title=\"rejectedDelay\"></a>rejectedDelay</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.rejectDelay = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      reject(reason)</span><br><span class=\"line\">    &#125;, time)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"7-ES5-function-完整版本\"><a href=\"#7-ES5-function-完整版本\" class=\"headerlink\" title=\"7. ES5 function 完整版本\"></a>7. ES5 function 完整版本</h2><h2 id=\"8-ES6-class完整版\"><a href=\"#8-ES6-class完整版\" class=\"headerlink\" title=\"8. ES6 class完整版\"></a>8. ES6 class完整版</h2>"},{"_content":"## 工作与生活为何会冲突\n\n#### 工作焦虑症\n\n担心不努力工作会慢慢失去竞争力\n\n误区：提高竞争力的方法是提高工作量（这绝对错了）\n\n*赢家总在找概率，菜鸟每局都想赢*\n\n#### 工作狂症\n\n在工作中感受成长和巨大的成就感和快乐中\n\n误区：工作事业成功是高质量生活的首要目标\n\n## 明确自己中心角色\n\n> 明确自己的立场和中心角色，减少选择机会成本\n\n![image-20200512203019382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512203019382.png)\n\n## 工作与生活达到动态平衡\n\n如何寻找动态生活平衡\n\n- 少搞上下班“分裂”，抓住上班时学习和练习的机会\n- 安排工作之外的活动来排解压力\n- 即使划分生活和工作的界限，确立好自己的“警戒线”\n- 适当停下工作，思考生活目标\n\n## 增加生活仪式感\n\n- 调整好乐观的心态\n\n  努力改变能改变的，淡定接受不能改变的\n\n- 加强身体健康管理\n\n  保证充足睡眠，健康饮食，健康运动，干净装扮\n\n- 分享生活美好瞬间\n\n  定期分享亲朋好友关于自己生活方面的动态\n\n![image-20200512204420261](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512204420261.png)","source":"_posts/LEVEL 1/时间管理/《时间管理》工作与生活冲突，如何享受生活.md","raw":"## 工作与生活为何会冲突\n\n#### 工作焦虑症\n\n担心不努力工作会慢慢失去竞争力\n\n误区：提高竞争力的方法是提高工作量（这绝对错了）\n\n*赢家总在找概率，菜鸟每局都想赢*\n\n#### 工作狂症\n\n在工作中感受成长和巨大的成就感和快乐中\n\n误区：工作事业成功是高质量生活的首要目标\n\n## 明确自己中心角色\n\n> 明确自己的立场和中心角色，减少选择机会成本\n\n![image-20200512203019382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512203019382.png)\n\n## 工作与生活达到动态平衡\n\n如何寻找动态生活平衡\n\n- 少搞上下班“分裂”，抓住上班时学习和练习的机会\n- 安排工作之外的活动来排解压力\n- 即使划分生活和工作的界限，确立好自己的“警戒线”\n- 适当停下工作，思考生活目标\n\n## 增加生活仪式感\n\n- 调整好乐观的心态\n\n  努力改变能改变的，淡定接受不能改变的\n\n- 加强身体健康管理\n\n  保证充足睡眠，健康饮食，健康运动，干净装扮\n\n- 分享生活美好瞬间\n\n  定期分享亲朋好友关于自己生活方面的动态\n\n![image-20200512204420261](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512204420261.png)","slug":"LEVEL 1/时间管理/《时间管理》工作与生活冲突，如何享受生活","published":1,"date":"2020-06-25T03:10:24.438Z","updated":"2020-06-25T03:10:24.439Z","title":"LEVEL 1/时间管理/《时间管理》工作与生活冲突，如何享受生活","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wol000u3ns6a1g121cf","content":"<h2 id=\"工作与生活为何会冲突\"><a href=\"#工作与生活为何会冲突\" class=\"headerlink\" title=\"工作与生活为何会冲突\"></a>工作与生活为何会冲突</h2><h4 id=\"工作焦虑症\"><a href=\"#工作焦虑症\" class=\"headerlink\" title=\"工作焦虑症\"></a>工作焦虑症</h4><p>担心不努力工作会慢慢失去竞争力</p>\n<p>误区：提高竞争力的方法是提高工作量（这绝对错了）</p>\n<p><em>赢家总在找概率，菜鸟每局都想赢</em></p>\n<h4 id=\"工作狂症\"><a href=\"#工作狂症\" class=\"headerlink\" title=\"工作狂症\"></a>工作狂症</h4><p>在工作中感受成长和巨大的成就感和快乐中</p>\n<p>误区：工作事业成功是高质量生活的首要目标</p>\n<h2 id=\"明确自己中心角色\"><a href=\"#明确自己中心角色\" class=\"headerlink\" title=\"明确自己中心角色\"></a>明确自己中心角色</h2><blockquote>\n<p>明确自己的立场和中心角色，减少选择机会成本</p>\n</blockquote>\n<p>![image-20200512203019382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512203019382.png)</p>\n<h2 id=\"工作与生活达到动态平衡\"><a href=\"#工作与生活达到动态平衡\" class=\"headerlink\" title=\"工作与生活达到动态平衡\"></a>工作与生活达到动态平衡</h2><p>如何寻找动态生活平衡</p>\n<ul>\n<li>少搞上下班“分裂”，抓住上班时学习和练习的机会</li>\n<li>安排工作之外的活动来排解压力</li>\n<li>即使划分生活和工作的界限，确立好自己的“警戒线”</li>\n<li>适当停下工作，思考生活目标</li>\n</ul>\n<h2 id=\"增加生活仪式感\"><a href=\"#增加生活仪式感\" class=\"headerlink\" title=\"增加生活仪式感\"></a>增加生活仪式感</h2><ul>\n<li><p>调整好乐观的心态</p>\n<p>努力改变能改变的，淡定接受不能改变的</p>\n</li>\n<li><p>加强身体健康管理</p>\n<p>保证充足睡眠，健康饮食，健康运动，干净装扮</p>\n</li>\n<li><p>分享生活美好瞬间</p>\n<p>定期分享亲朋好友关于自己生活方面的动态</p>\n</li>\n</ul>\n<p>![image-20200512204420261](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512204420261.png)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工作与生活为何会冲突\"><a href=\"#工作与生活为何会冲突\" class=\"headerlink\" title=\"工作与生活为何会冲突\"></a>工作与生活为何会冲突</h2><h4 id=\"工作焦虑症\"><a href=\"#工作焦虑症\" class=\"headerlink\" title=\"工作焦虑症\"></a>工作焦虑症</h4><p>担心不努力工作会慢慢失去竞争力</p>\n<p>误区：提高竞争力的方法是提高工作量（这绝对错了）</p>\n<p><em>赢家总在找概率，菜鸟每局都想赢</em></p>\n<h4 id=\"工作狂症\"><a href=\"#工作狂症\" class=\"headerlink\" title=\"工作狂症\"></a>工作狂症</h4><p>在工作中感受成长和巨大的成就感和快乐中</p>\n<p>误区：工作事业成功是高质量生活的首要目标</p>\n<h2 id=\"明确自己中心角色\"><a href=\"#明确自己中心角色\" class=\"headerlink\" title=\"明确自己中心角色\"></a>明确自己中心角色</h2><blockquote>\n<p>明确自己的立场和中心角色，减少选择机会成本</p>\n</blockquote>\n<p>![image-20200512203019382](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512203019382.png)</p>\n<h2 id=\"工作与生活达到动态平衡\"><a href=\"#工作与生活达到动态平衡\" class=\"headerlink\" title=\"工作与生活达到动态平衡\"></a>工作与生活达到动态平衡</h2><p>如何寻找动态生活平衡</p>\n<ul>\n<li>少搞上下班“分裂”，抓住上班时学习和练习的机会</li>\n<li>安排工作之外的活动来排解压力</li>\n<li>即使划分生活和工作的界限，确立好自己的“警戒线”</li>\n<li>适当停下工作，思考生活目标</li>\n</ul>\n<h2 id=\"增加生活仪式感\"><a href=\"#增加生活仪式感\" class=\"headerlink\" title=\"增加生活仪式感\"></a>增加生活仪式感</h2><ul>\n<li><p>调整好乐观的心态</p>\n<p>努力改变能改变的，淡定接受不能改变的</p>\n</li>\n<li><p>加强身体健康管理</p>\n<p>保证充足睡眠，健康饮食，健康运动，干净装扮</p>\n</li>\n<li><p>分享生活美好瞬间</p>\n<p>定期分享亲朋好友关于自己生活方面的动态</p>\n</li>\n</ul>\n<p>![image-20200512204420261](/Users/ant_qi/Library/Application Support/typora-user-images/image-20200512204420261.png)</p>\n"},{"_content":"## 重新认识时间管理\n\n> 时间无法被管理，我们只能管理注意力\n\n效率= 工作量/时间\n\n工作时间= 启动时间+专注时间+碎片时间\n\n工作没有上限，工作会自动扩张\n\n你越擅长时间管理，你的时间就越来越少；最终你的生活会被工作占满\n\n*自我支配时间增加，在心流状态下完成任务，在截止日期前交付*\n\n`HAVE TO`  VS.  `WANT TO`\n\n**效率是结果，不是目标；专注是目标，产生幸福**\n\n\n\n## 利用清单管理工作量\n\n> 不管理工作量，任何时间管理技巧都无法拯救你\n\n工作量清单\n\n- TO-DO-LIST\n- NOT-TO-DO-LIST\n- OTHERS-TO-DO-LIST\n\n**是否对你的实现目标（无论长期，还是短期）有益**\n\n解放自己，提升下属或者伙伴的业务能力\n\n重复、不重要的工作交出去（核查清单）\n\n**产生清单**和方法与方法\n\n#### 萃取法\n\n> 萃取是一种知识与经验的整理技术\n\n**做工具做方法**\n\n## WOOP减少启动时间\n\n不谈行动里的时间管理都是纸老虎\n\n一段时间只做一件事（专注是最终目标）\n\n#### 大脑运行机制\n\n- 目标意图\n- 执行意图 \n\n#### 减少启动时间\n\n- 减肥15-20斤\n- 建立自己的一套时间管理\n- 上厕所不看手机\n- 11:30睡觉\n- 7:30 起床看书半小时\n\n愿望：8月30日前减肥15斤-20斤\n\n结果：如果在8月30日\n\n障碍：（会遇到什么障碍）\n\n计划：（解决障碍）\n\n## 时间统计 * \n\n#### 四步心法\n\n- 观察：观察并觉知到自己注意力转换\n\n  开始并不容易，习惯之后成为自然\n\n- 记录：观察到注意力转移时，立刻记录下来\n\n  准备一个随身携带的小本子，如实记录，误差控制在15min之内\n\n- 统计：按月或记录讲本子输入到excel\n\n  输入的时候依据自己的人生观将时间分类，透视汇总时间。积累6个月的数据量\n\n- 反馈：面对时间统计结果，接纳自己，培养习惯\n\n  习惯的变化根本上时人格变化，心理学家告诉我们人格变化要1-3年的时间，不要操之过急\n\n  \n\n  \n\n## 问题\n\n> 我的人生目标时什么？我能花在人生目标上的时间有多少？\n\n清单革命\n\nWOOP思维心理学\n\n奇特的一生-格拉宁\n\n智识管理的技术-知识管理（卡片管理）\n\n罗伯特议事规则","source":"_posts/LEVEL 1/时间管理/如何优雅的实现时间自由.md","raw":"## 重新认识时间管理\n\n> 时间无法被管理，我们只能管理注意力\n\n效率= 工作量/时间\n\n工作时间= 启动时间+专注时间+碎片时间\n\n工作没有上限，工作会自动扩张\n\n你越擅长时间管理，你的时间就越来越少；最终你的生活会被工作占满\n\n*自我支配时间增加，在心流状态下完成任务，在截止日期前交付*\n\n`HAVE TO`  VS.  `WANT TO`\n\n**效率是结果，不是目标；专注是目标，产生幸福**\n\n\n\n## 利用清单管理工作量\n\n> 不管理工作量，任何时间管理技巧都无法拯救你\n\n工作量清单\n\n- TO-DO-LIST\n- NOT-TO-DO-LIST\n- OTHERS-TO-DO-LIST\n\n**是否对你的实现目标（无论长期，还是短期）有益**\n\n解放自己，提升下属或者伙伴的业务能力\n\n重复、不重要的工作交出去（核查清单）\n\n**产生清单**和方法与方法\n\n#### 萃取法\n\n> 萃取是一种知识与经验的整理技术\n\n**做工具做方法**\n\n## WOOP减少启动时间\n\n不谈行动里的时间管理都是纸老虎\n\n一段时间只做一件事（专注是最终目标）\n\n#### 大脑运行机制\n\n- 目标意图\n- 执行意图 \n\n#### 减少启动时间\n\n- 减肥15-20斤\n- 建立自己的一套时间管理\n- 上厕所不看手机\n- 11:30睡觉\n- 7:30 起床看书半小时\n\n愿望：8月30日前减肥15斤-20斤\n\n结果：如果在8月30日\n\n障碍：（会遇到什么障碍）\n\n计划：（解决障碍）\n\n## 时间统计 * \n\n#### 四步心法\n\n- 观察：观察并觉知到自己注意力转换\n\n  开始并不容易，习惯之后成为自然\n\n- 记录：观察到注意力转移时，立刻记录下来\n\n  准备一个随身携带的小本子，如实记录，误差控制在15min之内\n\n- 统计：按月或记录讲本子输入到excel\n\n  输入的时候依据自己的人生观将时间分类，透视汇总时间。积累6个月的数据量\n\n- 反馈：面对时间统计结果，接纳自己，培养习惯\n\n  习惯的变化根本上时人格变化，心理学家告诉我们人格变化要1-3年的时间，不要操之过急\n\n  \n\n  \n\n## 问题\n\n> 我的人生目标时什么？我能花在人生目标上的时间有多少？\n\n清单革命\n\nWOOP思维心理学\n\n奇特的一生-格拉宁\n\n智识管理的技术-知识管理（卡片管理）\n\n罗伯特议事规则","slug":"LEVEL 1/时间管理/如何优雅的实现时间自由","published":1,"date":"2020-06-25T03:10:24.440Z","updated":"2020-06-25T03:10:24.440Z","title":"LEVEL 1/时间管理/如何优雅的实现时间自由","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3won000v3ns6909w1jfc","content":"<h2 id=\"重新认识时间管理\"><a href=\"#重新认识时间管理\" class=\"headerlink\" title=\"重新认识时间管理\"></a>重新认识时间管理</h2><blockquote>\n<p>时间无法被管理，我们只能管理注意力</p>\n</blockquote>\n<p>效率= 工作量/时间</p>\n<p>工作时间= 启动时间+专注时间+碎片时间</p>\n<p>工作没有上限，工作会自动扩张</p>\n<p>你越擅长时间管理，你的时间就越来越少；最终你的生活会被工作占满</p>\n<p><em>自我支配时间增加，在心流状态下完成任务，在截止日期前交付</em></p>\n<p><code>HAVE TO</code>  VS.  <code>WANT TO</code></p>\n<p><strong>效率是结果，不是目标；专注是目标，产生幸福</strong></p>\n<h2 id=\"利用清单管理工作量\"><a href=\"#利用清单管理工作量\" class=\"headerlink\" title=\"利用清单管理工作量\"></a>利用清单管理工作量</h2><blockquote>\n<p>不管理工作量，任何时间管理技巧都无法拯救你</p>\n</blockquote>\n<p>工作量清单</p>\n<ul>\n<li>TO-DO-LIST</li>\n<li>NOT-TO-DO-LIST</li>\n<li>OTHERS-TO-DO-LIST</li>\n</ul>\n<p><strong>是否对你的实现目标（无论长期，还是短期）有益</strong></p>\n<p>解放自己，提升下属或者伙伴的业务能力</p>\n<p>重复、不重要的工作交出去（核查清单）</p>\n<p><strong>产生清单</strong>和方法与方法</p>\n<h4 id=\"萃取法\"><a href=\"#萃取法\" class=\"headerlink\" title=\"萃取法\"></a>萃取法</h4><blockquote>\n<p>萃取是一种知识与经验的整理技术</p>\n</blockquote>\n<p><strong>做工具做方法</strong></p>\n<h2 id=\"WOOP减少启动时间\"><a href=\"#WOOP减少启动时间\" class=\"headerlink\" title=\"WOOP减少启动时间\"></a>WOOP减少启动时间</h2><p>不谈行动里的时间管理都是纸老虎</p>\n<p>一段时间只做一件事（专注是最终目标）</p>\n<h4 id=\"大脑运行机制\"><a href=\"#大脑运行机制\" class=\"headerlink\" title=\"大脑运行机制\"></a>大脑运行机制</h4><ul>\n<li>目标意图</li>\n<li>执行意图 </li>\n</ul>\n<h4 id=\"减少启动时间\"><a href=\"#减少启动时间\" class=\"headerlink\" title=\"减少启动时间\"></a>减少启动时间</h4><ul>\n<li>减肥15-20斤</li>\n<li>建立自己的一套时间管理</li>\n<li>上厕所不看手机</li>\n<li>11:30睡觉</li>\n<li>7:30 起床看书半小时</li>\n</ul>\n<p>愿望：8月30日前减肥15斤-20斤</p>\n<p>结果：如果在8月30日</p>\n<p>障碍：（会遇到什么障碍）</p>\n<p>计划：（解决障碍）</p>\n<h2 id=\"时间统计\"><a href=\"#时间统计\" class=\"headerlink\" title=\"时间统计 *\"></a>时间统计 *</h2><h4 id=\"四步心法\"><a href=\"#四步心法\" class=\"headerlink\" title=\"四步心法\"></a>四步心法</h4><ul>\n<li><p>观察：观察并觉知到自己注意力转换</p>\n<p>开始并不容易，习惯之后成为自然</p>\n</li>\n<li><p>记录：观察到注意力转移时，立刻记录下来</p>\n<p>准备一个随身携带的小本子，如实记录，误差控制在15min之内</p>\n</li>\n<li><p>统计：按月或记录讲本子输入到excel</p>\n<p>输入的时候依据自己的人生观将时间分类，透视汇总时间。积累6个月的数据量</p>\n</li>\n<li><p>反馈：面对时间统计结果，接纳自己，培养习惯</p>\n<p>习惯的变化根本上时人格变化，心理学家告诉我们人格变化要1-3年的时间，不要操之过急</p>\n</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>我的人生目标时什么？我能花在人生目标上的时间有多少？</p>\n</blockquote>\n<p>清单革命</p>\n<p>WOOP思维心理学</p>\n<p>奇特的一生-格拉宁</p>\n<p>智识管理的技术-知识管理（卡片管理）</p>\n<p>罗伯特议事规则</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重新认识时间管理\"><a href=\"#重新认识时间管理\" class=\"headerlink\" title=\"重新认识时间管理\"></a>重新认识时间管理</h2><blockquote>\n<p>时间无法被管理，我们只能管理注意力</p>\n</blockquote>\n<p>效率= 工作量/时间</p>\n<p>工作时间= 启动时间+专注时间+碎片时间</p>\n<p>工作没有上限，工作会自动扩张</p>\n<p>你越擅长时间管理，你的时间就越来越少；最终你的生活会被工作占满</p>\n<p><em>自我支配时间增加，在心流状态下完成任务，在截止日期前交付</em></p>\n<p><code>HAVE TO</code>  VS.  <code>WANT TO</code></p>\n<p><strong>效率是结果，不是目标；专注是目标，产生幸福</strong></p>\n<h2 id=\"利用清单管理工作量\"><a href=\"#利用清单管理工作量\" class=\"headerlink\" title=\"利用清单管理工作量\"></a>利用清单管理工作量</h2><blockquote>\n<p>不管理工作量，任何时间管理技巧都无法拯救你</p>\n</blockquote>\n<p>工作量清单</p>\n<ul>\n<li>TO-DO-LIST</li>\n<li>NOT-TO-DO-LIST</li>\n<li>OTHERS-TO-DO-LIST</li>\n</ul>\n<p><strong>是否对你的实现目标（无论长期，还是短期）有益</strong></p>\n<p>解放自己，提升下属或者伙伴的业务能力</p>\n<p>重复、不重要的工作交出去（核查清单）</p>\n<p><strong>产生清单</strong>和方法与方法</p>\n<h4 id=\"萃取法\"><a href=\"#萃取法\" class=\"headerlink\" title=\"萃取法\"></a>萃取法</h4><blockquote>\n<p>萃取是一种知识与经验的整理技术</p>\n</blockquote>\n<p><strong>做工具做方法</strong></p>\n<h2 id=\"WOOP减少启动时间\"><a href=\"#WOOP减少启动时间\" class=\"headerlink\" title=\"WOOP减少启动时间\"></a>WOOP减少启动时间</h2><p>不谈行动里的时间管理都是纸老虎</p>\n<p>一段时间只做一件事（专注是最终目标）</p>\n<h4 id=\"大脑运行机制\"><a href=\"#大脑运行机制\" class=\"headerlink\" title=\"大脑运行机制\"></a>大脑运行机制</h4><ul>\n<li>目标意图</li>\n<li>执行意图 </li>\n</ul>\n<h4 id=\"减少启动时间\"><a href=\"#减少启动时间\" class=\"headerlink\" title=\"减少启动时间\"></a>减少启动时间</h4><ul>\n<li>减肥15-20斤</li>\n<li>建立自己的一套时间管理</li>\n<li>上厕所不看手机</li>\n<li>11:30睡觉</li>\n<li>7:30 起床看书半小时</li>\n</ul>\n<p>愿望：8月30日前减肥15斤-20斤</p>\n<p>结果：如果在8月30日</p>\n<p>障碍：（会遇到什么障碍）</p>\n<p>计划：（解决障碍）</p>\n<h2 id=\"时间统计\"><a href=\"#时间统计\" class=\"headerlink\" title=\"时间统计 *\"></a>时间统计 *</h2><h4 id=\"四步心法\"><a href=\"#四步心法\" class=\"headerlink\" title=\"四步心法\"></a>四步心法</h4><ul>\n<li><p>观察：观察并觉知到自己注意力转换</p>\n<p>开始并不容易，习惯之后成为自然</p>\n</li>\n<li><p>记录：观察到注意力转移时，立刻记录下来</p>\n<p>准备一个随身携带的小本子，如实记录，误差控制在15min之内</p>\n</li>\n<li><p>统计：按月或记录讲本子输入到excel</p>\n<p>输入的时候依据自己的人生观将时间分类，透视汇总时间。积累6个月的数据量</p>\n</li>\n<li><p>反馈：面对时间统计结果，接纳自己，培养习惯</p>\n<p>习惯的变化根本上时人格变化，心理学家告诉我们人格变化要1-3年的时间，不要操之过急</p>\n</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><blockquote>\n<p>我的人生目标时什么？我能花在人生目标上的时间有多少？</p>\n</blockquote>\n<p>清单革命</p>\n<p>WOOP思维心理学</p>\n<p>奇特的一生-格拉宁</p>\n<p>智识管理的技术-知识管理（卡片管理）</p>\n<p>罗伯特议事规则</p>\n"},{"_content":"","source":"_posts/LEVEL 1/高效工作/4 综合案例/4.1 综合练习.md","raw":"","slug":"LEVEL 1/高效工作/4 综合案例/4.1 综合练习","published":1,"date":"2020-06-25T03:10:24.444Z","updated":"2020-06-25T03:10:24.444Z","title":"LEVEL 1/高效工作/4 综合案例/4.1 综合练习","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wot000w3ns6213xf956","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"## 压力是什么？\n\n> 我们感受到的压力，是我们主观认为的，外部要求与自身拥有不平衡，这种不平衡就是压力\n\n\n\n## 压力的作用：压力会影响效率\n\n> 压力与效率的关系香一条 **倒U形曲线**，当压力很低和很高时，效率都低，只有当压力适度时，效率才会比较高\n\n- 没有压力带来的懒散\n\n- 适当压力带来的高效\n\n- 过大压力带来的焦虑不安\n\n  \n\n## 化压力为动力的方法\n\n> 找到对自己来说合适的压力水平\n\n1. 当压力太低时，适当加压\n2. 当压力太高时，适当减压\n\n尽量让自己处在倒U形曲线的中间部分","source":"_posts/LEVEL 1/压力管理/1 认识压力/1.1 你真的了解压力吗.md","raw":"## 压力是什么？\n\n> 我们感受到的压力，是我们主观认为的，外部要求与自身拥有不平衡，这种不平衡就是压力\n\n\n\n## 压力的作用：压力会影响效率\n\n> 压力与效率的关系香一条 **倒U形曲线**，当压力很低和很高时，效率都低，只有当压力适度时，效率才会比较高\n\n- 没有压力带来的懒散\n\n- 适当压力带来的高效\n\n- 过大压力带来的焦虑不安\n\n  \n\n## 化压力为动力的方法\n\n> 找到对自己来说合适的压力水平\n\n1. 当压力太低时，适当加压\n2. 当压力太高时，适当减压\n\n尽量让自己处在倒U形曲线的中间部分","slug":"LEVEL 1/压力管理/1 认识压力/1.1 你真的了解压力吗","published":1,"date":"2020-06-25T03:10:24.414Z","updated":"2020-06-25T03:10:24.415Z","title":"LEVEL 1/压力管理/1 认识压力/1.1 你真的了解压力吗","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp2000x3ns6015p7bnv","content":"<h2 id=\"压力是什么？\"><a href=\"#压力是什么？\" class=\"headerlink\" title=\"压力是什么？\"></a>压力是什么？</h2><blockquote>\n<p>我们感受到的压力，是我们主观认为的，外部要求与自身拥有不平衡，这种不平衡就是压力</p>\n</blockquote>\n<h2 id=\"压力的作用：压力会影响效率\"><a href=\"#压力的作用：压力会影响效率\" class=\"headerlink\" title=\"压力的作用：压力会影响效率\"></a>压力的作用：压力会影响效率</h2><blockquote>\n<p>压力与效率的关系香一条 <strong>倒U形曲线</strong>，当压力很低和很高时，效率都低，只有当压力适度时，效率才会比较高</p>\n</blockquote>\n<ul>\n<li><p>没有压力带来的懒散</p>\n</li>\n<li><p>适当压力带来的高效</p>\n</li>\n<li><p>过大压力带来的焦虑不安</p>\n</li>\n</ul>\n<h2 id=\"化压力为动力的方法\"><a href=\"#化压力为动力的方法\" class=\"headerlink\" title=\"化压力为动力的方法\"></a>化压力为动力的方法</h2><blockquote>\n<p>找到对自己来说合适的压力水平</p>\n</blockquote>\n<ol>\n<li>当压力太低时，适当加压</li>\n<li>当压力太高时，适当减压</li>\n</ol>\n<p>尽量让自己处在倒U形曲线的中间部分</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"压力是什么？\"><a href=\"#压力是什么？\" class=\"headerlink\" title=\"压力是什么？\"></a>压力是什么？</h2><blockquote>\n<p>我们感受到的压力，是我们主观认为的，外部要求与自身拥有不平衡，这种不平衡就是压力</p>\n</blockquote>\n<h2 id=\"压力的作用：压力会影响效率\"><a href=\"#压力的作用：压力会影响效率\" class=\"headerlink\" title=\"压力的作用：压力会影响效率\"></a>压力的作用：压力会影响效率</h2><blockquote>\n<p>压力与效率的关系香一条 <strong>倒U形曲线</strong>，当压力很低和很高时，效率都低，只有当压力适度时，效率才会比较高</p>\n</blockquote>\n<ul>\n<li><p>没有压力带来的懒散</p>\n</li>\n<li><p>适当压力带来的高效</p>\n</li>\n<li><p>过大压力带来的焦虑不安</p>\n</li>\n</ul>\n<h2 id=\"化压力为动力的方法\"><a href=\"#化压力为动力的方法\" class=\"headerlink\" title=\"化压力为动力的方法\"></a>化压力为动力的方法</h2><blockquote>\n<p>找到对自己来说合适的压力水平</p>\n</blockquote>\n<ol>\n<li>当压力太低时，适当加压</li>\n<li>当压力太高时，适当减压</li>\n</ol>\n<p>尽量让自己处在倒U形曲线的中间部分</p>\n"},{"_content":"## 压力的产生需要经过四步\n\n1. 压力源出现\n\n   压力是一个事件或情境，它是中性的没有好坏\n\n2. 初级评估，判断时间对我们是不是重要，是不是一个威胁（正向认知）\n\n3. 次级评估，判断我们是不是能够应对或者解决它（正向计划）\n\n4. 外部要求与自身拥有不平衡，感到有“压力”\n\n\n\n## 两个注意点\n\n> 改变能改变的，接受不能改变的\n\n- 压力与情绪紧密相关，但又有所不同。最后的压力反应可能包括情绪，但情绪不都是由压力产生的\n- 我们之所以能感受到压力，不是因为压力源本身，而是因为对压力源进行的两次主观评估\n\n**<u>压力管理想要做到的，不仅是管理压力带来的情绪，更是想从压力产生的过程入手，打破这种失衡的状态，从而让压力回归到我们期望的水平</u>**\n\n","source":"_posts/LEVEL 1/压力管理/1 认识压力/1.2 为什么会感觉到压力.md","raw":"## 压力的产生需要经过四步\n\n1. 压力源出现\n\n   压力是一个事件或情境，它是中性的没有好坏\n\n2. 初级评估，判断时间对我们是不是重要，是不是一个威胁（正向认知）\n\n3. 次级评估，判断我们是不是能够应对或者解决它（正向计划）\n\n4. 外部要求与自身拥有不平衡，感到有“压力”\n\n\n\n## 两个注意点\n\n> 改变能改变的，接受不能改变的\n\n- 压力与情绪紧密相关，但又有所不同。最后的压力反应可能包括情绪，但情绪不都是由压力产生的\n- 我们之所以能感受到压力，不是因为压力源本身，而是因为对压力源进行的两次主观评估\n\n**<u>压力管理想要做到的，不仅是管理压力带来的情绪，更是想从压力产生的过程入手，打破这种失衡的状态，从而让压力回归到我们期望的水平</u>**\n\n","slug":"LEVEL 1/压力管理/1 认识压力/1.2 为什么会感觉到压力","published":1,"date":"2020-06-25T03:10:24.415Z","updated":"2020-06-25T03:10:24.415Z","title":"LEVEL 1/压力管理/1 认识压力/1.2 为什么会感觉到压力","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp3000y3ns6aunmfmqx","content":"<h2 id=\"压力的产生需要经过四步\"><a href=\"#压力的产生需要经过四步\" class=\"headerlink\" title=\"压力的产生需要经过四步\"></a>压力的产生需要经过四步</h2><ol>\n<li><p>压力源出现</p>\n<p>压力是一个事件或情境，它是中性的没有好坏</p>\n</li>\n<li><p>初级评估，判断时间对我们是不是重要，是不是一个威胁（正向认知）</p>\n</li>\n<li><p>次级评估，判断我们是不是能够应对或者解决它（正向计划）</p>\n</li>\n<li><p>外部要求与自身拥有不平衡，感到有“压力”</p>\n</li>\n</ol>\n<h2 id=\"两个注意点\"><a href=\"#两个注意点\" class=\"headerlink\" title=\"两个注意点\"></a>两个注意点</h2><blockquote>\n<p>改变能改变的，接受不能改变的</p>\n</blockquote>\n<ul>\n<li>压力与情绪紧密相关，但又有所不同。最后的压力反应可能包括情绪，但情绪不都是由压力产生的</li>\n<li>我们之所以能感受到压力，不是因为压力源本身，而是因为对压力源进行的两次主观评估</li>\n</ul>\n<p><strong><u>压力管理想要做到的，不仅是管理压力带来的情绪，更是想从压力产生的过程入手，打破这种失衡的状态，从而让压力回归到我们期望的水平</u></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"压力的产生需要经过四步\"><a href=\"#压力的产生需要经过四步\" class=\"headerlink\" title=\"压力的产生需要经过四步\"></a>压力的产生需要经过四步</h2><ol>\n<li><p>压力源出现</p>\n<p>压力是一个事件或情境，它是中性的没有好坏</p>\n</li>\n<li><p>初级评估，判断时间对我们是不是重要，是不是一个威胁（正向认知）</p>\n</li>\n<li><p>次级评估，判断我们是不是能够应对或者解决它（正向计划）</p>\n</li>\n<li><p>外部要求与自身拥有不平衡，感到有“压力”</p>\n</li>\n</ol>\n<h2 id=\"两个注意点\"><a href=\"#两个注意点\" class=\"headerlink\" title=\"两个注意点\"></a>两个注意点</h2><blockquote>\n<p>改变能改变的，接受不能改变的</p>\n</blockquote>\n<ul>\n<li>压力与情绪紧密相关，但又有所不同。最后的压力反应可能包括情绪，但情绪不都是由压力产生的</li>\n<li>我们之所以能感受到压力，不是因为压力源本身，而是因为对压力源进行的两次主观评估</li>\n</ul>\n<p><strong><u>压力管理想要做到的，不仅是管理压力带来的情绪，更是想从压力产生的过程入手，打破这种失衡的状态，从而让压力回归到我们期望的水平</u></strong></p>\n"},{"_content":"## 记录压力的模版\n\n压力日记\n\n|         时间         |                    |\n| :------------------: | :----------------: |\n|        压力源        |                    |\n|    对压力源的认知    |                    |\n|    可用的应对资源    |                    |\n| 应对压力源的个人能力 |                    |\n|    生理和情绪反应    | 压力强度（0-10分） |\n|    采取的实际行动    | 工作效率（0-10分） |\n\n\n\n## 从五个角度复盘压力日记\n\n分析压力日记\n\n- 结合“压力强度”和“工作效率”，总结出对自己来说合适的压力水平是多少 （7）\n\n- 结合“生理和情绪反应”和“采取的实际行动”，看看自己偏向A型还是B型人格 （偏A型）\n\n- 分析“对压力源的认知”，总结自己的认知方式是否需要调整 （部分需要调整）\n\n- 结合“压力源”和“可用的应对资源”，总结：\n\n  对某一个压力源，是不是还需要争取到跟股东的应对资源\n\n- 结合“压力源”和“应对压力源的个人能力”，总结：\n\n  对某一个压力源，是不是还需要提升某些个人能力\n\n","source":"_posts/LEVEL 1/压力管理/2 识别压力/2.1 揭开你的压力真面目.md","raw":"## 记录压力的模版\n\n压力日记\n\n|         时间         |                    |\n| :------------------: | :----------------: |\n|        压力源        |                    |\n|    对压力源的认知    |                    |\n|    可用的应对资源    |                    |\n| 应对压力源的个人能力 |                    |\n|    生理和情绪反应    | 压力强度（0-10分） |\n|    采取的实际行动    | 工作效率（0-10分） |\n\n\n\n## 从五个角度复盘压力日记\n\n分析压力日记\n\n- 结合“压力强度”和“工作效率”，总结出对自己来说合适的压力水平是多少 （7）\n\n- 结合“生理和情绪反应”和“采取的实际行动”，看看自己偏向A型还是B型人格 （偏A型）\n\n- 分析“对压力源的认知”，总结自己的认知方式是否需要调整 （部分需要调整）\n\n- 结合“压力源”和“可用的应对资源”，总结：\n\n  对某一个压力源，是不是还需要争取到跟股东的应对资源\n\n- 结合“压力源”和“应对压力源的个人能力”，总结：\n\n  对某一个压力源，是不是还需要提升某些个人能力\n\n","slug":"LEVEL 1/压力管理/2 识别压力/2.1 揭开你的压力真面目","published":1,"date":"2020-06-25T03:10:24.419Z","updated":"2020-06-25T03:10:24.420Z","title":"LEVEL 1/压力管理/2 识别压力/2.1 揭开你的压力真面目","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp4000z3ns69szf1e0l","content":"<h2 id=\"记录压力的模版\"><a href=\"#记录压力的模版\" class=\"headerlink\" title=\"记录压力的模版\"></a>记录压力的模版</h2><p>压力日记</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">时间</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">压力源</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">对压力源的认知</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">可用的应对资源</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">应对压力源的个人能力</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">生理和情绪反应</td>\n<td align=\"center\">压力强度（0-10分）</td>\n</tr>\n<tr>\n<td align=\"center\">采取的实际行动</td>\n<td align=\"center\">工作效率（0-10分）</td>\n</tr>\n</tbody></table>\n<h2 id=\"从五个角度复盘压力日记\"><a href=\"#从五个角度复盘压力日记\" class=\"headerlink\" title=\"从五个角度复盘压力日记\"></a>从五个角度复盘压力日记</h2><p>分析压力日记</p>\n<ul>\n<li><p>结合“压力强度”和“工作效率”，总结出对自己来说合适的压力水平是多少 （7）</p>\n</li>\n<li><p>结合“生理和情绪反应”和“采取的实际行动”，看看自己偏向A型还是B型人格 （偏A型）</p>\n</li>\n<li><p>分析“对压力源的认知”，总结自己的认知方式是否需要调整 （部分需要调整）</p>\n</li>\n<li><p>结合“压力源”和“可用的应对资源”，总结：</p>\n<p>对某一个压力源，是不是还需要争取到跟股东的应对资源</p>\n</li>\n<li><p>结合“压力源”和“应对压力源的个人能力”，总结：</p>\n<p>对某一个压力源，是不是还需要提升某些个人能力</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"记录压力的模版\"><a href=\"#记录压力的模版\" class=\"headerlink\" title=\"记录压力的模版\"></a>记录压力的模版</h2><p>压力日记</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">时间</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">压力源</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">对压力源的认知</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">可用的应对资源</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">应对压力源的个人能力</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">生理和情绪反应</td>\n<td align=\"center\">压力强度（0-10分）</td>\n</tr>\n<tr>\n<td align=\"center\">采取的实际行动</td>\n<td align=\"center\">工作效率（0-10分）</td>\n</tr>\n</tbody></table>\n<h2 id=\"从五个角度复盘压力日记\"><a href=\"#从五个角度复盘压力日记\" class=\"headerlink\" title=\"从五个角度复盘压力日记\"></a>从五个角度复盘压力日记</h2><p>分析压力日记</p>\n<ul>\n<li><p>结合“压力强度”和“工作效率”，总结出对自己来说合适的压力水平是多少 （7）</p>\n</li>\n<li><p>结合“生理和情绪反应”和“采取的实际行动”，看看自己偏向A型还是B型人格 （偏A型）</p>\n</li>\n<li><p>分析“对压力源的认知”，总结自己的认知方式是否需要调整 （部分需要调整）</p>\n</li>\n<li><p>结合“压力源”和“可用的应对资源”，总结：</p>\n<p>对某一个压力源，是不是还需要争取到跟股东的应对资源</p>\n</li>\n<li><p>结合“压力源”和“应对压力源的个人能力”，总结：</p>\n<p>对某一个压力源，是不是还需要提升某些个人能力</p>\n</li>\n</ul>\n"},{"_content":"## 影响压力感知和评估的四大因素\n\n#### 人格类型\n\n表现为日常的行为方式：懒散、过于紧张等等\n\n#### 认知方式\n\n表现为对压力源的威胁性的评估、对自己应对压力的资源和个人能力的评估\n\n评估过度或过低\n\n#### 应对资源\n\n即应对压力的资源，表现为其他人的支持和帮助等等\n\n资源不足易感到压力，而充足资源会减轻这压力感\n\n#### 个人能力\n\n即应对压力时的个人能力，表现为有助于解决压力事件的能力\n\n*想要控制压力，第一步是：了解自己，知道自己是因为人格类型、认知、应对资源、个人能力哪个方面才产生压力，再对症下药*\n\n","source":"_posts/LEVEL 1/压力管理/1 认识压力/1.3 为什么有人总说压力山大.md","raw":"## 影响压力感知和评估的四大因素\n\n#### 人格类型\n\n表现为日常的行为方式：懒散、过于紧张等等\n\n#### 认知方式\n\n表现为对压力源的威胁性的评估、对自己应对压力的资源和个人能力的评估\n\n评估过度或过低\n\n#### 应对资源\n\n即应对压力的资源，表现为其他人的支持和帮助等等\n\n资源不足易感到压力，而充足资源会减轻这压力感\n\n#### 个人能力\n\n即应对压力时的个人能力，表现为有助于解决压力事件的能力\n\n*想要控制压力，第一步是：了解自己，知道自己是因为人格类型、认知、应对资源、个人能力哪个方面才产生压力，再对症下药*\n\n","slug":"LEVEL 1/压力管理/1 认识压力/1.3 为什么有人总说压力山大","published":1,"date":"2020-06-25T03:10:24.418Z","updated":"2020-06-25T03:10:24.418Z","title":"LEVEL 1/压力管理/1 认识压力/1.3 为什么有人总说压力山大","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp500103ns6ct5xc004","content":"<h2 id=\"影响压力感知和评估的四大因素\"><a href=\"#影响压力感知和评估的四大因素\" class=\"headerlink\" title=\"影响压力感知和评估的四大因素\"></a>影响压力感知和评估的四大因素</h2><h4 id=\"人格类型\"><a href=\"#人格类型\" class=\"headerlink\" title=\"人格类型\"></a>人格类型</h4><p>表现为日常的行为方式：懒散、过于紧张等等</p>\n<h4 id=\"认知方式\"><a href=\"#认知方式\" class=\"headerlink\" title=\"认知方式\"></a>认知方式</h4><p>表现为对压力源的威胁性的评估、对自己应对压力的资源和个人能力的评估</p>\n<p>评估过度或过低</p>\n<h4 id=\"应对资源\"><a href=\"#应对资源\" class=\"headerlink\" title=\"应对资源\"></a>应对资源</h4><p>即应对压力的资源，表现为其他人的支持和帮助等等</p>\n<p>资源不足易感到压力，而充足资源会减轻这压力感</p>\n<h4 id=\"个人能力\"><a href=\"#个人能力\" class=\"headerlink\" title=\"个人能力\"></a>个人能力</h4><p>即应对压力时的个人能力，表现为有助于解决压力事件的能力</p>\n<p><em>想要控制压力，第一步是：了解自己，知道自己是因为人格类型、认知、应对资源、个人能力哪个方面才产生压力，再对症下药</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"影响压力感知和评估的四大因素\"><a href=\"#影响压力感知和评估的四大因素\" class=\"headerlink\" title=\"影响压力感知和评估的四大因素\"></a>影响压力感知和评估的四大因素</h2><h4 id=\"人格类型\"><a href=\"#人格类型\" class=\"headerlink\" title=\"人格类型\"></a>人格类型</h4><p>表现为日常的行为方式：懒散、过于紧张等等</p>\n<h4 id=\"认知方式\"><a href=\"#认知方式\" class=\"headerlink\" title=\"认知方式\"></a>认知方式</h4><p>表现为对压力源的威胁性的评估、对自己应对压力的资源和个人能力的评估</p>\n<p>评估过度或过低</p>\n<h4 id=\"应对资源\"><a href=\"#应对资源\" class=\"headerlink\" title=\"应对资源\"></a>应对资源</h4><p>即应对压力的资源，表现为其他人的支持和帮助等等</p>\n<p>资源不足易感到压力，而充足资源会减轻这压力感</p>\n<h4 id=\"个人能力\"><a href=\"#个人能力\" class=\"headerlink\" title=\"个人能力\"></a>个人能力</h4><p>即应对压力时的个人能力，表现为有助于解决压力事件的能力</p>\n<p><em>想要控制压力，第一步是：了解自己，知道自己是因为人格类型、认知、应对资源、个人能力哪个方面才产生压力，再对症下药</em></p>\n"},{"_content":"## 人格类型和行为方式的关系\n\n人格类型不是一个可调整的因素，但**行为方式是可以调整的**\n\n## 两类人格的行为方式的调整\n\n#### A型\n\n- 放慢生活和工作的速度\n- 劳逸结合，使用工作间隙让自己多休息\n- 可以降低一些不切实际的要求\n\n#### B型\n\n- 在已有目标上对自己提高要求\n- 为自己设定新的目标来进行适当的加压\n- 把自己设定的flag告诉别人\n\n## A型和B型人格的两个说明点\n\n#### 1.遵循SMART原则\n\n- **Specific**，目标一定要明确不能模糊\n- **Measureable**，目标能够被量化和评价\n- **Attainable**，目标必须是经过努力可以实现的，不能太好高骛远\n- **Relevant**，目标与你的工作生活需要相关\n- **Time Bound**，必须有明确的截止期限\n\n#### 2. A型B型没有好坏之分，只是两种不同的人格类型","source":"_posts/LEVEL 1/压力管理/3 应对压力/3.1 方法一：调整行为方式.md","raw":"## 人格类型和行为方式的关系\n\n人格类型不是一个可调整的因素，但**行为方式是可以调整的**\n\n## 两类人格的行为方式的调整\n\n#### A型\n\n- 放慢生活和工作的速度\n- 劳逸结合，使用工作间隙让自己多休息\n- 可以降低一些不切实际的要求\n\n#### B型\n\n- 在已有目标上对自己提高要求\n- 为自己设定新的目标来进行适当的加压\n- 把自己设定的flag告诉别人\n\n## A型和B型人格的两个说明点\n\n#### 1.遵循SMART原则\n\n- **Specific**，目标一定要明确不能模糊\n- **Measureable**，目标能够被量化和评价\n- **Attainable**，目标必须是经过努力可以实现的，不能太好高骛远\n- **Relevant**，目标与你的工作生活需要相关\n- **Time Bound**，必须有明确的截止期限\n\n#### 2. A型B型没有好坏之分，只是两种不同的人格类型","slug":"LEVEL 1/压力管理/3 应对压力/3.1 方法一：调整行为方式","published":1,"date":"2020-06-25T03:10:24.420Z","updated":"2020-06-25T03:10:24.420Z","title":"LEVEL 1/压力管理/3 应对压力/3.1 方法一：调整行为方式","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp600113ns64lfh7nhf","content":"<h2 id=\"人格类型和行为方式的关系\"><a href=\"#人格类型和行为方式的关系\" class=\"headerlink\" title=\"人格类型和行为方式的关系\"></a>人格类型和行为方式的关系</h2><p>人格类型不是一个可调整的因素，但<strong>行为方式是可以调整的</strong></p>\n<h2 id=\"两类人格的行为方式的调整\"><a href=\"#两类人格的行为方式的调整\" class=\"headerlink\" title=\"两类人格的行为方式的调整\"></a>两类人格的行为方式的调整</h2><h4 id=\"A型\"><a href=\"#A型\" class=\"headerlink\" title=\"A型\"></a>A型</h4><ul>\n<li>放慢生活和工作的速度</li>\n<li>劳逸结合，使用工作间隙让自己多休息</li>\n<li>可以降低一些不切实际的要求</li>\n</ul>\n<h4 id=\"B型\"><a href=\"#B型\" class=\"headerlink\" title=\"B型\"></a>B型</h4><ul>\n<li>在已有目标上对自己提高要求</li>\n<li>为自己设定新的目标来进行适当的加压</li>\n<li>把自己设定的flag告诉别人</li>\n</ul>\n<h2 id=\"A型和B型人格的两个说明点\"><a href=\"#A型和B型人格的两个说明点\" class=\"headerlink\" title=\"A型和B型人格的两个说明点\"></a>A型和B型人格的两个说明点</h2><h4 id=\"1-遵循SMART原则\"><a href=\"#1-遵循SMART原则\" class=\"headerlink\" title=\"1.遵循SMART原则\"></a>1.遵循SMART原则</h4><ul>\n<li><strong>Specific</strong>，目标一定要明确不能模糊</li>\n<li><strong>Measureable</strong>，目标能够被量化和评价</li>\n<li><strong>Attainable</strong>，目标必须是经过努力可以实现的，不能太好高骛远</li>\n<li><strong>Relevant</strong>，目标与你的工作生活需要相关</li>\n<li><strong>Time Bound</strong>，必须有明确的截止期限</li>\n</ul>\n<h4 id=\"2-A型B型没有好坏之分，只是两种不同的人格类型\"><a href=\"#2-A型B型没有好坏之分，只是两种不同的人格类型\" class=\"headerlink\" title=\"2. A型B型没有好坏之分，只是两种不同的人格类型\"></a>2. A型B型没有好坏之分，只是两种不同的人格类型</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"人格类型和行为方式的关系\"><a href=\"#人格类型和行为方式的关系\" class=\"headerlink\" title=\"人格类型和行为方式的关系\"></a>人格类型和行为方式的关系</h2><p>人格类型不是一个可调整的因素，但<strong>行为方式是可以调整的</strong></p>\n<h2 id=\"两类人格的行为方式的调整\"><a href=\"#两类人格的行为方式的调整\" class=\"headerlink\" title=\"两类人格的行为方式的调整\"></a>两类人格的行为方式的调整</h2><h4 id=\"A型\"><a href=\"#A型\" class=\"headerlink\" title=\"A型\"></a>A型</h4><ul>\n<li>放慢生活和工作的速度</li>\n<li>劳逸结合，使用工作间隙让自己多休息</li>\n<li>可以降低一些不切实际的要求</li>\n</ul>\n<h4 id=\"B型\"><a href=\"#B型\" class=\"headerlink\" title=\"B型\"></a>B型</h4><ul>\n<li>在已有目标上对自己提高要求</li>\n<li>为自己设定新的目标来进行适当的加压</li>\n<li>把自己设定的flag告诉别人</li>\n</ul>\n<h2 id=\"A型和B型人格的两个说明点\"><a href=\"#A型和B型人格的两个说明点\" class=\"headerlink\" title=\"A型和B型人格的两个说明点\"></a>A型和B型人格的两个说明点</h2><h4 id=\"1-遵循SMART原则\"><a href=\"#1-遵循SMART原则\" class=\"headerlink\" title=\"1.遵循SMART原则\"></a>1.遵循SMART原则</h4><ul>\n<li><strong>Specific</strong>，目标一定要明确不能模糊</li>\n<li><strong>Measureable</strong>，目标能够被量化和评价</li>\n<li><strong>Attainable</strong>，目标必须是经过努力可以实现的，不能太好高骛远</li>\n<li><strong>Relevant</strong>，目标与你的工作生活需要相关</li>\n<li><strong>Time Bound</strong>，必须有明确的截止期限</li>\n</ul>\n<h4 id=\"2-A型B型没有好坏之分，只是两种不同的人格类型\"><a href=\"#2-A型B型没有好坏之分，只是两种不同的人格类型\" class=\"headerlink\" title=\"2. A型B型没有好坏之分，只是两种不同的人格类型\"></a>2. A型B型没有好坏之分，只是两种不同的人格类型</h4>"},{"_content":"## 改变认知方式是有效的\n\n> 从认知上将压力视为是一种有益于自己的反应\n\n## 质疑原由认知方式是有效的\n\n#### 三种质疑方法\n\n- 对原有认知的逻辑质疑\n\n  找出原有认知中，不合逻辑的推论进行质疑\n\n- 对原有认知的证据质疑\n\n  对支持原有认知的证据质疑，目的是让自己意识到那些证据并不一定可靠\n\n- 对原有认知的后果质疑\n\n  让自己意识到，原有的认知不仅不能帮助实现目标，反而会起到消极的作用，坚持原油的认知的时间越久，收到的压力困扰就会越久\n\n  \n\n","source":"_posts/LEVEL 1/压力管理/3 应对压力/3.2 方法二：改变认知方式.md","raw":"## 改变认知方式是有效的\n\n> 从认知上将压力视为是一种有益于自己的反应\n\n## 质疑原由认知方式是有效的\n\n#### 三种质疑方法\n\n- 对原有认知的逻辑质疑\n\n  找出原有认知中，不合逻辑的推论进行质疑\n\n- 对原有认知的证据质疑\n\n  对支持原有认知的证据质疑，目的是让自己意识到那些证据并不一定可靠\n\n- 对原有认知的后果质疑\n\n  让自己意识到，原有的认知不仅不能帮助实现目标，反而会起到消极的作用，坚持原油的认知的时间越久，收到的压力困扰就会越久\n\n  \n\n","slug":"LEVEL 1/压力管理/3 应对压力/3.2 方法二：改变认知方式","published":1,"date":"2020-06-25T03:10:24.420Z","updated":"2020-06-25T03:10:24.420Z","title":"LEVEL 1/压力管理/3 应对压力/3.2 方法二：改变认知方式","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp600123ns6cf9ledcg","content":"<h2 id=\"改变认知方式是有效的\"><a href=\"#改变认知方式是有效的\" class=\"headerlink\" title=\"改变认知方式是有效的\"></a>改变认知方式是有效的</h2><blockquote>\n<p>从认知上将压力视为是一种有益于自己的反应</p>\n</blockquote>\n<h2 id=\"质疑原由认知方式是有效的\"><a href=\"#质疑原由认知方式是有效的\" class=\"headerlink\" title=\"质疑原由认知方式是有效的\"></a>质疑原由认知方式是有效的</h2><h4 id=\"三种质疑方法\"><a href=\"#三种质疑方法\" class=\"headerlink\" title=\"三种质疑方法\"></a>三种质疑方法</h4><ul>\n<li><p>对原有认知的逻辑质疑</p>\n<p>找出原有认知中，不合逻辑的推论进行质疑</p>\n</li>\n<li><p>对原有认知的证据质疑</p>\n<p>对支持原有认知的证据质疑，目的是让自己意识到那些证据并不一定可靠</p>\n</li>\n<li><p>对原有认知的后果质疑</p>\n<p>让自己意识到，原有的认知不仅不能帮助实现目标，反而会起到消极的作用，坚持原油的认知的时间越久，收到的压力困扰就会越久</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"改变认知方式是有效的\"><a href=\"#改变认知方式是有效的\" class=\"headerlink\" title=\"改变认知方式是有效的\"></a>改变认知方式是有效的</h2><blockquote>\n<p>从认知上将压力视为是一种有益于自己的反应</p>\n</blockquote>\n<h2 id=\"质疑原由认知方式是有效的\"><a href=\"#质疑原由认知方式是有效的\" class=\"headerlink\" title=\"质疑原由认知方式是有效的\"></a>质疑原由认知方式是有效的</h2><h4 id=\"三种质疑方法\"><a href=\"#三种质疑方法\" class=\"headerlink\" title=\"三种质疑方法\"></a>三种质疑方法</h4><ul>\n<li><p>对原有认知的逻辑质疑</p>\n<p>找出原有认知中，不合逻辑的推论进行质疑</p>\n</li>\n<li><p>对原有认知的证据质疑</p>\n<p>对支持原有认知的证据质疑，目的是让自己意识到那些证据并不一定可靠</p>\n</li>\n<li><p>对原有认知的后果质疑</p>\n<p>让自己意识到，原有的认知不仅不能帮助实现目标，反而会起到消极的作用，坚持原油的认知的时间越久，收到的压力困扰就会越久</p>\n</li>\n</ul>\n"},{"_content":"## 增加对应资源\n\n#### 增加应对压力的资源，有三个方面\n\n1. 良好的身体基础\n\n   充足的睡眠，合理的饮食，适当的锻炼\n\n2. 精神上的支持\n\n   1）寻同事、朋友、家人精神上的支持与鼓励\n\n   2）参加应对相同压力源的自助群体，得到精神上的归属感\n\n3. 行动上的支持\n\n   请求上司、同事、朋友、家人行动上的帮助","source":"_posts/LEVEL 1/压力管理/3 应对压力/3.3 方法三：增加应对资源.md","raw":"## 增加对应资源\n\n#### 增加应对压力的资源，有三个方面\n\n1. 良好的身体基础\n\n   充足的睡眠，合理的饮食，适当的锻炼\n\n2. 精神上的支持\n\n   1）寻同事、朋友、家人精神上的支持与鼓励\n\n   2）参加应对相同压力源的自助群体，得到精神上的归属感\n\n3. 行动上的支持\n\n   请求上司、同事、朋友、家人行动上的帮助","slug":"LEVEL 1/压力管理/3 应对压力/3.3 方法三：增加应对资源","published":1,"date":"2020-06-25T03:10:24.420Z","updated":"2020-06-25T03:10:24.421Z","title":"LEVEL 1/压力管理/3 应对压力/3.3 方法三：增加应对资源","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wp700133ns68wbw2exr","content":"<h2 id=\"增加对应资源\"><a href=\"#增加对应资源\" class=\"headerlink\" title=\"增加对应资源\"></a>增加对应资源</h2><h4 id=\"增加应对压力的资源，有三个方面\"><a href=\"#增加应对压力的资源，有三个方面\" class=\"headerlink\" title=\"增加应对压力的资源，有三个方面\"></a>增加应对压力的资源，有三个方面</h4><ol>\n<li><p>良好的身体基础</p>\n<p>充足的睡眠，合理的饮食，适当的锻炼</p>\n</li>\n<li><p>精神上的支持</p>\n<p>1）寻同事、朋友、家人精神上的支持与鼓励</p>\n<p>2）参加应对相同压力源的自助群体，得到精神上的归属感</p>\n</li>\n<li><p>行动上的支持</p>\n<p>请求上司、同事、朋友、家人行动上的帮助</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"增加对应资源\"><a href=\"#增加对应资源\" class=\"headerlink\" title=\"增加对应资源\"></a>增加对应资源</h2><h4 id=\"增加应对压力的资源，有三个方面\"><a href=\"#增加应对压力的资源，有三个方面\" class=\"headerlink\" title=\"增加应对压力的资源，有三个方面\"></a>增加应对压力的资源，有三个方面</h4><ol>\n<li><p>良好的身体基础</p>\n<p>充足的睡眠，合理的饮食，适当的锻炼</p>\n</li>\n<li><p>精神上的支持</p>\n<p>1）寻同事、朋友、家人精神上的支持与鼓励</p>\n<p>2）参加应对相同压力源的自助群体，得到精神上的归属感</p>\n</li>\n<li><p>行动上的支持</p>\n<p>请求上司、同事、朋友、家人行动上的帮助</p>\n</li>\n</ol>\n"},{"_content":"## 应对压力的三种可提高的能力\n\n1. #### 提升时间管理能力\n\n   月历管理工作事项（清单等等），不要记在脑子里，释放大脑资源\n\n   \n\n2. #### 提升沟通能力和洞察他人行为的能力\n\n   > 一个人会有什么样的行为，取决于他是否知道、是否愿意以及是否有能力\n\n   \n\n   使用行为分析模型\n\n   1. 角色认知（知）：是否清楚自己要做什么，以及相应要求\n\n   2. 行为意愿（愿）：了解要做什么之后，是否有意愿去做\n\n   3. 行为能力（能）：具备了意愿，是否有足够的能力来完成\n\n      \n\n3. #### 提升找到本质问题能力\n\n   > 确认自己对问题的理解是正确的\n\n   \n\n   找到本质问题的小技巧是，通过向对方提问，确保双方同一个问题的理解是一致的\n\n## 提升控制感\n\n#### 1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\n\n#### 2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\n\n","source":"_posts/LEVEL 1/压力管理/3 应对压力/3.4 方法四：提升应对能力.md","raw":"## 应对压力的三种可提高的能力\n\n1. #### 提升时间管理能力\n\n   月历管理工作事项（清单等等），不要记在脑子里，释放大脑资源\n\n   \n\n2. #### 提升沟通能力和洞察他人行为的能力\n\n   > 一个人会有什么样的行为，取决于他是否知道、是否愿意以及是否有能力\n\n   \n\n   使用行为分析模型\n\n   1. 角色认知（知）：是否清楚自己要做什么，以及相应要求\n\n   2. 行为意愿（愿）：了解要做什么之后，是否有意愿去做\n\n   3. 行为能力（能）：具备了意愿，是否有足够的能力来完成\n\n      \n\n3. #### 提升找到本质问题能力\n\n   > 确认自己对问题的理解是正确的\n\n   \n\n   找到本质问题的小技巧是，通过向对方提问，确保双方同一个问题的理解是一致的\n\n## 提升控制感\n\n#### 1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\n\n#### 2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\n\n","slug":"LEVEL 1/压力管理/3 应对压力/3.4 方法四：提升应对能力","published":1,"date":"2020-06-25T03:10:24.421Z","updated":"2020-06-25T03:10:24.422Z","title":"LEVEL 1/压力管理/3 应对压力/3.4 方法四：提升应对能力","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpa00143ns64m486knl","content":"<h2 id=\"应对压力的三种可提高的能力\"><a href=\"#应对压力的三种可提高的能力\" class=\"headerlink\" title=\"应对压力的三种可提高的能力\"></a>应对压力的三种可提高的能力</h2><ol>\n<li><h4 id=\"提升时间管理能力\"><a href=\"#提升时间管理能力\" class=\"headerlink\" title=\"提升时间管理能力\"></a>提升时间管理能力</h4><p>月历管理工作事项（清单等等），不要记在脑子里，释放大脑资源</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h4 id=\"提升沟通能力和洞察他人行为的能力\"><a href=\"#提升沟通能力和洞察他人行为的能力\" class=\"headerlink\" title=\"提升沟通能力和洞察他人行为的能力\"></a>提升沟通能力和洞察他人行为的能力</h4><blockquote>\n<p>一个人会有什么样的行为，取决于他是否知道、是否愿意以及是否有能力</p>\n</blockquote>\n</li>\n</ol>\n<p>   使用行为分析模型</p>\n<ol>\n<li><p>角色认知（知）：是否清楚自己要做什么，以及相应要求</p>\n</li>\n<li><p>行为意愿（愿）：了解要做什么之后，是否有意愿去做</p>\n</li>\n<li><p>行为能力（能）：具备了意愿，是否有足够的能力来完成</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h4 id=\"提升找到本质问题能力\"><a href=\"#提升找到本质问题能力\" class=\"headerlink\" title=\"提升找到本质问题能力\"></a>提升找到本质问题能力</h4><blockquote>\n<p>确认自己对问题的理解是正确的</p>\n</blockquote>\n</li>\n</ol>\n<p>   找到本质问题的小技巧是，通过向对方提问，确保双方同一个问题的理解是一致的</p>\n<h2 id=\"提升控制感\"><a href=\"#提升控制感\" class=\"headerlink\" title=\"提升控制感\"></a>提升控制感</h2><h4 id=\"1-在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\"><a href=\"#1-在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\" class=\"headerlink\" title=\"1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\"></a>1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感</h4><h4 id=\"2-临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\"><a href=\"#2-临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\" class=\"headerlink\" title=\"2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\"></a>2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应对压力的三种可提高的能力\"><a href=\"#应对压力的三种可提高的能力\" class=\"headerlink\" title=\"应对压力的三种可提高的能力\"></a>应对压力的三种可提高的能力</h2><ol>\n<li><h4 id=\"提升时间管理能力\"><a href=\"#提升时间管理能力\" class=\"headerlink\" title=\"提升时间管理能力\"></a>提升时间管理能力</h4><p>月历管理工作事项（清单等等），不要记在脑子里，释放大脑资源</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h4 id=\"提升沟通能力和洞察他人行为的能力\"><a href=\"#提升沟通能力和洞察他人行为的能力\" class=\"headerlink\" title=\"提升沟通能力和洞察他人行为的能力\"></a>提升沟通能力和洞察他人行为的能力</h4><blockquote>\n<p>一个人会有什么样的行为，取决于他是否知道、是否愿意以及是否有能力</p>\n</blockquote>\n</li>\n</ol>\n<p>   使用行为分析模型</p>\n<ol>\n<li><p>角色认知（知）：是否清楚自己要做什么，以及相应要求</p>\n</li>\n<li><p>行为意愿（愿）：了解要做什么之后，是否有意愿去做</p>\n</li>\n<li><p>行为能力（能）：具备了意愿，是否有足够的能力来完成</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h4 id=\"提升找到本质问题能力\"><a href=\"#提升找到本质问题能力\" class=\"headerlink\" title=\"提升找到本质问题能力\"></a>提升找到本质问题能力</h4><blockquote>\n<p>确认自己对问题的理解是正确的</p>\n</blockquote>\n</li>\n</ol>\n<p>   找到本质问题的小技巧是，通过向对方提问，确保双方同一个问题的理解是一致的</p>\n<h2 id=\"提升控制感\"><a href=\"#提升控制感\" class=\"headerlink\" title=\"提升控制感\"></a>提升控制感</h2><h4 id=\"1-在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\"><a href=\"#1-在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\" class=\"headerlink\" title=\"1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感\"></a>1. 在日常生活中培养掌控感，为自己设立一些较小的、较容易达到的目标，完成目标后鼓励和肯定自己，并记住在完成目标时的成就感</h4><h4 id=\"2-临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\"><a href=\"#2-临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\" class=\"headerlink\" title=\"2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感\"></a>2. 临场压力很大，需要短暂提升掌控感时，可以回忆自己曾经某次处于优势地位的情景，唤醒类似的掌控感</h4>"},{"_content":"## 误区一：时间管理，就是制定完美的时间\n\n> 时间管理不仅是一个时间表，它体现了自己的时间观\n\n#### 关键点\n\n- 时间表不是将自己的时间安排的满满当当\n- 优化之前，先了解自己的时间观。需要决定把时间应该花在哪些方面\n\n#### 我要怎么做\n\n1. 了解自己的时间观\n2. 先做时间记录，以此来调整时间管理，作出适合自己的时间分配\n\n\n## 误区二：时间管理，就是提升工作效率\n\n> 时间管理并不只是关于效率，而是关于价值\n\n#### 关键点\n\n- 即使是同样的事情，再不同的时间段，思考的产出是完全不同的（`一天的黄金时间`）\n\n- 反而是一些不用思考的重复工作，恰恰有可能一直显得高效，把它安排再几乎任何时间都可以完成\n\n- *我们要把目光从“效率”上拿来，转而关注“价值”，看看自己一天做的任务价值产出有多大* ,**把高价值的事情安排在恰当的时间，充分发挥时间的价值**\n\n#### 我要怎么做\n\n参考一天的黄金时间，丢掉效率导向，以价值导向来分配时间\n\n1. 将任务分类为高价值任务及重复任务\n2. 将高价值的事情安排在恰当的时间    \n\n\n## 误区三：时间管理好了，就能同时处理多个任务\n\n> 同时处理多件事只是一种错觉，一心多用是个伪命题。研究发现：一心多用实际上是大脑前额叶再处理事情时，把资源快速的从一件事切换到另一件事，这些切换需要时间，由于切换时间很短，我们难以察觉，产生了一心多用的错觉。\n\n#### 关键点\n\n- 如果是需要专注思考解决问题的工作，一心多用的方式会把时间消耗在切换任务上，反而降低了效率。\n\n- 如果的确需要多任务处理，该怎么办呢？\n  借助一个可靠的外部系统。需要一些有效的管理工具，来让这些信息及时得到处理。\n\n#### 我要怎么做\n\n1. 在认知上改变：一心多用，是一种错觉，可能会导致消耗在切换任务上。\n2. 借助可靠的外部系统可以帮助我处理好任务，但现在我需要做的是：记录并分析自己的时间规律，以便搭建自己的时间管理系统。\n\n\n## 我的时间误区\n\n| 时间管理误区                       | 是/否有 | 举例                                                         | 如何解决                                               | 备注               |\n| ---------------------------------- | ------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------ |\n| 时间管理，就是制定完美的时间       | 是      | 这次离职在家打算给自己3-6个月的时间调整心态身体与学习，开始做了一个时间表，学习、健身、休闲方面的，执行下来发现好累，无法继续下去。满满当当的 | 先了解自己的真正的价值需求，并开始记录时间，调整时间表 | 参考一天的黄金时间 |\n| 时间管理，就是提升工作效率         | 是      | 之前工作中，前阵子做算法练习，计划一天做学习多少算法类型，越多越好。最后发现其实只是当时机械的理解了，其实并没有真正的内化 | 多并不一定会是效率。分析并选择更有价值部分来重点学习   | --                 |\n| 时间管理好了，就能同时处理多个任务 | 否      | /                                                            | /                                                      | 有多任务处理的要求 |\n\n\n\n## 总结\n\n1. 做自己时间记录\n2. 分析自己时间记录\n3. 纠正时间管理的错误认识","source":"_posts/LEVEL 1/时间管理/1 认识时间管理/1.1 时间管理的误区.md","raw":"## 误区一：时间管理，就是制定完美的时间\n\n> 时间管理不仅是一个时间表，它体现了自己的时间观\n\n#### 关键点\n\n- 时间表不是将自己的时间安排的满满当当\n- 优化之前，先了解自己的时间观。需要决定把时间应该花在哪些方面\n\n#### 我要怎么做\n\n1. 了解自己的时间观\n2. 先做时间记录，以此来调整时间管理，作出适合自己的时间分配\n\n\n## 误区二：时间管理，就是提升工作效率\n\n> 时间管理并不只是关于效率，而是关于价值\n\n#### 关键点\n\n- 即使是同样的事情，再不同的时间段，思考的产出是完全不同的（`一天的黄金时间`）\n\n- 反而是一些不用思考的重复工作，恰恰有可能一直显得高效，把它安排再几乎任何时间都可以完成\n\n- *我们要把目光从“效率”上拿来，转而关注“价值”，看看自己一天做的任务价值产出有多大* ,**把高价值的事情安排在恰当的时间，充分发挥时间的价值**\n\n#### 我要怎么做\n\n参考一天的黄金时间，丢掉效率导向，以价值导向来分配时间\n\n1. 将任务分类为高价值任务及重复任务\n2. 将高价值的事情安排在恰当的时间    \n\n\n## 误区三：时间管理好了，就能同时处理多个任务\n\n> 同时处理多件事只是一种错觉，一心多用是个伪命题。研究发现：一心多用实际上是大脑前额叶再处理事情时，把资源快速的从一件事切换到另一件事，这些切换需要时间，由于切换时间很短，我们难以察觉，产生了一心多用的错觉。\n\n#### 关键点\n\n- 如果是需要专注思考解决问题的工作，一心多用的方式会把时间消耗在切换任务上，反而降低了效率。\n\n- 如果的确需要多任务处理，该怎么办呢？\n  借助一个可靠的外部系统。需要一些有效的管理工具，来让这些信息及时得到处理。\n\n#### 我要怎么做\n\n1. 在认知上改变：一心多用，是一种错觉，可能会导致消耗在切换任务上。\n2. 借助可靠的外部系统可以帮助我处理好任务，但现在我需要做的是：记录并分析自己的时间规律，以便搭建自己的时间管理系统。\n\n\n## 我的时间误区\n\n| 时间管理误区                       | 是/否有 | 举例                                                         | 如何解决                                               | 备注               |\n| ---------------------------------- | ------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------ |\n| 时间管理，就是制定完美的时间       | 是      | 这次离职在家打算给自己3-6个月的时间调整心态身体与学习，开始做了一个时间表，学习、健身、休闲方面的，执行下来发现好累，无法继续下去。满满当当的 | 先了解自己的真正的价值需求，并开始记录时间，调整时间表 | 参考一天的黄金时间 |\n| 时间管理，就是提升工作效率         | 是      | 之前工作中，前阵子做算法练习，计划一天做学习多少算法类型，越多越好。最后发现其实只是当时机械的理解了，其实并没有真正的内化 | 多并不一定会是效率。分析并选择更有价值部分来重点学习   | --                 |\n| 时间管理好了，就能同时处理多个任务 | 否      | /                                                            | /                                                      | 有多任务处理的要求 |\n\n\n\n## 总结\n\n1. 做自己时间记录\n2. 分析自己时间记录\n3. 纠正时间管理的错误认识","slug":"LEVEL 1/时间管理/1 认识时间管理/1.1 时间管理的误区","published":1,"date":"2020-06-25T03:10:24.430Z","updated":"2020-06-25T03:10:24.430Z","title":"LEVEL 1/时间管理/1 认识时间管理/1.1 时间管理的误区","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpb00153ns64l2707ko","content":"<h2 id=\"误区一：时间管理，就是制定完美的时间\"><a href=\"#误区一：时间管理，就是制定完美的时间\" class=\"headerlink\" title=\"误区一：时间管理，就是制定完美的时间\"></a>误区一：时间管理，就是制定完美的时间</h2><blockquote>\n<p>时间管理不仅是一个时间表，它体现了自己的时间观</p>\n</blockquote>\n<h4 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li>时间表不是将自己的时间安排的满满当当</li>\n<li>优化之前，先了解自己的时间观。需要决定把时间应该花在哪些方面</li>\n</ul>\n<h4 id=\"我要怎么做\"><a href=\"#我要怎么做\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><ol>\n<li>了解自己的时间观</li>\n<li>先做时间记录，以此来调整时间管理，作出适合自己的时间分配</li>\n</ol>\n<h2 id=\"误区二：时间管理，就是提升工作效率\"><a href=\"#误区二：时间管理，就是提升工作效率\" class=\"headerlink\" title=\"误区二：时间管理，就是提升工作效率\"></a>误区二：时间管理，就是提升工作效率</h2><blockquote>\n<p>时间管理并不只是关于效率，而是关于价值</p>\n</blockquote>\n<h4 id=\"关键点-1\"><a href=\"#关键点-1\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li><p>即使是同样的事情，再不同的时间段，思考的产出是完全不同的（<code>一天的黄金时间</code>）</p>\n</li>\n<li><p>反而是一些不用思考的重复工作，恰恰有可能一直显得高效，把它安排再几乎任何时间都可以完成</p>\n</li>\n<li><p><em>我们要把目光从“效率”上拿来，转而关注“价值”，看看自己一天做的任务价值产出有多大</em> ,<strong>把高价值的事情安排在恰当的时间，充分发挥时间的价值</strong></p>\n</li>\n</ul>\n<h4 id=\"我要怎么做-1\"><a href=\"#我要怎么做-1\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><p>参考一天的黄金时间，丢掉效率导向，以价值导向来分配时间</p>\n<ol>\n<li>将任务分类为高价值任务及重复任务</li>\n<li>将高价值的事情安排在恰当的时间    </li>\n</ol>\n<h2 id=\"误区三：时间管理好了，就能同时处理多个任务\"><a href=\"#误区三：时间管理好了，就能同时处理多个任务\" class=\"headerlink\" title=\"误区三：时间管理好了，就能同时处理多个任务\"></a>误区三：时间管理好了，就能同时处理多个任务</h2><blockquote>\n<p>同时处理多件事只是一种错觉，一心多用是个伪命题。研究发现：一心多用实际上是大脑前额叶再处理事情时，把资源快速的从一件事切换到另一件事，这些切换需要时间，由于切换时间很短，我们难以察觉，产生了一心多用的错觉。</p>\n</blockquote>\n<h4 id=\"关键点-2\"><a href=\"#关键点-2\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li><p>如果是需要专注思考解决问题的工作，一心多用的方式会把时间消耗在切换任务上，反而降低了效率。</p>\n</li>\n<li><p>如果的确需要多任务处理，该怎么办呢？<br>借助一个可靠的外部系统。需要一些有效的管理工具，来让这些信息及时得到处理。</p>\n</li>\n</ul>\n<h4 id=\"我要怎么做-2\"><a href=\"#我要怎么做-2\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><ol>\n<li>在认知上改变：一心多用，是一种错觉，可能会导致消耗在切换任务上。</li>\n<li>借助可靠的外部系统可以帮助我处理好任务，但现在我需要做的是：记录并分析自己的时间规律，以便搭建自己的时间管理系统。</li>\n</ol>\n<h2 id=\"我的时间误区\"><a href=\"#我的时间误区\" class=\"headerlink\" title=\"我的时间误区\"></a>我的时间误区</h2><table>\n<thead>\n<tr>\n<th>时间管理误区</th>\n<th>是/否有</th>\n<th>举例</th>\n<th>如何解决</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>时间管理，就是制定完美的时间</td>\n<td>是</td>\n<td>这次离职在家打算给自己3-6个月的时间调整心态身体与学习，开始做了一个时间表，学习、健身、休闲方面的，执行下来发现好累，无法继续下去。满满当当的</td>\n<td>先了解自己的真正的价值需求，并开始记录时间，调整时间表</td>\n<td>参考一天的黄金时间</td>\n</tr>\n<tr>\n<td>时间管理，就是提升工作效率</td>\n<td>是</td>\n<td>之前工作中，前阵子做算法练习，计划一天做学习多少算法类型，越多越好。最后发现其实只是当时机械的理解了，其实并没有真正的内化</td>\n<td>多并不一定会是效率。分析并选择更有价值部分来重点学习</td>\n<td>–</td>\n</tr>\n<tr>\n<td>时间管理好了，就能同时处理多个任务</td>\n<td>否</td>\n<td>/</td>\n<td>/</td>\n<td>有多任务处理的要求</td>\n</tr>\n</tbody></table>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>做自己时间记录</li>\n<li>分析自己时间记录</li>\n<li>纠正时间管理的错误认识</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"误区一：时间管理，就是制定完美的时间\"><a href=\"#误区一：时间管理，就是制定完美的时间\" class=\"headerlink\" title=\"误区一：时间管理，就是制定完美的时间\"></a>误区一：时间管理，就是制定完美的时间</h2><blockquote>\n<p>时间管理不仅是一个时间表，它体现了自己的时间观</p>\n</blockquote>\n<h4 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li>时间表不是将自己的时间安排的满满当当</li>\n<li>优化之前，先了解自己的时间观。需要决定把时间应该花在哪些方面</li>\n</ul>\n<h4 id=\"我要怎么做\"><a href=\"#我要怎么做\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><ol>\n<li>了解自己的时间观</li>\n<li>先做时间记录，以此来调整时间管理，作出适合自己的时间分配</li>\n</ol>\n<h2 id=\"误区二：时间管理，就是提升工作效率\"><a href=\"#误区二：时间管理，就是提升工作效率\" class=\"headerlink\" title=\"误区二：时间管理，就是提升工作效率\"></a>误区二：时间管理，就是提升工作效率</h2><blockquote>\n<p>时间管理并不只是关于效率，而是关于价值</p>\n</blockquote>\n<h4 id=\"关键点-1\"><a href=\"#关键点-1\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li><p>即使是同样的事情，再不同的时间段，思考的产出是完全不同的（<code>一天的黄金时间</code>）</p>\n</li>\n<li><p>反而是一些不用思考的重复工作，恰恰有可能一直显得高效，把它安排再几乎任何时间都可以完成</p>\n</li>\n<li><p><em>我们要把目光从“效率”上拿来，转而关注“价值”，看看自己一天做的任务价值产出有多大</em> ,<strong>把高价值的事情安排在恰当的时间，充分发挥时间的价值</strong></p>\n</li>\n</ul>\n<h4 id=\"我要怎么做-1\"><a href=\"#我要怎么做-1\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><p>参考一天的黄金时间，丢掉效率导向，以价值导向来分配时间</p>\n<ol>\n<li>将任务分类为高价值任务及重复任务</li>\n<li>将高价值的事情安排在恰当的时间    </li>\n</ol>\n<h2 id=\"误区三：时间管理好了，就能同时处理多个任务\"><a href=\"#误区三：时间管理好了，就能同时处理多个任务\" class=\"headerlink\" title=\"误区三：时间管理好了，就能同时处理多个任务\"></a>误区三：时间管理好了，就能同时处理多个任务</h2><blockquote>\n<p>同时处理多件事只是一种错觉，一心多用是个伪命题。研究发现：一心多用实际上是大脑前额叶再处理事情时，把资源快速的从一件事切换到另一件事，这些切换需要时间，由于切换时间很短，我们难以察觉，产生了一心多用的错觉。</p>\n</blockquote>\n<h4 id=\"关键点-2\"><a href=\"#关键点-2\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ul>\n<li><p>如果是需要专注思考解决问题的工作，一心多用的方式会把时间消耗在切换任务上，反而降低了效率。</p>\n</li>\n<li><p>如果的确需要多任务处理，该怎么办呢？<br>借助一个可靠的外部系统。需要一些有效的管理工具，来让这些信息及时得到处理。</p>\n</li>\n</ul>\n<h4 id=\"我要怎么做-2\"><a href=\"#我要怎么做-2\" class=\"headerlink\" title=\"我要怎么做\"></a>我要怎么做</h4><ol>\n<li>在认知上改变：一心多用，是一种错觉，可能会导致消耗在切换任务上。</li>\n<li>借助可靠的外部系统可以帮助我处理好任务，但现在我需要做的是：记录并分析自己的时间规律，以便搭建自己的时间管理系统。</li>\n</ol>\n<h2 id=\"我的时间误区\"><a href=\"#我的时间误区\" class=\"headerlink\" title=\"我的时间误区\"></a>我的时间误区</h2><table>\n<thead>\n<tr>\n<th>时间管理误区</th>\n<th>是/否有</th>\n<th>举例</th>\n<th>如何解决</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>时间管理，就是制定完美的时间</td>\n<td>是</td>\n<td>这次离职在家打算给自己3-6个月的时间调整心态身体与学习，开始做了一个时间表，学习、健身、休闲方面的，执行下来发现好累，无法继续下去。满满当当的</td>\n<td>先了解自己的真正的价值需求，并开始记录时间，调整时间表</td>\n<td>参考一天的黄金时间</td>\n</tr>\n<tr>\n<td>时间管理，就是提升工作效率</td>\n<td>是</td>\n<td>之前工作中，前阵子做算法练习，计划一天做学习多少算法类型，越多越好。最后发现其实只是当时机械的理解了，其实并没有真正的内化</td>\n<td>多并不一定会是效率。分析并选择更有价值部分来重点学习</td>\n<td>–</td>\n</tr>\n<tr>\n<td>时间管理好了，就能同时处理多个任务</td>\n<td>否</td>\n<td>/</td>\n<td>/</td>\n<td>有多任务处理的要求</td>\n</tr>\n</tbody></table>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>做自己时间记录</li>\n<li>分析自己时间记录</li>\n<li>纠正时间管理的错误认识</li>\n</ol>\n"},{"_content":"## 什么是时间观\n> [棉花糖实验](https://baike.baidu.com/tashuo/browse/content?id=0973544b769d9226d67cdc85&lemmaId=15659236&fromLemmaModule=pcBottom)\n\n#### 津巴多时间观\n\n> 时间观分为过去、现在、将来三个维度。\n>\n> 对时间观不同倾向的人，无论是言语、行为、决策，都会是完全不同的\n\n- 过去\n  - 消极过去时间观\n  \n    总是回忆人生中的负面经历，并沉浸其中无法自拔\n  \n  - 积极过去时间观\n  \n    善于从过去的经历中吸取养分\n- 现在 \n\t- 宿命主义当下时间观\n\t\n\t  认为万事皆注定、命运由不得自己\n\t\n\t- 享乐主义当下时间观\n\t\n\t  尽情享受当下，幸福感很高；但自控能力差\n- 未来\n\t- 未来导向时间观（张一鸣强调的“延迟满足”）\n\t\n\t  善于规划，为了达成未来目标愿意放弃当下的娱乐\n\t\n\t- 超未来时间观\n\t\n\t  坚信人会有来世，可能会做出一些比较极端的行为\n\n*我们会在多个时间观上都有倾向，它们之间是相互影响的*\n\n##  时间观可以如何应用？\n\n> 一方面改变和调整自己，一方面还能改变别人\n\n#### 改变自己\n\n了解自己的时间观，以此作为依据制定计划，来更好的达到效果\n\n#### 改变他人\n\n了解他人的时间观，站在对方时间观角度，做出更有用的建议\n\n## 总结\n\n#### 我是什么时间观的人\n\n首要时间观念：未来 时间观念\n\n#### 如何做\n\n制定未来目标，并在脑海中描绘出生动的图像。来增强实现目标动力\n\n","source":"_posts/LEVEL 1/时间管理/2 了解你的时间观/2.1 津巴多时间观｜了解自己的时间观.md","raw":"## 什么是时间观\n> [棉花糖实验](https://baike.baidu.com/tashuo/browse/content?id=0973544b769d9226d67cdc85&lemmaId=15659236&fromLemmaModule=pcBottom)\n\n#### 津巴多时间观\n\n> 时间观分为过去、现在、将来三个维度。\n>\n> 对时间观不同倾向的人，无论是言语、行为、决策，都会是完全不同的\n\n- 过去\n  - 消极过去时间观\n  \n    总是回忆人生中的负面经历，并沉浸其中无法自拔\n  \n  - 积极过去时间观\n  \n    善于从过去的经历中吸取养分\n- 现在 \n\t- 宿命主义当下时间观\n\t\n\t  认为万事皆注定、命运由不得自己\n\t\n\t- 享乐主义当下时间观\n\t\n\t  尽情享受当下，幸福感很高；但自控能力差\n- 未来\n\t- 未来导向时间观（张一鸣强调的“延迟满足”）\n\t\n\t  善于规划，为了达成未来目标愿意放弃当下的娱乐\n\t\n\t- 超未来时间观\n\t\n\t  坚信人会有来世，可能会做出一些比较极端的行为\n\n*我们会在多个时间观上都有倾向，它们之间是相互影响的*\n\n##  时间观可以如何应用？\n\n> 一方面改变和调整自己，一方面还能改变别人\n\n#### 改变自己\n\n了解自己的时间观，以此作为依据制定计划，来更好的达到效果\n\n#### 改变他人\n\n了解他人的时间观，站在对方时间观角度，做出更有用的建议\n\n## 总结\n\n#### 我是什么时间观的人\n\n首要时间观念：未来 时间观念\n\n#### 如何做\n\n制定未来目标，并在脑海中描绘出生动的图像。来增强实现目标动力\n\n","slug":"LEVEL 1/时间管理/2 了解你的时间观/2.1 津巴多时间观｜了解自己的时间观","published":1,"date":"2020-06-25T03:10:24.431Z","updated":"2020-06-25T03:10:24.431Z","title":"LEVEL 1/时间管理/2 了解你的时间观/2.1 津巴多时间观｜了解自己的时间观","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpc00163ns6hl143icn","content":"<h2 id=\"什么是时间观\"><a href=\"#什么是时间观\" class=\"headerlink\" title=\"什么是时间观\"></a>什么是时间观</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/tashuo/browse/content?id=0973544b769d9226d67cdc85&lemmaId=15659236&fromLemmaModule=pcBottom\" target=\"_blank\" rel=\"noopener\">棉花糖实验</a></p>\n</blockquote>\n<h4 id=\"津巴多时间观\"><a href=\"#津巴多时间观\" class=\"headerlink\" title=\"津巴多时间观\"></a>津巴多时间观</h4><blockquote>\n<p>时间观分为过去、现在、将来三个维度。</p>\n<p>对时间观不同倾向的人，无论是言语、行为、决策，都会是完全不同的</p>\n</blockquote>\n<ul>\n<li><p>过去</p>\n<ul>\n<li><p>消极过去时间观</p>\n<p>总是回忆人生中的负面经历，并沉浸其中无法自拔</p>\n</li>\n<li><p>积极过去时间观</p>\n<p>善于从过去的经历中吸取养分</p>\n</li>\n</ul>\n</li>\n<li><p>现在 </p>\n<ul>\n<li><p>宿命主义当下时间观</p>\n<p>认为万事皆注定、命运由不得自己</p>\n</li>\n<li><p>享乐主义当下时间观</p>\n<p>尽情享受当下，幸福感很高；但自控能力差</p>\n</li>\n</ul>\n</li>\n<li><p>未来</p>\n<ul>\n<li><p>未来导向时间观（张一鸣强调的“延迟满足”）</p>\n<p>善于规划，为了达成未来目标愿意放弃当下的娱乐</p>\n</li>\n<li><p>超未来时间观</p>\n<p>坚信人会有来世，可能会做出一些比较极端的行为</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><em>我们会在多个时间观上都有倾向，它们之间是相互影响的</em></p>\n<h2 id=\"时间观可以如何应用？\"><a href=\"#时间观可以如何应用？\" class=\"headerlink\" title=\"时间观可以如何应用？\"></a>时间观可以如何应用？</h2><blockquote>\n<p>一方面改变和调整自己，一方面还能改变别人</p>\n</blockquote>\n<h4 id=\"改变自己\"><a href=\"#改变自己\" class=\"headerlink\" title=\"改变自己\"></a>改变自己</h4><p>了解自己的时间观，以此作为依据制定计划，来更好的达到效果</p>\n<h4 id=\"改变他人\"><a href=\"#改变他人\" class=\"headerlink\" title=\"改变他人\"></a>改变他人</h4><p>了解他人的时间观，站在对方时间观角度，做出更有用的建议</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h4 id=\"我是什么时间观的人\"><a href=\"#我是什么时间观的人\" class=\"headerlink\" title=\"我是什么时间观的人\"></a>我是什么时间观的人</h4><p>首要时间观念：未来 时间观念</p>\n<h4 id=\"如何做\"><a href=\"#如何做\" class=\"headerlink\" title=\"如何做\"></a>如何做</h4><p>制定未来目标，并在脑海中描绘出生动的图像。来增强实现目标动力</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是时间观\"><a href=\"#什么是时间观\" class=\"headerlink\" title=\"什么是时间观\"></a>什么是时间观</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/tashuo/browse/content?id=0973544b769d9226d67cdc85&lemmaId=15659236&fromLemmaModule=pcBottom\" target=\"_blank\" rel=\"noopener\">棉花糖实验</a></p>\n</blockquote>\n<h4 id=\"津巴多时间观\"><a href=\"#津巴多时间观\" class=\"headerlink\" title=\"津巴多时间观\"></a>津巴多时间观</h4><blockquote>\n<p>时间观分为过去、现在、将来三个维度。</p>\n<p>对时间观不同倾向的人，无论是言语、行为、决策，都会是完全不同的</p>\n</blockquote>\n<ul>\n<li><p>过去</p>\n<ul>\n<li><p>消极过去时间观</p>\n<p>总是回忆人生中的负面经历，并沉浸其中无法自拔</p>\n</li>\n<li><p>积极过去时间观</p>\n<p>善于从过去的经历中吸取养分</p>\n</li>\n</ul>\n</li>\n<li><p>现在 </p>\n<ul>\n<li><p>宿命主义当下时间观</p>\n<p>认为万事皆注定、命运由不得自己</p>\n</li>\n<li><p>享乐主义当下时间观</p>\n<p>尽情享受当下，幸福感很高；但自控能力差</p>\n</li>\n</ul>\n</li>\n<li><p>未来</p>\n<ul>\n<li><p>未来导向时间观（张一鸣强调的“延迟满足”）</p>\n<p>善于规划，为了达成未来目标愿意放弃当下的娱乐</p>\n</li>\n<li><p>超未来时间观</p>\n<p>坚信人会有来世，可能会做出一些比较极端的行为</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><em>我们会在多个时间观上都有倾向，它们之间是相互影响的</em></p>\n<h2 id=\"时间观可以如何应用？\"><a href=\"#时间观可以如何应用？\" class=\"headerlink\" title=\"时间观可以如何应用？\"></a>时间观可以如何应用？</h2><blockquote>\n<p>一方面改变和调整自己，一方面还能改变别人</p>\n</blockquote>\n<h4 id=\"改变自己\"><a href=\"#改变自己\" class=\"headerlink\" title=\"改变自己\"></a>改变自己</h4><p>了解自己的时间观，以此作为依据制定计划，来更好的达到效果</p>\n<h4 id=\"改变他人\"><a href=\"#改变他人\" class=\"headerlink\" title=\"改变他人\"></a>改变他人</h4><p>了解他人的时间观，站在对方时间观角度，做出更有用的建议</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h4 id=\"我是什么时间观的人\"><a href=\"#我是什么时间观的人\" class=\"headerlink\" title=\"我是什么时间观的人\"></a>我是什么时间观的人</h4><p>首要时间观念：未来 时间观念</p>\n<h4 id=\"如何做\"><a href=\"#如何做\" class=\"headerlink\" title=\"如何做\"></a>如何做</h4><p>制定未来目标，并在脑海中描绘出生动的图像。来增强实现目标动力</p>\n"},{"_content":"## 如何进行时间记录\n\n#### 1. 时间花费记录\n\n以天为单位记录自己的时间流水，积累一定量后进行分类统计\n\n``` 开始时间-结束时间：做了什么```\n\n#### 2. 时间消耗记录\n\n> 为了发现时间管理的问题\n\n针对花费时间较久或发生频率相对较高的任务，在表格中列下任务、评估时间、实际时间三项\n\n## 时间记录会有什么障碍\n\n#### 时间记录的三个误区\n\n#### 1. 记录越仔细越好\n\n反而会耗费很多时间在记录时间上\n\n#### 2. 记录颗粒度越小越好\n\n记录颗粒度最小在5分钟，控制在2小时内\n\n#### 3. 记录时间就是时间管理的全部\n\n记录之后需要做分析\n\n\n\n## 我的时间记录\n\n记录时间已经5天，有好的方面也有不好的地方：\n\n好的：\n\n- 利用APP，时间颗粒度固定在15分钟，基本满足所有需求\n- 没有因为记录时间花费果果的时间\n\n不好的：\n\n- 周末休息的时候没有记录\n- 睡觉时间也可以记录下来","source":"_posts/LEVEL 1/时间管理/3 诊断你的时间/3.1 时间记录法 | 了解你的时间花费，让时间变得更可控.md","raw":"## 如何进行时间记录\n\n#### 1. 时间花费记录\n\n以天为单位记录自己的时间流水，积累一定量后进行分类统计\n\n``` 开始时间-结束时间：做了什么```\n\n#### 2. 时间消耗记录\n\n> 为了发现时间管理的问题\n\n针对花费时间较久或发生频率相对较高的任务，在表格中列下任务、评估时间、实际时间三项\n\n## 时间记录会有什么障碍\n\n#### 时间记录的三个误区\n\n#### 1. 记录越仔细越好\n\n反而会耗费很多时间在记录时间上\n\n#### 2. 记录颗粒度越小越好\n\n记录颗粒度最小在5分钟，控制在2小时内\n\n#### 3. 记录时间就是时间管理的全部\n\n记录之后需要做分析\n\n\n\n## 我的时间记录\n\n记录时间已经5天，有好的方面也有不好的地方：\n\n好的：\n\n- 利用APP，时间颗粒度固定在15分钟，基本满足所有需求\n- 没有因为记录时间花费果果的时间\n\n不好的：\n\n- 周末休息的时候没有记录\n- 睡觉时间也可以记录下来","slug":"LEVEL 1/时间管理/3 诊断你的时间/3.1 时间记录法 | 了解你的时间花费，让时间变得更可控","published":1,"date":"2020-06-25T03:10:24.434Z","updated":"2020-06-25T03:10:24.434Z","title":"LEVEL 1/时间管理/3 诊断你的时间/3.1 时间记录法 | 了解你的时间花费，让时间变得更可控","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpd00173ns6b88zexav","content":"<h2 id=\"如何进行时间记录\"><a href=\"#如何进行时间记录\" class=\"headerlink\" title=\"如何进行时间记录\"></a>如何进行时间记录</h2><h4 id=\"1-时间花费记录\"><a href=\"#1-时间花费记录\" class=\"headerlink\" title=\"1. 时间花费记录\"></a>1. 时间花费记录</h4><p>以天为单位记录自己的时间流水，积累一定量后进行分类统计</p>\n<p><code>开始时间-结束时间：做了什么</code></p>\n<h4 id=\"2-时间消耗记录\"><a href=\"#2-时间消耗记录\" class=\"headerlink\" title=\"2. 时间消耗记录\"></a>2. 时间消耗记录</h4><blockquote>\n<p>为了发现时间管理的问题</p>\n</blockquote>\n<p>针对花费时间较久或发生频率相对较高的任务，在表格中列下任务、评估时间、实际时间三项</p>\n<h2 id=\"时间记录会有什么障碍\"><a href=\"#时间记录会有什么障碍\" class=\"headerlink\" title=\"时间记录会有什么障碍\"></a>时间记录会有什么障碍</h2><h4 id=\"时间记录的三个误区\"><a href=\"#时间记录的三个误区\" class=\"headerlink\" title=\"时间记录的三个误区\"></a>时间记录的三个误区</h4><h4 id=\"1-记录越仔细越好\"><a href=\"#1-记录越仔细越好\" class=\"headerlink\" title=\"1. 记录越仔细越好\"></a>1. 记录越仔细越好</h4><p>反而会耗费很多时间在记录时间上</p>\n<h4 id=\"2-记录颗粒度越小越好\"><a href=\"#2-记录颗粒度越小越好\" class=\"headerlink\" title=\"2. 记录颗粒度越小越好\"></a>2. 记录颗粒度越小越好</h4><p>记录颗粒度最小在5分钟，控制在2小时内</p>\n<h4 id=\"3-记录时间就是时间管理的全部\"><a href=\"#3-记录时间就是时间管理的全部\" class=\"headerlink\" title=\"3. 记录时间就是时间管理的全部\"></a>3. 记录时间就是时间管理的全部</h4><p>记录之后需要做分析</p>\n<h2 id=\"我的时间记录\"><a href=\"#我的时间记录\" class=\"headerlink\" title=\"我的时间记录\"></a>我的时间记录</h2><p>记录时间已经5天，有好的方面也有不好的地方：</p>\n<p>好的：</p>\n<ul>\n<li>利用APP，时间颗粒度固定在15分钟，基本满足所有需求</li>\n<li>没有因为记录时间花费果果的时间</li>\n</ul>\n<p>不好的：</p>\n<ul>\n<li>周末休息的时候没有记录</li>\n<li>睡觉时间也可以记录下来</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何进行时间记录\"><a href=\"#如何进行时间记录\" class=\"headerlink\" title=\"如何进行时间记录\"></a>如何进行时间记录</h2><h4 id=\"1-时间花费记录\"><a href=\"#1-时间花费记录\" class=\"headerlink\" title=\"1. 时间花费记录\"></a>1. 时间花费记录</h4><p>以天为单位记录自己的时间流水，积累一定量后进行分类统计</p>\n<p><code>开始时间-结束时间：做了什么</code></p>\n<h4 id=\"2-时间消耗记录\"><a href=\"#2-时间消耗记录\" class=\"headerlink\" title=\"2. 时间消耗记录\"></a>2. 时间消耗记录</h4><blockquote>\n<p>为了发现时间管理的问题</p>\n</blockquote>\n<p>针对花费时间较久或发生频率相对较高的任务，在表格中列下任务、评估时间、实际时间三项</p>\n<h2 id=\"时间记录会有什么障碍\"><a href=\"#时间记录会有什么障碍\" class=\"headerlink\" title=\"时间记录会有什么障碍\"></a>时间记录会有什么障碍</h2><h4 id=\"时间记录的三个误区\"><a href=\"#时间记录的三个误区\" class=\"headerlink\" title=\"时间记录的三个误区\"></a>时间记录的三个误区</h4><h4 id=\"1-记录越仔细越好\"><a href=\"#1-记录越仔细越好\" class=\"headerlink\" title=\"1. 记录越仔细越好\"></a>1. 记录越仔细越好</h4><p>反而会耗费很多时间在记录时间上</p>\n<h4 id=\"2-记录颗粒度越小越好\"><a href=\"#2-记录颗粒度越小越好\" class=\"headerlink\" title=\"2. 记录颗粒度越小越好\"></a>2. 记录颗粒度越小越好</h4><p>记录颗粒度最小在5分钟，控制在2小时内</p>\n<h4 id=\"3-记录时间就是时间管理的全部\"><a href=\"#3-记录时间就是时间管理的全部\" class=\"headerlink\" title=\"3. 记录时间就是时间管理的全部\"></a>3. 记录时间就是时间管理的全部</h4><p>记录之后需要做分析</p>\n<h2 id=\"我的时间记录\"><a href=\"#我的时间记录\" class=\"headerlink\" title=\"我的时间记录\"></a>我的时间记录</h2><p>记录时间已经5天，有好的方面也有不好的地方：</p>\n<p>好的：</p>\n<ul>\n<li>利用APP，时间颗粒度固定在15分钟，基本满足所有需求</li>\n<li>没有因为记录时间花费果果的时间</li>\n</ul>\n<p>不好的：</p>\n<ul>\n<li>周末休息的时候没有记录</li>\n<li>睡觉时间也可以记录下来</li>\n</ul>\n"},{"_content":"## 调整未来时间观\n\n> 现在我们处于一个安全的社会中，越来越需要从更长远的时间对自己进行规划\n\n####  找到目标\n\n“我真正的人生目标时什么？”，写下脑海中最先想到的答案，然后重复这一步，知道写出一个为之惊叫的答案\n\n#### 调整自控力肌肉\n\n停止做某件事、开始做某件事、记录平时不关注的事情（比如减肥拒绝高热量食物、上厕所不带手机等等）\n\n#### 给未来的自己写封信\n\n可以在信里向未来的自己描述将来打算要做什么、对未来的自己有什么期望等等\n\n\n\n## 什么是平衡的时间观\n\n> 津巴多认为，单一的发展六种时间观念都是有缺陷的，因此他建议人们形成一种平衡的时间观\n\n#### 平衡的时间观\n\n- 较强的“积极的过去”时间观\n- 适当的“享乐主义的现在”时间观\n- 适当的“未来导向”时间观\n- 较弱的“消极的过去”时间观\n- 较弱的“宿命主义的现在”时间观\n\n\n\n## 调整过去时间观\n\n> 过去的记忆，是可以因为对过去事件看法的改变，而发生重构\n\n#### 如何调整过去的时间观\n\n1. 记录自我评价\n\n   在纸上顶部或文档顶部写上：“我过去时什么样的人”；描述之前行事方式；重复步骤‘左后保存答案。\n\n2. 为重要的时间，重新赋予意义\n\n   写三件过去有负面影响的事件；写下在这三件事中现在能得到的正面收获；列出这些收获在未来如何帮助自己。\n\n3. 写感恩日记\n\n   每一天快结束的时候，写下三件今天感到快乐的或者感恩的小事，至少坚持2周的时间。\n\n**新的积极的角度看待过去的事情**，但不要沉溺，改变也需要时间呢，不要着急\n\n## 调整现在时间观\n\n> 以当下为导向的时间观，可以让你在工作中更容易进入“心流”的状态，也就是在一定的时间里，全神贯注于眼前的事情、不受干扰的专注状态\n\n#### 如何让自己更关注当下呢？\n\n- 自我问答\n\n  1. 我是谁（尽可能写出所有答案）\n  2. 现在是什么时候（发挥想象力，比如事业、关系、生活中的哪个阶段）\n  3. 我现在，在哪里（发挥想象力，比如描述周围环境）\n  4. 我现在有什么样的感受（尝试感受自己真正的感受）\n\n- 练习冥想\n\n  冥想5分钟也可以起到明显的效果\n\n  \n\n## 我需要做的调整\n\n#### 需要调整的时间观\n\n测试测出我的主流时间观是：未来导向。但日常我常常会被过去让我有过负面情绪的事情所影响，导致无法专心做当下的事情。所以我需要调整消极的过去时间观为较强的积极过去时间观\n\n#### 我的方案\n\n1. 每天记录自己完成的三件事情，肯定自己的成果（坚持三周）\n2. 在回忆到过去让我有过负面情绪的事情时，先记下来，等冷静下来，对它进行一次冷静的正面总结\n\n#### 期待的效果\n\n- 当再次想起同样的事情时，不再受负面情绪困扰，转而可以坦然面对，以及更多想到的是正面的影响\n- 除了对当事达到有正面效果，希望养成可以自己消除不好事情的影响的好习惯\n\n","source":"_posts/LEVEL 1/时间管理/2 了解你的时间观/2.2 时间观察调整法｜ 如何平衡自己的时间.md","raw":"## 调整未来时间观\n\n> 现在我们处于一个安全的社会中，越来越需要从更长远的时间对自己进行规划\n\n####  找到目标\n\n“我真正的人生目标时什么？”，写下脑海中最先想到的答案，然后重复这一步，知道写出一个为之惊叫的答案\n\n#### 调整自控力肌肉\n\n停止做某件事、开始做某件事、记录平时不关注的事情（比如减肥拒绝高热量食物、上厕所不带手机等等）\n\n#### 给未来的自己写封信\n\n可以在信里向未来的自己描述将来打算要做什么、对未来的自己有什么期望等等\n\n\n\n## 什么是平衡的时间观\n\n> 津巴多认为，单一的发展六种时间观念都是有缺陷的，因此他建议人们形成一种平衡的时间观\n\n#### 平衡的时间观\n\n- 较强的“积极的过去”时间观\n- 适当的“享乐主义的现在”时间观\n- 适当的“未来导向”时间观\n- 较弱的“消极的过去”时间观\n- 较弱的“宿命主义的现在”时间观\n\n\n\n## 调整过去时间观\n\n> 过去的记忆，是可以因为对过去事件看法的改变，而发生重构\n\n#### 如何调整过去的时间观\n\n1. 记录自我评价\n\n   在纸上顶部或文档顶部写上：“我过去时什么样的人”；描述之前行事方式；重复步骤‘左后保存答案。\n\n2. 为重要的时间，重新赋予意义\n\n   写三件过去有负面影响的事件；写下在这三件事中现在能得到的正面收获；列出这些收获在未来如何帮助自己。\n\n3. 写感恩日记\n\n   每一天快结束的时候，写下三件今天感到快乐的或者感恩的小事，至少坚持2周的时间。\n\n**新的积极的角度看待过去的事情**，但不要沉溺，改变也需要时间呢，不要着急\n\n## 调整现在时间观\n\n> 以当下为导向的时间观，可以让你在工作中更容易进入“心流”的状态，也就是在一定的时间里，全神贯注于眼前的事情、不受干扰的专注状态\n\n#### 如何让自己更关注当下呢？\n\n- 自我问答\n\n  1. 我是谁（尽可能写出所有答案）\n  2. 现在是什么时候（发挥想象力，比如事业、关系、生活中的哪个阶段）\n  3. 我现在，在哪里（发挥想象力，比如描述周围环境）\n  4. 我现在有什么样的感受（尝试感受自己真正的感受）\n\n- 练习冥想\n\n  冥想5分钟也可以起到明显的效果\n\n  \n\n## 我需要做的调整\n\n#### 需要调整的时间观\n\n测试测出我的主流时间观是：未来导向。但日常我常常会被过去让我有过负面情绪的事情所影响，导致无法专心做当下的事情。所以我需要调整消极的过去时间观为较强的积极过去时间观\n\n#### 我的方案\n\n1. 每天记录自己完成的三件事情，肯定自己的成果（坚持三周）\n2. 在回忆到过去让我有过负面情绪的事情时，先记下来，等冷静下来，对它进行一次冷静的正面总结\n\n#### 期待的效果\n\n- 当再次想起同样的事情时，不再受负面情绪困扰，转而可以坦然面对，以及更多想到的是正面的影响\n- 除了对当事达到有正面效果，希望养成可以自己消除不好事情的影响的好习惯\n\n","slug":"LEVEL 1/时间管理/2 了解你的时间观/2.2 时间观察调整法｜ 如何平衡自己的时间","published":1,"date":"2020-06-25T03:10:24.433Z","updated":"2020-06-25T03:10:24.433Z","title":"LEVEL 1/时间管理/2 了解你的时间观/2.2 时间观察调整法｜ 如何平衡自己的时间","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpe00183ns612cy6qr2","content":"<h2 id=\"调整未来时间观\"><a href=\"#调整未来时间观\" class=\"headerlink\" title=\"调整未来时间观\"></a>调整未来时间观</h2><blockquote>\n<p>现在我们处于一个安全的社会中，越来越需要从更长远的时间对自己进行规划</p>\n</blockquote>\n<h4 id=\"找到目标\"><a href=\"#找到目标\" class=\"headerlink\" title=\"找到目标\"></a>找到目标</h4><p>“我真正的人生目标时什么？”，写下脑海中最先想到的答案，然后重复这一步，知道写出一个为之惊叫的答案</p>\n<h4 id=\"调整自控力肌肉\"><a href=\"#调整自控力肌肉\" class=\"headerlink\" title=\"调整自控力肌肉\"></a>调整自控力肌肉</h4><p>停止做某件事、开始做某件事、记录平时不关注的事情（比如减肥拒绝高热量食物、上厕所不带手机等等）</p>\n<h4 id=\"给未来的自己写封信\"><a href=\"#给未来的自己写封信\" class=\"headerlink\" title=\"给未来的自己写封信\"></a>给未来的自己写封信</h4><p>可以在信里向未来的自己描述将来打算要做什么、对未来的自己有什么期望等等</p>\n<h2 id=\"什么是平衡的时间观\"><a href=\"#什么是平衡的时间观\" class=\"headerlink\" title=\"什么是平衡的时间观\"></a>什么是平衡的时间观</h2><blockquote>\n<p>津巴多认为，单一的发展六种时间观念都是有缺陷的，因此他建议人们形成一种平衡的时间观</p>\n</blockquote>\n<h4 id=\"平衡的时间观\"><a href=\"#平衡的时间观\" class=\"headerlink\" title=\"平衡的时间观\"></a>平衡的时间观</h4><ul>\n<li>较强的“积极的过去”时间观</li>\n<li>适当的“享乐主义的现在”时间观</li>\n<li>适当的“未来导向”时间观</li>\n<li>较弱的“消极的过去”时间观</li>\n<li>较弱的“宿命主义的现在”时间观</li>\n</ul>\n<h2 id=\"调整过去时间观\"><a href=\"#调整过去时间观\" class=\"headerlink\" title=\"调整过去时间观\"></a>调整过去时间观</h2><blockquote>\n<p>过去的记忆，是可以因为对过去事件看法的改变，而发生重构</p>\n</blockquote>\n<h4 id=\"如何调整过去的时间观\"><a href=\"#如何调整过去的时间观\" class=\"headerlink\" title=\"如何调整过去的时间观\"></a>如何调整过去的时间观</h4><ol>\n<li><p>记录自我评价</p>\n<p>在纸上顶部或文档顶部写上：“我过去时什么样的人”；描述之前行事方式；重复步骤‘左后保存答案。</p>\n</li>\n<li><p>为重要的时间，重新赋予意义</p>\n<p>写三件过去有负面影响的事件；写下在这三件事中现在能得到的正面收获；列出这些收获在未来如何帮助自己。</p>\n</li>\n<li><p>写感恩日记</p>\n<p>每一天快结束的时候，写下三件今天感到快乐的或者感恩的小事，至少坚持2周的时间。</p>\n</li>\n</ol>\n<p><strong>新的积极的角度看待过去的事情</strong>，但不要沉溺，改变也需要时间呢，不要着急</p>\n<h2 id=\"调整现在时间观\"><a href=\"#调整现在时间观\" class=\"headerlink\" title=\"调整现在时间观\"></a>调整现在时间观</h2><blockquote>\n<p>以当下为导向的时间观，可以让你在工作中更容易进入“心流”的状态，也就是在一定的时间里，全神贯注于眼前的事情、不受干扰的专注状态</p>\n</blockquote>\n<h4 id=\"如何让自己更关注当下呢？\"><a href=\"#如何让自己更关注当下呢？\" class=\"headerlink\" title=\"如何让自己更关注当下呢？\"></a>如何让自己更关注当下呢？</h4><ul>\n<li><p>自我问答</p>\n<ol>\n<li>我是谁（尽可能写出所有答案）</li>\n<li>现在是什么时候（发挥想象力，比如事业、关系、生活中的哪个阶段）</li>\n<li>我现在，在哪里（发挥想象力，比如描述周围环境）</li>\n<li>我现在有什么样的感受（尝试感受自己真正的感受）</li>\n</ol>\n</li>\n<li><p>练习冥想</p>\n<p>冥想5分钟也可以起到明显的效果</p>\n</li>\n</ul>\n<h2 id=\"我需要做的调整\"><a href=\"#我需要做的调整\" class=\"headerlink\" title=\"我需要做的调整\"></a>我需要做的调整</h2><h4 id=\"需要调整的时间观\"><a href=\"#需要调整的时间观\" class=\"headerlink\" title=\"需要调整的时间观\"></a>需要调整的时间观</h4><p>测试测出我的主流时间观是：未来导向。但日常我常常会被过去让我有过负面情绪的事情所影响，导致无法专心做当下的事情。所以我需要调整消极的过去时间观为较强的积极过去时间观</p>\n<h4 id=\"我的方案\"><a href=\"#我的方案\" class=\"headerlink\" title=\"我的方案\"></a>我的方案</h4><ol>\n<li>每天记录自己完成的三件事情，肯定自己的成果（坚持三周）</li>\n<li>在回忆到过去让我有过负面情绪的事情时，先记下来，等冷静下来，对它进行一次冷静的正面总结</li>\n</ol>\n<h4 id=\"期待的效果\"><a href=\"#期待的效果\" class=\"headerlink\" title=\"期待的效果\"></a>期待的效果</h4><ul>\n<li>当再次想起同样的事情时，不再受负面情绪困扰，转而可以坦然面对，以及更多想到的是正面的影响</li>\n<li>除了对当事达到有正面效果，希望养成可以自己消除不好事情的影响的好习惯</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"调整未来时间观\"><a href=\"#调整未来时间观\" class=\"headerlink\" title=\"调整未来时间观\"></a>调整未来时间观</h2><blockquote>\n<p>现在我们处于一个安全的社会中，越来越需要从更长远的时间对自己进行规划</p>\n</blockquote>\n<h4 id=\"找到目标\"><a href=\"#找到目标\" class=\"headerlink\" title=\"找到目标\"></a>找到目标</h4><p>“我真正的人生目标时什么？”，写下脑海中最先想到的答案，然后重复这一步，知道写出一个为之惊叫的答案</p>\n<h4 id=\"调整自控力肌肉\"><a href=\"#调整自控力肌肉\" class=\"headerlink\" title=\"调整自控力肌肉\"></a>调整自控力肌肉</h4><p>停止做某件事、开始做某件事、记录平时不关注的事情（比如减肥拒绝高热量食物、上厕所不带手机等等）</p>\n<h4 id=\"给未来的自己写封信\"><a href=\"#给未来的自己写封信\" class=\"headerlink\" title=\"给未来的自己写封信\"></a>给未来的自己写封信</h4><p>可以在信里向未来的自己描述将来打算要做什么、对未来的自己有什么期望等等</p>\n<h2 id=\"什么是平衡的时间观\"><a href=\"#什么是平衡的时间观\" class=\"headerlink\" title=\"什么是平衡的时间观\"></a>什么是平衡的时间观</h2><blockquote>\n<p>津巴多认为，单一的发展六种时间观念都是有缺陷的，因此他建议人们形成一种平衡的时间观</p>\n</blockquote>\n<h4 id=\"平衡的时间观\"><a href=\"#平衡的时间观\" class=\"headerlink\" title=\"平衡的时间观\"></a>平衡的时间观</h4><ul>\n<li>较强的“积极的过去”时间观</li>\n<li>适当的“享乐主义的现在”时间观</li>\n<li>适当的“未来导向”时间观</li>\n<li>较弱的“消极的过去”时间观</li>\n<li>较弱的“宿命主义的现在”时间观</li>\n</ul>\n<h2 id=\"调整过去时间观\"><a href=\"#调整过去时间观\" class=\"headerlink\" title=\"调整过去时间观\"></a>调整过去时间观</h2><blockquote>\n<p>过去的记忆，是可以因为对过去事件看法的改变，而发生重构</p>\n</blockquote>\n<h4 id=\"如何调整过去的时间观\"><a href=\"#如何调整过去的时间观\" class=\"headerlink\" title=\"如何调整过去的时间观\"></a>如何调整过去的时间观</h4><ol>\n<li><p>记录自我评价</p>\n<p>在纸上顶部或文档顶部写上：“我过去时什么样的人”；描述之前行事方式；重复步骤‘左后保存答案。</p>\n</li>\n<li><p>为重要的时间，重新赋予意义</p>\n<p>写三件过去有负面影响的事件；写下在这三件事中现在能得到的正面收获；列出这些收获在未来如何帮助自己。</p>\n</li>\n<li><p>写感恩日记</p>\n<p>每一天快结束的时候，写下三件今天感到快乐的或者感恩的小事，至少坚持2周的时间。</p>\n</li>\n</ol>\n<p><strong>新的积极的角度看待过去的事情</strong>，但不要沉溺，改变也需要时间呢，不要着急</p>\n<h2 id=\"调整现在时间观\"><a href=\"#调整现在时间观\" class=\"headerlink\" title=\"调整现在时间观\"></a>调整现在时间观</h2><blockquote>\n<p>以当下为导向的时间观，可以让你在工作中更容易进入“心流”的状态，也就是在一定的时间里，全神贯注于眼前的事情、不受干扰的专注状态</p>\n</blockquote>\n<h4 id=\"如何让自己更关注当下呢？\"><a href=\"#如何让自己更关注当下呢？\" class=\"headerlink\" title=\"如何让自己更关注当下呢？\"></a>如何让自己更关注当下呢？</h4><ul>\n<li><p>自我问答</p>\n<ol>\n<li>我是谁（尽可能写出所有答案）</li>\n<li>现在是什么时候（发挥想象力，比如事业、关系、生活中的哪个阶段）</li>\n<li>我现在，在哪里（发挥想象力，比如描述周围环境）</li>\n<li>我现在有什么样的感受（尝试感受自己真正的感受）</li>\n</ol>\n</li>\n<li><p>练习冥想</p>\n<p>冥想5分钟也可以起到明显的效果</p>\n</li>\n</ul>\n<h2 id=\"我需要做的调整\"><a href=\"#我需要做的调整\" class=\"headerlink\" title=\"我需要做的调整\"></a>我需要做的调整</h2><h4 id=\"需要调整的时间观\"><a href=\"#需要调整的时间观\" class=\"headerlink\" title=\"需要调整的时间观\"></a>需要调整的时间观</h4><p>测试测出我的主流时间观是：未来导向。但日常我常常会被过去让我有过负面情绪的事情所影响，导致无法专心做当下的事情。所以我需要调整消极的过去时间观为较强的积极过去时间观</p>\n<h4 id=\"我的方案\"><a href=\"#我的方案\" class=\"headerlink\" title=\"我的方案\"></a>我的方案</h4><ol>\n<li>每天记录自己完成的三件事情，肯定自己的成果（坚持三周）</li>\n<li>在回忆到过去让我有过负面情绪的事情时，先记下来，等冷静下来，对它进行一次冷静的正面总结</li>\n</ol>\n<h4 id=\"期待的效果\"><a href=\"#期待的效果\" class=\"headerlink\" title=\"期待的效果\"></a>期待的效果</h4><ul>\n<li>当再次想起同样的事情时，不再受负面情绪困扰，转而可以坦然面对，以及更多想到的是正面的影响</li>\n<li>除了对当事达到有正面效果，希望养成可以自己消除不好事情的影响的好习惯</li>\n</ul>\n"},{"_content":"判断价值的时间分析工具\n\n有两个方面：事件本身的价值、个人时间规律\n\n#### 先开始事件本身的价值分析\n\n> 关键点：我们把时间花在什么事情上面。因为这决定了我们的时间将会创造什么样的价值。\n\n依据时间的四象限：重要、紧急两个维度\n\n而其中重要紧急的划分，只考虑了工作的产出情况，没有考虑对工作的投入情况。为防止一件重要又紧急的事情，花费你大量的时间，有很难解决它。我们可以用*关键度*和*可解决度*这两个维度重新定义时间\n\n![2.jpg](https://static.iqycamp.com/challenge-20180829185345-1p5s27b50.jpg)\n\n#### 1. \"小插曲\"：解决度高、关键度低\n\n最容易对付的问题，如所需花费的时间少，可迅速解决；如花时间多，可授权别人去做。\n\n比如上班中午吃什么，可以快速决定，或跟随同事\n\n#### 2. “困难游戏”：解决度低、关键度低\n\n对于这种问题，你需要设定一个时限，然后以此为标准，时限内能解决的就做，时限内解决不了就放弃。\n\n比如游戏，抖应，这些刷完了多少量，对你也没什么意义的事情，关键度低，且花费了大量的时间精力。不如放弃\n\n#### 3. “无底洞”：解决度低、关键度高\n\n调用情绪脑，听从内心的直觉；或者永远求助他人解决；或者找替代方案。\n\n比如两个人中选择一个结婚，这个考虑因素很多，无法抉择的时候，不如听从内心呼唤。或者暂时放放。\n\n#### 4. “高价值陷阱”：解决度高、关键度高\n\n把时间花在分析和解决这类问题上，才能产生价值。\n\n比如提升结构化思维能力、分析问题的能力等等。但也可能是“陷阱”：你以为自己在思考和解决问题，其实知识在困扰和焦虑中耗费精力。真正的思考，是你通过手机信息、自我婆媳、咨询他人、分析各种因素等方法，最终进行选择。\n\n***所以需要把时间花在分析和解决这类问题上，才能真正产生价值，警惕被困扰在这件事造成的假思考***\n\n\n\n## 如何利用矩阵分析时间\n\n#### 利用矩阵调整时间分配的三种方法\n\n##### 1. 减少投入\n\n如果在“小插曲”以及“困难游戏”上花费的时间高，就减少时间投入，把更多的时间投入到关键度高的事情上。\n\n##### 2. 延缓处理\n\n如果在“无底洞”上耗费很多时间，但仍然没有结果，考虑用直觉块度选择方向、延缓处理、他人帮忙。\n\n##### 3. 避免困扰\n\n判断一下，在处理“高价值陷阱”里面的事情时，是在思考还是困扰\n\n#### 判断时间“关键—可行”的两个标准\n\n##### 1. 明确目标，确定关键度\n\n对事情的关键度，最主要的是看你有什么样的目标，与目标相关度越高，关键度会越高。\n\n比如我现在目标是提升自己，虽然玩手机看剧娱乐能让我放松提高效率，但花在这部分的时间不宜过多，它与目标并无什么相关度。\n\n##### 2. 横向对比，确定解决度\n\n对一些你还没做过的事情，在判断解决度时，找一些历史数据、他人的案例进行横向对比。\n\n\n\n## 总结\n\n通过事件角度分析，知道什么事情是属于高价值的事情。而接下来则是把这些事情安排在什么时间完成\n\n#### 我的关键可行矩阵及调整计划\n\n<table>\n  <tbody>\n  \t<tr  style=\"font-weight:700\">\n      <td rowspan=\"15\" style=\"width:35px\">高<br><br>解<br>决<br>度<br><br> 低</td>\n    \t<td colspan=\"2\" >区间一：小插曲</td>\n      <td colspan=\"2\">区间四：高价值陷阱</td>\n    </tr>\n    <tr style=\"font-weight:600\">\n    \t<td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n    \t<td>做饭</td>\n      <td>除特殊情况，中饭交给奶奶做，晚饭妈妈做</td>\n      <td>与人沟通（尤其好朋友的时候）容易想太多</td>\n      <td>这时候听从内心想法<br/>觉得正确则停止想</td>\n    </tr>\n    <tr style=\"font-weight:700\">\n    \t<td colspan=\"2\">区间二：困难游戏</td>\n      <td colspan=\"2\">区间三：无敌洞</td>\n    </tr>\n     <tr style=\"font-weight:600\">\n    \t<td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n    \t<td>玩手机</td>\n      <td>减少玩手机时间，<br/>卸载和在一些时间段禁用不必要的APP</td>\n      <td>框架源码深入理解，看的有些懵</td>\n      <td>搜索找资料，看别人是如何理解的<br/>学习别人的学习经验</td>\n    </tr>\n    <tr>\n    \t<td>看咨询</td>\n      <td>少看咨询，或者在一个时间段集中看</td>\n      <td></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n## 备注\n\n***你的时间花得值吗？一个关键的评判点：*分析这件事对你的长期 短期的益处**\n\n时间的四象限法则：重要和紧急两个维度\n\n","source":"_posts/LEVEL 1/时间管理/3 诊断你的时间/3.2 关键可行矩阵 | 让你用更短的时间，创造更高的价值.md","raw":"判断价值的时间分析工具\n\n有两个方面：事件本身的价值、个人时间规律\n\n#### 先开始事件本身的价值分析\n\n> 关键点：我们把时间花在什么事情上面。因为这决定了我们的时间将会创造什么样的价值。\n\n依据时间的四象限：重要、紧急两个维度\n\n而其中重要紧急的划分，只考虑了工作的产出情况，没有考虑对工作的投入情况。为防止一件重要又紧急的事情，花费你大量的时间，有很难解决它。我们可以用*关键度*和*可解决度*这两个维度重新定义时间\n\n![2.jpg](https://static.iqycamp.com/challenge-20180829185345-1p5s27b50.jpg)\n\n#### 1. \"小插曲\"：解决度高、关键度低\n\n最容易对付的问题，如所需花费的时间少，可迅速解决；如花时间多，可授权别人去做。\n\n比如上班中午吃什么，可以快速决定，或跟随同事\n\n#### 2. “困难游戏”：解决度低、关键度低\n\n对于这种问题，你需要设定一个时限，然后以此为标准，时限内能解决的就做，时限内解决不了就放弃。\n\n比如游戏，抖应，这些刷完了多少量，对你也没什么意义的事情，关键度低，且花费了大量的时间精力。不如放弃\n\n#### 3. “无底洞”：解决度低、关键度高\n\n调用情绪脑，听从内心的直觉；或者永远求助他人解决；或者找替代方案。\n\n比如两个人中选择一个结婚，这个考虑因素很多，无法抉择的时候，不如听从内心呼唤。或者暂时放放。\n\n#### 4. “高价值陷阱”：解决度高、关键度高\n\n把时间花在分析和解决这类问题上，才能产生价值。\n\n比如提升结构化思维能力、分析问题的能力等等。但也可能是“陷阱”：你以为自己在思考和解决问题，其实知识在困扰和焦虑中耗费精力。真正的思考，是你通过手机信息、自我婆媳、咨询他人、分析各种因素等方法，最终进行选择。\n\n***所以需要把时间花在分析和解决这类问题上，才能真正产生价值，警惕被困扰在这件事造成的假思考***\n\n\n\n## 如何利用矩阵分析时间\n\n#### 利用矩阵调整时间分配的三种方法\n\n##### 1. 减少投入\n\n如果在“小插曲”以及“困难游戏”上花费的时间高，就减少时间投入，把更多的时间投入到关键度高的事情上。\n\n##### 2. 延缓处理\n\n如果在“无底洞”上耗费很多时间，但仍然没有结果，考虑用直觉块度选择方向、延缓处理、他人帮忙。\n\n##### 3. 避免困扰\n\n判断一下，在处理“高价值陷阱”里面的事情时，是在思考还是困扰\n\n#### 判断时间“关键—可行”的两个标准\n\n##### 1. 明确目标，确定关键度\n\n对事情的关键度，最主要的是看你有什么样的目标，与目标相关度越高，关键度会越高。\n\n比如我现在目标是提升自己，虽然玩手机看剧娱乐能让我放松提高效率，但花在这部分的时间不宜过多，它与目标并无什么相关度。\n\n##### 2. 横向对比，确定解决度\n\n对一些你还没做过的事情，在判断解决度时，找一些历史数据、他人的案例进行横向对比。\n\n\n\n## 总结\n\n通过事件角度分析，知道什么事情是属于高价值的事情。而接下来则是把这些事情安排在什么时间完成\n\n#### 我的关键可行矩阵及调整计划\n\n<table>\n  <tbody>\n  \t<tr  style=\"font-weight:700\">\n      <td rowspan=\"15\" style=\"width:35px\">高<br><br>解<br>决<br>度<br><br> 低</td>\n    \t<td colspan=\"2\" >区间一：小插曲</td>\n      <td colspan=\"2\">区间四：高价值陷阱</td>\n    </tr>\n    <tr style=\"font-weight:600\">\n    \t<td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n    \t<td>做饭</td>\n      <td>除特殊情况，中饭交给奶奶做，晚饭妈妈做</td>\n      <td>与人沟通（尤其好朋友的时候）容易想太多</td>\n      <td>这时候听从内心想法<br/>觉得正确则停止想</td>\n    </tr>\n    <tr style=\"font-weight:700\">\n    \t<td colspan=\"2\">区间二：困难游戏</td>\n      <td colspan=\"2\">区间三：无敌洞</td>\n    </tr>\n     <tr style=\"font-weight:600\">\n    \t<td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n    \t<td>玩手机</td>\n      <td>减少玩手机时间，<br/>卸载和在一些时间段禁用不必要的APP</td>\n      <td>框架源码深入理解，看的有些懵</td>\n      <td>搜索找资料，看别人是如何理解的<br/>学习别人的学习经验</td>\n    </tr>\n    <tr>\n    \t<td>看咨询</td>\n      <td>少看咨询，或者在一个时间段集中看</td>\n      <td></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n## 备注\n\n***你的时间花得值吗？一个关键的评判点：*分析这件事对你的长期 短期的益处**\n\n时间的四象限法则：重要和紧急两个维度\n\n","slug":"LEVEL 1/时间管理/3 诊断你的时间/3.2 关键可行矩阵 | 让你用更短的时间，创造更高的价值","published":1,"date":"2020-06-25T03:10:24.434Z","updated":"2020-06-25T03:10:24.434Z","title":"LEVEL 1/时间管理/3 诊断你的时间/3.2 关键可行矩阵 | 让你用更短的时间，创造更高的价值","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpf00193ns63esmhf1n","content":"<p>判断价值的时间分析工具</p>\n<p>有两个方面：事件本身的价值、个人时间规律</p>\n<h4 id=\"先开始事件本身的价值分析\"><a href=\"#先开始事件本身的价值分析\" class=\"headerlink\" title=\"先开始事件本身的价值分析\"></a>先开始事件本身的价值分析</h4><blockquote>\n<p>关键点：我们把时间花在什么事情上面。因为这决定了我们的时间将会创造什么样的价值。</p>\n</blockquote>\n<p>依据时间的四象限：重要、紧急两个维度</p>\n<p>而其中重要紧急的划分，只考虑了工作的产出情况，没有考虑对工作的投入情况。为防止一件重要又紧急的事情，花费你大量的时间，有很难解决它。我们可以用<em>关键度</em>和<em>可解决度</em>这两个维度重新定义时间</p>\n<p><img src=\"https://static.iqycamp.com/challenge-20180829185345-1p5s27b50.jpg\" alt=\"2.jpg\"></p>\n<h4 id=\"1-“小插曲”：解决度高、关键度低\"><a href=\"#1-“小插曲”：解决度高、关键度低\" class=\"headerlink\" title=\"1. “小插曲”：解决度高、关键度低\"></a>1. “小插曲”：解决度高、关键度低</h4><p>最容易对付的问题，如所需花费的时间少，可迅速解决；如花时间多，可授权别人去做。</p>\n<p>比如上班中午吃什么，可以快速决定，或跟随同事</p>\n<h4 id=\"2-“困难游戏”：解决度低、关键度低\"><a href=\"#2-“困难游戏”：解决度低、关键度低\" class=\"headerlink\" title=\"2. “困难游戏”：解决度低、关键度低\"></a>2. “困难游戏”：解决度低、关键度低</h4><p>对于这种问题，你需要设定一个时限，然后以此为标准，时限内能解决的就做，时限内解决不了就放弃。</p>\n<p>比如游戏，抖应，这些刷完了多少量，对你也没什么意义的事情，关键度低，且花费了大量的时间精力。不如放弃</p>\n<h4 id=\"3-“无底洞”：解决度低、关键度高\"><a href=\"#3-“无底洞”：解决度低、关键度高\" class=\"headerlink\" title=\"3. “无底洞”：解决度低、关键度高\"></a>3. “无底洞”：解决度低、关键度高</h4><p>调用情绪脑，听从内心的直觉；或者永远求助他人解决；或者找替代方案。</p>\n<p>比如两个人中选择一个结婚，这个考虑因素很多，无法抉择的时候，不如听从内心呼唤。或者暂时放放。</p>\n<h4 id=\"4-“高价值陷阱”：解决度高、关键度高\"><a href=\"#4-“高价值陷阱”：解决度高、关键度高\" class=\"headerlink\" title=\"4. “高价值陷阱”：解决度高、关键度高\"></a>4. “高价值陷阱”：解决度高、关键度高</h4><p>把时间花在分析和解决这类问题上，才能产生价值。</p>\n<p>比如提升结构化思维能力、分析问题的能力等等。但也可能是“陷阱”：你以为自己在思考和解决问题，其实知识在困扰和焦虑中耗费精力。真正的思考，是你通过手机信息、自我婆媳、咨询他人、分析各种因素等方法，最终进行选择。</p>\n<p><strong><em>所以需要把时间花在分析和解决这类问题上，才能真正产生价值，警惕被困扰在这件事造成的假思考</em></strong></p>\n<h2 id=\"如何利用矩阵分析时间\"><a href=\"#如何利用矩阵分析时间\" class=\"headerlink\" title=\"如何利用矩阵分析时间\"></a>如何利用矩阵分析时间</h2><h4 id=\"利用矩阵调整时间分配的三种方法\"><a href=\"#利用矩阵调整时间分配的三种方法\" class=\"headerlink\" title=\"利用矩阵调整时间分配的三种方法\"></a>利用矩阵调整时间分配的三种方法</h4><h5 id=\"1-减少投入\"><a href=\"#1-减少投入\" class=\"headerlink\" title=\"1. 减少投入\"></a>1. 减少投入</h5><p>如果在“小插曲”以及“困难游戏”上花费的时间高，就减少时间投入，把更多的时间投入到关键度高的事情上。</p>\n<h5 id=\"2-延缓处理\"><a href=\"#2-延缓处理\" class=\"headerlink\" title=\"2. 延缓处理\"></a>2. 延缓处理</h5><p>如果在“无底洞”上耗费很多时间，但仍然没有结果，考虑用直觉块度选择方向、延缓处理、他人帮忙。</p>\n<h5 id=\"3-避免困扰\"><a href=\"#3-避免困扰\" class=\"headerlink\" title=\"3. 避免困扰\"></a>3. 避免困扰</h5><p>判断一下，在处理“高价值陷阱”里面的事情时，是在思考还是困扰</p>\n<h4 id=\"判断时间“关键—可行”的两个标准\"><a href=\"#判断时间“关键—可行”的两个标准\" class=\"headerlink\" title=\"判断时间“关键—可行”的两个标准\"></a>判断时间“关键—可行”的两个标准</h4><h5 id=\"1-明确目标，确定关键度\"><a href=\"#1-明确目标，确定关键度\" class=\"headerlink\" title=\"1. 明确目标，确定关键度\"></a>1. 明确目标，确定关键度</h5><p>对事情的关键度，最主要的是看你有什么样的目标，与目标相关度越高，关键度会越高。</p>\n<p>比如我现在目标是提升自己，虽然玩手机看剧娱乐能让我放松提高效率，但花在这部分的时间不宜过多，它与目标并无什么相关度。</p>\n<h5 id=\"2-横向对比，确定解决度\"><a href=\"#2-横向对比，确定解决度\" class=\"headerlink\" title=\"2. 横向对比，确定解决度\"></a>2. 横向对比，确定解决度</h5><p>对一些你还没做过的事情，在判断解决度时，找一些历史数据、他人的案例进行横向对比。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过事件角度分析，知道什么事情是属于高价值的事情。而接下来则是把这些事情安排在什么时间完成</p>\n<h4 id=\"我的关键可行矩阵及调整计划\"><a href=\"#我的关键可行矩阵及调整计划\" class=\"headerlink\" title=\"我的关键可行矩阵及调整计划\"></a>我的关键可行矩阵及调整计划</h4><table>\n  <tbody>\n      <tr  style=\"font-weight:700\">\n      <td rowspan=\"15\" style=\"width:35px\">高<br><br>解<br>决<br>度<br><br> 低</td>\n        <td colspan=\"2\" >区间一：小插曲</td>\n      <td colspan=\"2\">区间四：高价值陷阱</td>\n    </tr>\n    <tr style=\"font-weight:600\">\n        <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n        <td>做饭</td>\n      <td>除特殊情况，中饭交给奶奶做，晚饭妈妈做</td>\n      <td>与人沟通（尤其好朋友的时候）容易想太多</td>\n      <td>这时候听从内心想法<br/>觉得正确则停止想</td>\n    </tr>\n    <tr style=\"font-weight:700\">\n        <td colspan=\"2\">区间二：困难游戏</td>\n      <td colspan=\"2\">区间三：无敌洞</td>\n    </tr>\n     <tr style=\"font-weight:600\">\n        <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n        <td>玩手机</td>\n      <td>减少玩手机时间，<br/>卸载和在一些时间段禁用不必要的APP</td>\n      <td>框架源码深入理解，看的有些懵</td>\n      <td>搜索找资料，看别人是如何理解的<br/>学习别人的学习经验</td>\n    </tr>\n    <tr>\n        <td>看咨询</td>\n      <td>少看咨询，或者在一个时间段集中看</td>\n      <td></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><p><strong><em>你的时间花得值吗？一个关键的评判点：</em>分析这件事对你的长期 短期的益处</strong></p>\n<p>时间的四象限法则：重要和紧急两个维度</p>\n","site":{"data":{}},"excerpt":"","more":"<p>判断价值的时间分析工具</p>\n<p>有两个方面：事件本身的价值、个人时间规律</p>\n<h4 id=\"先开始事件本身的价值分析\"><a href=\"#先开始事件本身的价值分析\" class=\"headerlink\" title=\"先开始事件本身的价值分析\"></a>先开始事件本身的价值分析</h4><blockquote>\n<p>关键点：我们把时间花在什么事情上面。因为这决定了我们的时间将会创造什么样的价值。</p>\n</blockquote>\n<p>依据时间的四象限：重要、紧急两个维度</p>\n<p>而其中重要紧急的划分，只考虑了工作的产出情况，没有考虑对工作的投入情况。为防止一件重要又紧急的事情，花费你大量的时间，有很难解决它。我们可以用<em>关键度</em>和<em>可解决度</em>这两个维度重新定义时间</p>\n<p><img src=\"https://static.iqycamp.com/challenge-20180829185345-1p5s27b50.jpg\" alt=\"2.jpg\"></p>\n<h4 id=\"1-“小插曲”：解决度高、关键度低\"><a href=\"#1-“小插曲”：解决度高、关键度低\" class=\"headerlink\" title=\"1. “小插曲”：解决度高、关键度低\"></a>1. “小插曲”：解决度高、关键度低</h4><p>最容易对付的问题，如所需花费的时间少，可迅速解决；如花时间多，可授权别人去做。</p>\n<p>比如上班中午吃什么，可以快速决定，或跟随同事</p>\n<h4 id=\"2-“困难游戏”：解决度低、关键度低\"><a href=\"#2-“困难游戏”：解决度低、关键度低\" class=\"headerlink\" title=\"2. “困难游戏”：解决度低、关键度低\"></a>2. “困难游戏”：解决度低、关键度低</h4><p>对于这种问题，你需要设定一个时限，然后以此为标准，时限内能解决的就做，时限内解决不了就放弃。</p>\n<p>比如游戏，抖应，这些刷完了多少量，对你也没什么意义的事情，关键度低，且花费了大量的时间精力。不如放弃</p>\n<h4 id=\"3-“无底洞”：解决度低、关键度高\"><a href=\"#3-“无底洞”：解决度低、关键度高\" class=\"headerlink\" title=\"3. “无底洞”：解决度低、关键度高\"></a>3. “无底洞”：解决度低、关键度高</h4><p>调用情绪脑，听从内心的直觉；或者永远求助他人解决；或者找替代方案。</p>\n<p>比如两个人中选择一个结婚，这个考虑因素很多，无法抉择的时候，不如听从内心呼唤。或者暂时放放。</p>\n<h4 id=\"4-“高价值陷阱”：解决度高、关键度高\"><a href=\"#4-“高价值陷阱”：解决度高、关键度高\" class=\"headerlink\" title=\"4. “高价值陷阱”：解决度高、关键度高\"></a>4. “高价值陷阱”：解决度高、关键度高</h4><p>把时间花在分析和解决这类问题上，才能产生价值。</p>\n<p>比如提升结构化思维能力、分析问题的能力等等。但也可能是“陷阱”：你以为自己在思考和解决问题，其实知识在困扰和焦虑中耗费精力。真正的思考，是你通过手机信息、自我婆媳、咨询他人、分析各种因素等方法，最终进行选择。</p>\n<p><strong><em>所以需要把时间花在分析和解决这类问题上，才能真正产生价值，警惕被困扰在这件事造成的假思考</em></strong></p>\n<h2 id=\"如何利用矩阵分析时间\"><a href=\"#如何利用矩阵分析时间\" class=\"headerlink\" title=\"如何利用矩阵分析时间\"></a>如何利用矩阵分析时间</h2><h4 id=\"利用矩阵调整时间分配的三种方法\"><a href=\"#利用矩阵调整时间分配的三种方法\" class=\"headerlink\" title=\"利用矩阵调整时间分配的三种方法\"></a>利用矩阵调整时间分配的三种方法</h4><h5 id=\"1-减少投入\"><a href=\"#1-减少投入\" class=\"headerlink\" title=\"1. 减少投入\"></a>1. 减少投入</h5><p>如果在“小插曲”以及“困难游戏”上花费的时间高，就减少时间投入，把更多的时间投入到关键度高的事情上。</p>\n<h5 id=\"2-延缓处理\"><a href=\"#2-延缓处理\" class=\"headerlink\" title=\"2. 延缓处理\"></a>2. 延缓处理</h5><p>如果在“无底洞”上耗费很多时间，但仍然没有结果，考虑用直觉块度选择方向、延缓处理、他人帮忙。</p>\n<h5 id=\"3-避免困扰\"><a href=\"#3-避免困扰\" class=\"headerlink\" title=\"3. 避免困扰\"></a>3. 避免困扰</h5><p>判断一下，在处理“高价值陷阱”里面的事情时，是在思考还是困扰</p>\n<h4 id=\"判断时间“关键—可行”的两个标准\"><a href=\"#判断时间“关键—可行”的两个标准\" class=\"headerlink\" title=\"判断时间“关键—可行”的两个标准\"></a>判断时间“关键—可行”的两个标准</h4><h5 id=\"1-明确目标，确定关键度\"><a href=\"#1-明确目标，确定关键度\" class=\"headerlink\" title=\"1. 明确目标，确定关键度\"></a>1. 明确目标，确定关键度</h5><p>对事情的关键度，最主要的是看你有什么样的目标，与目标相关度越高，关键度会越高。</p>\n<p>比如我现在目标是提升自己，虽然玩手机看剧娱乐能让我放松提高效率，但花在这部分的时间不宜过多，它与目标并无什么相关度。</p>\n<h5 id=\"2-横向对比，确定解决度\"><a href=\"#2-横向对比，确定解决度\" class=\"headerlink\" title=\"2. 横向对比，确定解决度\"></a>2. 横向对比，确定解决度</h5><p>对一些你还没做过的事情，在判断解决度时，找一些历史数据、他人的案例进行横向对比。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过事件角度分析，知道什么事情是属于高价值的事情。而接下来则是把这些事情安排在什么时间完成</p>\n<h4 id=\"我的关键可行矩阵及调整计划\"><a href=\"#我的关键可行矩阵及调整计划\" class=\"headerlink\" title=\"我的关键可行矩阵及调整计划\"></a>我的关键可行矩阵及调整计划</h4><table>\n  <tbody>\n      <tr  style=\"font-weight:700\">\n      <td rowspan=\"15\" style=\"width:35px\">高<br><br>解<br>决<br>度<br><br> 低</td>\n        <td colspan=\"2\" >区间一：小插曲</td>\n      <td colspan=\"2\">区间四：高价值陷阱</td>\n    </tr>\n    <tr style=\"font-weight:600\">\n        <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n        <td>做饭</td>\n      <td>除特殊情况，中饭交给奶奶做，晚饭妈妈做</td>\n      <td>与人沟通（尤其好朋友的时候）容易想太多</td>\n      <td>这时候听从内心想法<br/>觉得正确则停止想</td>\n    </tr>\n    <tr style=\"font-weight:700\">\n        <td colspan=\"2\">区间二：困难游戏</td>\n      <td colspan=\"2\">区间三：无敌洞</td>\n    </tr>\n     <tr style=\"font-weight:600\">\n        <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n      <td style=\"width:150px\">事件</td>\n      <td style=\"width:200px\">调整方案</td>\n    </tr>\n    <tr>\n        <td>玩手机</td>\n      <td>减少玩手机时间，<br/>卸载和在一些时间段禁用不必要的APP</td>\n      <td>框架源码深入理解，看的有些懵</td>\n      <td>搜索找资料，看别人是如何理解的<br/>学习别人的学习经验</td>\n    </tr>\n    <tr>\n        <td>看咨询</td>\n      <td>少看咨询，或者在一个时间段集中看</td>\n      <td></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><p><strong><em>你的时间花得值吗？一个关键的评判点：</em>分析这件事对你的长期 短期的益处</strong></p>\n<p>时间的四象限法则：重要和紧急两个维度</p>\n"},{"_content":"## 时间有哪些类型\n\n#### 黄金时间\n\n一天之中最能够集中注意力的大块时间。适合安排高价值、需要深度思考的事情。\n\n#### 常规时间\n\n每天基本固定的时间。适合做哪些需要动一动脑子，但不需要深度思考的事情。\n\n#### 碎片时间\n\n没有被安排的无规律时间。可更具不同的时长和场景，完成意志想做但总找不到时间的事情。\n\n\n\n## 如何充分利用你的时间\n\n#### 1. 在黄金时间进入深度工作\n\n营造深度工作的环境、将浮浅工作授权他人\n\n#### 2. 准备碎片时间清单\n\n- 为不同长度的时间列出场景，以及在这些场景下，可以去完成的事\n- 将需要深度思考的工作拆分为多个小任务，在空闲时间里完成一两个小步骤\n\n#### 3. 养成有节奏的时间习惯\n\n明确自己的黄金时间是什么时候，并为其安排高价值任务，同事也为其他的时间找到合适的事情。\n\n\n\n## 总结\n\n#### 我的黄金时间是什么时候？\n\n现在是待业情况，休息充分，所以一天环境时间会有多个\n\n- 8:00-10:30 \n- 14:30-17:00 （午休后）\n- 20:00-21:30  \n\n#### 在黄金时间要做的事&一定不做的事\n\n<table>\n\t<tr>\n  \t<th style=\"min-width:120px;max-width:300px\">黄金时间</th>\n    <th style=\"min-width:120px;max-width:300px\">要做的事</th>\n    <th style=\"min-width:120px;max-width:300px\">一定不做的事</th>\n  </tr>\n  <tr>\n  \t<td rowspan=\"2\">8:00 - 10:30 </td>\n    <td>学习圈外的课程</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度学习</td>\n    <td>看剧、聊天</td>\n  </tr>\n  <tr>\n  \t<td rowspan=\"2\">15:00 - 17:00 <br>（午休后） </td>\n    <td>前端深度能力提神学习</td>\n    <td>看公众号文章，玩手机、看剧、聊天</td>\n  </tr>\n  <tr>\n    <td>学习总结，以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n   <tr>\n  \t<td rowspan=\"2\">20:00 - 21:30 </td>\n    <td>学习总结以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度能力提升</td>\n    <td>看公众号文章，玩手机、看剧</td>\n  </tr>\n</table>\n\n#### 我的碎片时间清单\n\n<table>\n  <tr>\n  \t<th>时长</th>\n    <th>场景</th>\n    <th>内容</th>\n  </tr>\n  <tr>\n  \t<td>20分钟</td>\n    <td>饭后休息</td>\n    <td>回微信，看咨询</td>\n  </tr>\n  <tr>\n  \t<td>30分钟</td>\n    <td>起床后</td>\n    <td>看咨询，回微信</td>\n  </tr>\n  <tr>\n  \t<td>30分钟</td>\n    <td>早饭后休息</td>\n    <td>回微信，做家务</td>\n  </tr>\n  <tr>\n  \t<td>5小时</td>\n    <td>周末休息的下午</td>\n    <td>看剧，玩手机</td>\n  </tr>\n   <tr>\n  \t<td>30分钟</td>\n    <td>睡前半小时</td>\n    <td>看咨询/聊天</td>\n  </tr>\n</table>\n\n\n\n## 问题\n\n#### 有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\n\n需要借助外部系统来帮助自己（搭建一个外部系统）","source":"_posts/LEVEL 1/时间管理/3 诊断你的时间/3.3 时间分类法 | 找到你的时间规律，发挥时间的最大价值.md","raw":"## 时间有哪些类型\n\n#### 黄金时间\n\n一天之中最能够集中注意力的大块时间。适合安排高价值、需要深度思考的事情。\n\n#### 常规时间\n\n每天基本固定的时间。适合做哪些需要动一动脑子，但不需要深度思考的事情。\n\n#### 碎片时间\n\n没有被安排的无规律时间。可更具不同的时长和场景，完成意志想做但总找不到时间的事情。\n\n\n\n## 如何充分利用你的时间\n\n#### 1. 在黄金时间进入深度工作\n\n营造深度工作的环境、将浮浅工作授权他人\n\n#### 2. 准备碎片时间清单\n\n- 为不同长度的时间列出场景，以及在这些场景下，可以去完成的事\n- 将需要深度思考的工作拆分为多个小任务，在空闲时间里完成一两个小步骤\n\n#### 3. 养成有节奏的时间习惯\n\n明确自己的黄金时间是什么时候，并为其安排高价值任务，同事也为其他的时间找到合适的事情。\n\n\n\n## 总结\n\n#### 我的黄金时间是什么时候？\n\n现在是待业情况，休息充分，所以一天环境时间会有多个\n\n- 8:00-10:30 \n- 14:30-17:00 （午休后）\n- 20:00-21:30  \n\n#### 在黄金时间要做的事&一定不做的事\n\n<table>\n\t<tr>\n  \t<th style=\"min-width:120px;max-width:300px\">黄金时间</th>\n    <th style=\"min-width:120px;max-width:300px\">要做的事</th>\n    <th style=\"min-width:120px;max-width:300px\">一定不做的事</th>\n  </tr>\n  <tr>\n  \t<td rowspan=\"2\">8:00 - 10:30 </td>\n    <td>学习圈外的课程</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度学习</td>\n    <td>看剧、聊天</td>\n  </tr>\n  <tr>\n  \t<td rowspan=\"2\">15:00 - 17:00 <br>（午休后） </td>\n    <td>前端深度能力提神学习</td>\n    <td>看公众号文章，玩手机、看剧、聊天</td>\n  </tr>\n  <tr>\n    <td>学习总结，以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n   <tr>\n  \t<td rowspan=\"2\">20:00 - 21:30 </td>\n    <td>学习总结以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度能力提升</td>\n    <td>看公众号文章，玩手机、看剧</td>\n  </tr>\n</table>\n\n#### 我的碎片时间清单\n\n<table>\n  <tr>\n  \t<th>时长</th>\n    <th>场景</th>\n    <th>内容</th>\n  </tr>\n  <tr>\n  \t<td>20分钟</td>\n    <td>饭后休息</td>\n    <td>回微信，看咨询</td>\n  </tr>\n  <tr>\n  \t<td>30分钟</td>\n    <td>起床后</td>\n    <td>看咨询，回微信</td>\n  </tr>\n  <tr>\n  \t<td>30分钟</td>\n    <td>早饭后休息</td>\n    <td>回微信，做家务</td>\n  </tr>\n  <tr>\n  \t<td>5小时</td>\n    <td>周末休息的下午</td>\n    <td>看剧，玩手机</td>\n  </tr>\n   <tr>\n  \t<td>30分钟</td>\n    <td>睡前半小时</td>\n    <td>看咨询/聊天</td>\n  </tr>\n</table>\n\n\n\n## 问题\n\n#### 有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\n\n需要借助外部系统来帮助自己（搭建一个外部系统）","slug":"LEVEL 1/时间管理/3 诊断你的时间/3.3 时间分类法 | 找到你的时间规律，发挥时间的最大价值","published":1,"date":"2020-06-25T03:10:24.435Z","updated":"2020-06-25T03:10:24.435Z","title":"LEVEL 1/时间管理/3 诊断你的时间/3.3 时间分类法 | 找到你的时间规律，发挥时间的最大价值","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpm001a3ns6bnpw61ro","content":"<h2 id=\"时间有哪些类型\"><a href=\"#时间有哪些类型\" class=\"headerlink\" title=\"时间有哪些类型\"></a>时间有哪些类型</h2><h4 id=\"黄金时间\"><a href=\"#黄金时间\" class=\"headerlink\" title=\"黄金时间\"></a>黄金时间</h4><p>一天之中最能够集中注意力的大块时间。适合安排高价值、需要深度思考的事情。</p>\n<h4 id=\"常规时间\"><a href=\"#常规时间\" class=\"headerlink\" title=\"常规时间\"></a>常规时间</h4><p>每天基本固定的时间。适合做哪些需要动一动脑子，但不需要深度思考的事情。</p>\n<h4 id=\"碎片时间\"><a href=\"#碎片时间\" class=\"headerlink\" title=\"碎片时间\"></a>碎片时间</h4><p>没有被安排的无规律时间。可更具不同的时长和场景，完成意志想做但总找不到时间的事情。</p>\n<h2 id=\"如何充分利用你的时间\"><a href=\"#如何充分利用你的时间\" class=\"headerlink\" title=\"如何充分利用你的时间\"></a>如何充分利用你的时间</h2><h4 id=\"1-在黄金时间进入深度工作\"><a href=\"#1-在黄金时间进入深度工作\" class=\"headerlink\" title=\"1. 在黄金时间进入深度工作\"></a>1. 在黄金时间进入深度工作</h4><p>营造深度工作的环境、将浮浅工作授权他人</p>\n<h4 id=\"2-准备碎片时间清单\"><a href=\"#2-准备碎片时间清单\" class=\"headerlink\" title=\"2. 准备碎片时间清单\"></a>2. 准备碎片时间清单</h4><ul>\n<li>为不同长度的时间列出场景，以及在这些场景下，可以去完成的事</li>\n<li>将需要深度思考的工作拆分为多个小任务，在空闲时间里完成一两个小步骤</li>\n</ul>\n<h4 id=\"3-养成有节奏的时间习惯\"><a href=\"#3-养成有节奏的时间习惯\" class=\"headerlink\" title=\"3. 养成有节奏的时间习惯\"></a>3. 养成有节奏的时间习惯</h4><p>明确自己的黄金时间是什么时候，并为其安排高价值任务，同事也为其他的时间找到合适的事情。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h4 id=\"我的黄金时间是什么时候？\"><a href=\"#我的黄金时间是什么时候？\" class=\"headerlink\" title=\"我的黄金时间是什么时候？\"></a>我的黄金时间是什么时候？</h4><p>现在是待业情况，休息充分，所以一天环境时间会有多个</p>\n<ul>\n<li>8:00-10:30 </li>\n<li>14:30-17:00 （午休后）</li>\n<li>20:00-21:30  </li>\n</ul>\n<h4 id=\"在黄金时间要做的事-amp-一定不做的事\"><a href=\"#在黄金时间要做的事-amp-一定不做的事\" class=\"headerlink\" title=\"在黄金时间要做的事&amp;一定不做的事\"></a>在黄金时间要做的事&amp;一定不做的事</h4><table>\n    <tr>\n      <th style=\"min-width:120px;max-width:300px\">黄金时间</th>\n    <th style=\"min-width:120px;max-width:300px\">要做的事</th>\n    <th style=\"min-width:120px;max-width:300px\">一定不做的事</th>\n  </tr>\n  <tr>\n      <td rowspan=\"2\">8:00 - 10:30 </td>\n    <td>学习圈外的课程</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度学习</td>\n    <td>看剧、聊天</td>\n  </tr>\n  <tr>\n      <td rowspan=\"2\">15:00 - 17:00 <br>（午休后） </td>\n    <td>前端深度能力提神学习</td>\n    <td>看公众号文章，玩手机、看剧、聊天</td>\n  </tr>\n  <tr>\n    <td>学习总结，以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n   <tr>\n      <td rowspan=\"2\">20:00 - 21:30 </td>\n    <td>学习总结以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度能力提升</td>\n    <td>看公众号文章，玩手机、看剧</td>\n  </tr>\n</table>\n\n<h4 id=\"我的碎片时间清单\"><a href=\"#我的碎片时间清单\" class=\"headerlink\" title=\"我的碎片时间清单\"></a>我的碎片时间清单</h4><table>\n  <tr>\n      <th>时长</th>\n    <th>场景</th>\n    <th>内容</th>\n  </tr>\n  <tr>\n      <td>20分钟</td>\n    <td>饭后休息</td>\n    <td>回微信，看咨询</td>\n  </tr>\n  <tr>\n      <td>30分钟</td>\n    <td>起床后</td>\n    <td>看咨询，回微信</td>\n  </tr>\n  <tr>\n      <td>30分钟</td>\n    <td>早饭后休息</td>\n    <td>回微信，做家务</td>\n  </tr>\n  <tr>\n      <td>5小时</td>\n    <td>周末休息的下午</td>\n    <td>看剧，玩手机</td>\n  </tr>\n   <tr>\n      <td>30分钟</td>\n    <td>睡前半小时</td>\n    <td>看咨询/聊天</td>\n  </tr>\n</table>\n\n\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h4 id=\"有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\"><a href=\"#有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\" class=\"headerlink\" title=\"有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\"></a>有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？</h4><p>需要借助外部系统来帮助自己（搭建一个外部系统）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"时间有哪些类型\"><a href=\"#时间有哪些类型\" class=\"headerlink\" title=\"时间有哪些类型\"></a>时间有哪些类型</h2><h4 id=\"黄金时间\"><a href=\"#黄金时间\" class=\"headerlink\" title=\"黄金时间\"></a>黄金时间</h4><p>一天之中最能够集中注意力的大块时间。适合安排高价值、需要深度思考的事情。</p>\n<h4 id=\"常规时间\"><a href=\"#常规时间\" class=\"headerlink\" title=\"常规时间\"></a>常规时间</h4><p>每天基本固定的时间。适合做哪些需要动一动脑子，但不需要深度思考的事情。</p>\n<h4 id=\"碎片时间\"><a href=\"#碎片时间\" class=\"headerlink\" title=\"碎片时间\"></a>碎片时间</h4><p>没有被安排的无规律时间。可更具不同的时长和场景，完成意志想做但总找不到时间的事情。</p>\n<h2 id=\"如何充分利用你的时间\"><a href=\"#如何充分利用你的时间\" class=\"headerlink\" title=\"如何充分利用你的时间\"></a>如何充分利用你的时间</h2><h4 id=\"1-在黄金时间进入深度工作\"><a href=\"#1-在黄金时间进入深度工作\" class=\"headerlink\" title=\"1. 在黄金时间进入深度工作\"></a>1. 在黄金时间进入深度工作</h4><p>营造深度工作的环境、将浮浅工作授权他人</p>\n<h4 id=\"2-准备碎片时间清单\"><a href=\"#2-准备碎片时间清单\" class=\"headerlink\" title=\"2. 准备碎片时间清单\"></a>2. 准备碎片时间清单</h4><ul>\n<li>为不同长度的时间列出场景，以及在这些场景下，可以去完成的事</li>\n<li>将需要深度思考的工作拆分为多个小任务，在空闲时间里完成一两个小步骤</li>\n</ul>\n<h4 id=\"3-养成有节奏的时间习惯\"><a href=\"#3-养成有节奏的时间习惯\" class=\"headerlink\" title=\"3. 养成有节奏的时间习惯\"></a>3. 养成有节奏的时间习惯</h4><p>明确自己的黄金时间是什么时候，并为其安排高价值任务，同事也为其他的时间找到合适的事情。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h4 id=\"我的黄金时间是什么时候？\"><a href=\"#我的黄金时间是什么时候？\" class=\"headerlink\" title=\"我的黄金时间是什么时候？\"></a>我的黄金时间是什么时候？</h4><p>现在是待业情况，休息充分，所以一天环境时间会有多个</p>\n<ul>\n<li>8:00-10:30 </li>\n<li>14:30-17:00 （午休后）</li>\n<li>20:00-21:30  </li>\n</ul>\n<h4 id=\"在黄金时间要做的事-amp-一定不做的事\"><a href=\"#在黄金时间要做的事-amp-一定不做的事\" class=\"headerlink\" title=\"在黄金时间要做的事&amp;一定不做的事\"></a>在黄金时间要做的事&amp;一定不做的事</h4><table>\n    <tr>\n      <th style=\"min-width:120px;max-width:300px\">黄金时间</th>\n    <th style=\"min-width:120px;max-width:300px\">要做的事</th>\n    <th style=\"min-width:120px;max-width:300px\">一定不做的事</th>\n  </tr>\n  <tr>\n      <td rowspan=\"2\">8:00 - 10:30 </td>\n    <td>学习圈外的课程</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度学习</td>\n    <td>看剧、聊天</td>\n  </tr>\n  <tr>\n      <td rowspan=\"2\">15:00 - 17:00 <br>（午休后） </td>\n    <td>前端深度能力提神学习</td>\n    <td>看公众号文章，玩手机、看剧、聊天</td>\n  </tr>\n  <tr>\n    <td>学习总结，以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n   <tr>\n      <td rowspan=\"2\">20:00 - 21:30 </td>\n    <td>学习总结以及阅读</td>\n    <td>看公众号文章，玩手机</td>\n  </tr>\n  <tr>\n    <td>前端深度能力提升</td>\n    <td>看公众号文章，玩手机、看剧</td>\n  </tr>\n</table>\n\n<h4 id=\"我的碎片时间清单\"><a href=\"#我的碎片时间清单\" class=\"headerlink\" title=\"我的碎片时间清单\"></a>我的碎片时间清单</h4><table>\n  <tr>\n      <th>时长</th>\n    <th>场景</th>\n    <th>内容</th>\n  </tr>\n  <tr>\n      <td>20分钟</td>\n    <td>饭后休息</td>\n    <td>回微信，看咨询</td>\n  </tr>\n  <tr>\n      <td>30分钟</td>\n    <td>起床后</td>\n    <td>看咨询，回微信</td>\n  </tr>\n  <tr>\n      <td>30分钟</td>\n    <td>早饭后休息</td>\n    <td>回微信，做家务</td>\n  </tr>\n  <tr>\n      <td>5小时</td>\n    <td>周末休息的下午</td>\n    <td>看剧，玩手机</td>\n  </tr>\n   <tr>\n      <td>30分钟</td>\n    <td>睡前半小时</td>\n    <td>看咨询/聊天</td>\n  </tr>\n</table>\n\n\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h4 id=\"有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\"><a href=\"#有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\" class=\"headerlink\" title=\"有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？\"></a>有些突发的事情难以避免，或者有多任务，这种情况下如何集中精神？</h4><p>需要借助外部系统来帮助自己（搭建一个外部系统）</p>\n"},{"_content":"> 我们把任何任务都放在大脑里，会严重影响我们的效率，因为我们会有对哪些还没有完成的事情，有一种想要把它完成的冲动，否则就会一直想到它。或者想不起来。\n\n## 你需要什么样的管理系统\n\n> 我需要一个可以帮我管理并记录任务的管理系统，我只需要设计它并且花一点时间录入和完善，它到时间提醒我，并帮我做记录，方便我回顾统计分析。\n\n#### RAR管理法\n\nR记录|record-A安排|arrange-R回顾|review\n\nRAR的核心思想来源于：GTD（Get Things Done）,但更加简单实用\n\n## 如何搭建时间管理系统\n\n#### 记录Record\n\n- 百分百的记录\n- 收纳箱保持统一（保持工具统一）\n- 定期清空收纳箱；以及记录待办事项。\n\n*已在执行，APP记录（参照时间记录发原则）*\n\n#### 安排Arrange\n\n- 这件事还要不要做\n\n- 这件事属于关键可行矩阵的哪个区间\n\n- 这件事什么时候由谁来做\n\n  日历和行动清单\n\n#### 回顾Review\n\n>  **睡前写计划 或 早晨计划**\n\n- 完成了什么、推进来什么\n- 对哪些满意哪些不满意\n- 接下来的规划是什么\n\n","source":"_posts/LEVEL 1/时间管理/4 打造你的时间管理系统/4.1 RAR管理法 | 打造时间管理系统，释放你的大脑.md","raw":"> 我们把任何任务都放在大脑里，会严重影响我们的效率，因为我们会有对哪些还没有完成的事情，有一种想要把它完成的冲动，否则就会一直想到它。或者想不起来。\n\n## 你需要什么样的管理系统\n\n> 我需要一个可以帮我管理并记录任务的管理系统，我只需要设计它并且花一点时间录入和完善，它到时间提醒我，并帮我做记录，方便我回顾统计分析。\n\n#### RAR管理法\n\nR记录|record-A安排|arrange-R回顾|review\n\nRAR的核心思想来源于：GTD（Get Things Done）,但更加简单实用\n\n## 如何搭建时间管理系统\n\n#### 记录Record\n\n- 百分百的记录\n- 收纳箱保持统一（保持工具统一）\n- 定期清空收纳箱；以及记录待办事项。\n\n*已在执行，APP记录（参照时间记录发原则）*\n\n#### 安排Arrange\n\n- 这件事还要不要做\n\n- 这件事属于关键可行矩阵的哪个区间\n\n- 这件事什么时候由谁来做\n\n  日历和行动清单\n\n#### 回顾Review\n\n>  **睡前写计划 或 早晨计划**\n\n- 完成了什么、推进来什么\n- 对哪些满意哪些不满意\n- 接下来的规划是什么\n\n","slug":"LEVEL 1/时间管理/4 打造你的时间管理系统/4.1 RAR管理法 | 打造时间管理系统，释放你的大脑","published":1,"date":"2020-06-25T03:10:24.437Z","updated":"2020-06-25T03:10:24.437Z","title":"LEVEL 1/时间管理/4 打造你的时间管理系统/4.1 RAR管理法 | 打造时间管理系统，释放你的大脑","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpn001b3ns62mn3glbt","content":"<blockquote>\n<p>我们把任何任务都放在大脑里，会严重影响我们的效率，因为我们会有对哪些还没有完成的事情，有一种想要把它完成的冲动，否则就会一直想到它。或者想不起来。</p>\n</blockquote>\n<h2 id=\"你需要什么样的管理系统\"><a href=\"#你需要什么样的管理系统\" class=\"headerlink\" title=\"你需要什么样的管理系统\"></a>你需要什么样的管理系统</h2><blockquote>\n<p>我需要一个可以帮我管理并记录任务的管理系统，我只需要设计它并且花一点时间录入和完善，它到时间提醒我，并帮我做记录，方便我回顾统计分析。</p>\n</blockquote>\n<h4 id=\"RAR管理法\"><a href=\"#RAR管理法\" class=\"headerlink\" title=\"RAR管理法\"></a>RAR管理法</h4><p>R记录|record-A安排|arrange-R回顾|review</p>\n<p>RAR的核心思想来源于：GTD（Get Things Done）,但更加简单实用</p>\n<h2 id=\"如何搭建时间管理系统\"><a href=\"#如何搭建时间管理系统\" class=\"headerlink\" title=\"如何搭建时间管理系统\"></a>如何搭建时间管理系统</h2><h4 id=\"记录Record\"><a href=\"#记录Record\" class=\"headerlink\" title=\"记录Record\"></a>记录Record</h4><ul>\n<li>百分百的记录</li>\n<li>收纳箱保持统一（保持工具统一）</li>\n<li>定期清空收纳箱；以及记录待办事项。</li>\n</ul>\n<p><em>已在执行，APP记录（参照时间记录发原则）</em></p>\n<h4 id=\"安排Arrange\"><a href=\"#安排Arrange\" class=\"headerlink\" title=\"安排Arrange\"></a>安排Arrange</h4><ul>\n<li><p>这件事还要不要做</p>\n</li>\n<li><p>这件事属于关键可行矩阵的哪个区间</p>\n</li>\n<li><p>这件事什么时候由谁来做</p>\n<p>日历和行动清单</p>\n</li>\n</ul>\n<h4 id=\"回顾Review\"><a href=\"#回顾Review\" class=\"headerlink\" title=\"回顾Review\"></a>回顾Review</h4><blockquote>\n<p> <strong>睡前写计划 或 早晨计划</strong></p>\n</blockquote>\n<ul>\n<li>完成了什么、推进来什么</li>\n<li>对哪些满意哪些不满意</li>\n<li>接下来的规划是什么</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我们把任何任务都放在大脑里，会严重影响我们的效率，因为我们会有对哪些还没有完成的事情，有一种想要把它完成的冲动，否则就会一直想到它。或者想不起来。</p>\n</blockquote>\n<h2 id=\"你需要什么样的管理系统\"><a href=\"#你需要什么样的管理系统\" class=\"headerlink\" title=\"你需要什么样的管理系统\"></a>你需要什么样的管理系统</h2><blockquote>\n<p>我需要一个可以帮我管理并记录任务的管理系统，我只需要设计它并且花一点时间录入和完善，它到时间提醒我，并帮我做记录，方便我回顾统计分析。</p>\n</blockquote>\n<h4 id=\"RAR管理法\"><a href=\"#RAR管理法\" class=\"headerlink\" title=\"RAR管理法\"></a>RAR管理法</h4><p>R记录|record-A安排|arrange-R回顾|review</p>\n<p>RAR的核心思想来源于：GTD（Get Things Done）,但更加简单实用</p>\n<h2 id=\"如何搭建时间管理系统\"><a href=\"#如何搭建时间管理系统\" class=\"headerlink\" title=\"如何搭建时间管理系统\"></a>如何搭建时间管理系统</h2><h4 id=\"记录Record\"><a href=\"#记录Record\" class=\"headerlink\" title=\"记录Record\"></a>记录Record</h4><ul>\n<li>百分百的记录</li>\n<li>收纳箱保持统一（保持工具统一）</li>\n<li>定期清空收纳箱；以及记录待办事项。</li>\n</ul>\n<p><em>已在执行，APP记录（参照时间记录发原则）</em></p>\n<h4 id=\"安排Arrange\"><a href=\"#安排Arrange\" class=\"headerlink\" title=\"安排Arrange\"></a>安排Arrange</h4><ul>\n<li><p>这件事还要不要做</p>\n</li>\n<li><p>这件事属于关键可行矩阵的哪个区间</p>\n</li>\n<li><p>这件事什么时候由谁来做</p>\n<p>日历和行动清单</p>\n</li>\n</ul>\n<h4 id=\"回顾Review\"><a href=\"#回顾Review\" class=\"headerlink\" title=\"回顾Review\"></a>回顾Review</h4><blockquote>\n<p> <strong>睡前写计划 或 早晨计划</strong></p>\n</blockquote>\n<ul>\n<li>完成了什么、推进来什么</li>\n<li>对哪些满意哪些不满意</li>\n<li>接下来的规划是什么</li>\n</ul>\n"},{"_content":"## 善用日历\n\n> 利用日历和清单进行时间管理，其实就是管理你的承若。\n>\n> 先把大石子放入玻璃瓶，再倒入沙子。每天先将高价值事情安排上，再安排小插曲和困难游戏\n\n#### 放进日历的两种事件类型\n\n1. 开始利用时间和截止时间都确定\n\n   利用帕金森定律，需要在定下确定的deadline时，不给自己留后路\n\n2. 开始时间已知，结束时间未知\n\n   先定时间再调整\n\n## 巧用行动清单\n\n#### 巧用行动清单的三个要点\n\n1. 把任务转化为行动\n\n   在行动描述时，可以用动词开头、描述结果、设定期限这三个技巧来进行细化。当你通过把任务转化为行动之后，看到清单的每一项都可以立刻去执行，不会因为思考而产生延误。\n\n   - 动词开头\n\n     以动词开头 保证这是一件能够执行的事情\n\n   - 描述结果\n\n     描述越清晰就可以产生越大的行动力\n\n   - 设定期限\n\n     明确什么时候开始，可以更好的把握这个行动的进度。当然遇突发情况，可以灵活调整。\n\n2. 按情境给清单分类\n\n   给清单进行分类，比如办公清单、学习清单、阅读清单、聊天清单等等\n\n3. 预留弹性时间\n\n   每天安排任务的时候，最少也要留出20%的弹性时间，这样遇突发紧急状况，可以灵活调整。不至于整个时间安排像多米若一样，一块骨牌倒下，引发发生连锁反应。\n\n\n\n## 结语\n\n> 所谓的高效能人士，并不是因为他们知道普通人不知道的道理，而是他们把人人知道的道理，做到普通人做不到的程度\n\n","source":"_posts/LEVEL 1/时间管理/4 打造你的时间管理系统/4.2 时间管理工具 | 让工具为你创造更多自由时间.md","raw":"## 善用日历\n\n> 利用日历和清单进行时间管理，其实就是管理你的承若。\n>\n> 先把大石子放入玻璃瓶，再倒入沙子。每天先将高价值事情安排上，再安排小插曲和困难游戏\n\n#### 放进日历的两种事件类型\n\n1. 开始利用时间和截止时间都确定\n\n   利用帕金森定律，需要在定下确定的deadline时，不给自己留后路\n\n2. 开始时间已知，结束时间未知\n\n   先定时间再调整\n\n## 巧用行动清单\n\n#### 巧用行动清单的三个要点\n\n1. 把任务转化为行动\n\n   在行动描述时，可以用动词开头、描述结果、设定期限这三个技巧来进行细化。当你通过把任务转化为行动之后，看到清单的每一项都可以立刻去执行，不会因为思考而产生延误。\n\n   - 动词开头\n\n     以动词开头 保证这是一件能够执行的事情\n\n   - 描述结果\n\n     描述越清晰就可以产生越大的行动力\n\n   - 设定期限\n\n     明确什么时候开始，可以更好的把握这个行动的进度。当然遇突发情况，可以灵活调整。\n\n2. 按情境给清单分类\n\n   给清单进行分类，比如办公清单、学习清单、阅读清单、聊天清单等等\n\n3. 预留弹性时间\n\n   每天安排任务的时候，最少也要留出20%的弹性时间，这样遇突发紧急状况，可以灵活调整。不至于整个时间安排像多米若一样，一块骨牌倒下，引发发生连锁反应。\n\n\n\n## 结语\n\n> 所谓的高效能人士，并不是因为他们知道普通人不知道的道理，而是他们把人人知道的道理，做到普通人做不到的程度\n\n","slug":"LEVEL 1/时间管理/4 打造你的时间管理系统/4.2 时间管理工具 | 让工具为你创造更多自由时间","published":1,"date":"2020-06-25T03:10:24.437Z","updated":"2020-06-25T03:10:24.438Z","title":"LEVEL 1/时间管理/4 打造你的时间管理系统/4.2 时间管理工具 | 让工具为你创造更多自由时间","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpn001c3ns6estjbd97","content":"<h2 id=\"善用日历\"><a href=\"#善用日历\" class=\"headerlink\" title=\"善用日历\"></a>善用日历</h2><blockquote>\n<p>利用日历和清单进行时间管理，其实就是管理你的承若。</p>\n<p>先把大石子放入玻璃瓶，再倒入沙子。每天先将高价值事情安排上，再安排小插曲和困难游戏</p>\n</blockquote>\n<h4 id=\"放进日历的两种事件类型\"><a href=\"#放进日历的两种事件类型\" class=\"headerlink\" title=\"放进日历的两种事件类型\"></a>放进日历的两种事件类型</h4><ol>\n<li><p>开始利用时间和截止时间都确定</p>\n<p>利用帕金森定律，需要在定下确定的deadline时，不给自己留后路</p>\n</li>\n<li><p>开始时间已知，结束时间未知</p>\n<p>先定时间再调整</p>\n</li>\n</ol>\n<h2 id=\"巧用行动清单\"><a href=\"#巧用行动清单\" class=\"headerlink\" title=\"巧用行动清单\"></a>巧用行动清单</h2><h4 id=\"巧用行动清单的三个要点\"><a href=\"#巧用行动清单的三个要点\" class=\"headerlink\" title=\"巧用行动清单的三个要点\"></a>巧用行动清单的三个要点</h4><ol>\n<li><p>把任务转化为行动</p>\n<p>在行动描述时，可以用动词开头、描述结果、设定期限这三个技巧来进行细化。当你通过把任务转化为行动之后，看到清单的每一项都可以立刻去执行，不会因为思考而产生延误。</p>\n<ul>\n<li><p>动词开头</p>\n<p>以动词开头 保证这是一件能够执行的事情</p>\n</li>\n<li><p>描述结果</p>\n<p>描述越清晰就可以产生越大的行动力</p>\n</li>\n<li><p>设定期限</p>\n<p>明确什么时候开始，可以更好的把握这个行动的进度。当然遇突发情况，可以灵活调整。</p>\n</li>\n</ul>\n</li>\n<li><p>按情境给清单分类</p>\n<p>给清单进行分类，比如办公清单、学习清单、阅读清单、聊天清单等等</p>\n</li>\n<li><p>预留弹性时间</p>\n<p>每天安排任务的时候，最少也要留出20%的弹性时间，这样遇突发紧急状况，可以灵活调整。不至于整个时间安排像多米若一样，一块骨牌倒下，引发发生连锁反应。</p>\n</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><blockquote>\n<p>所谓的高效能人士，并不是因为他们知道普通人不知道的道理，而是他们把人人知道的道理，做到普通人做不到的程度</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"善用日历\"><a href=\"#善用日历\" class=\"headerlink\" title=\"善用日历\"></a>善用日历</h2><blockquote>\n<p>利用日历和清单进行时间管理，其实就是管理你的承若。</p>\n<p>先把大石子放入玻璃瓶，再倒入沙子。每天先将高价值事情安排上，再安排小插曲和困难游戏</p>\n</blockquote>\n<h4 id=\"放进日历的两种事件类型\"><a href=\"#放进日历的两种事件类型\" class=\"headerlink\" title=\"放进日历的两种事件类型\"></a>放进日历的两种事件类型</h4><ol>\n<li><p>开始利用时间和截止时间都确定</p>\n<p>利用帕金森定律，需要在定下确定的deadline时，不给自己留后路</p>\n</li>\n<li><p>开始时间已知，结束时间未知</p>\n<p>先定时间再调整</p>\n</li>\n</ol>\n<h2 id=\"巧用行动清单\"><a href=\"#巧用行动清单\" class=\"headerlink\" title=\"巧用行动清单\"></a>巧用行动清单</h2><h4 id=\"巧用行动清单的三个要点\"><a href=\"#巧用行动清单的三个要点\" class=\"headerlink\" title=\"巧用行动清单的三个要点\"></a>巧用行动清单的三个要点</h4><ol>\n<li><p>把任务转化为行动</p>\n<p>在行动描述时，可以用动词开头、描述结果、设定期限这三个技巧来进行细化。当你通过把任务转化为行动之后，看到清单的每一项都可以立刻去执行，不会因为思考而产生延误。</p>\n<ul>\n<li><p>动词开头</p>\n<p>以动词开头 保证这是一件能够执行的事情</p>\n</li>\n<li><p>描述结果</p>\n<p>描述越清晰就可以产生越大的行动力</p>\n</li>\n<li><p>设定期限</p>\n<p>明确什么时候开始，可以更好的把握这个行动的进度。当然遇突发情况，可以灵活调整。</p>\n</li>\n</ul>\n</li>\n<li><p>按情境给清单分类</p>\n<p>给清单进行分类，比如办公清单、学习清单、阅读清单、聊天清单等等</p>\n</li>\n<li><p>预留弹性时间</p>\n<p>每天安排任务的时候，最少也要留出20%的弹性时间，这样遇突发紧急状况，可以灵活调整。不至于整个时间安排像多米若一样，一块骨牌倒下，引发发生连锁反应。</p>\n</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><blockquote>\n<p>所谓的高效能人士，并不是因为他们知道普通人不知道的道理，而是他们把人人知道的道理，做到普通人做不到的程度</p>\n</blockquote>\n"},{"_content":"## 实现“以始为终”\n\n#### 将“以始为终”付诸实践的两大步骤\n\n1. 明确我们的最终目的\n\n   - 从职位本身出发\n\n     基于该职位的职责，做这件事的目的是什么？\n\n   - 从公司重点出发\n\n     从公司近期目标来看，做这件事的目的事什么？\n\n   - 从任务本身出发\n\n     这件事本身的目的事什么？\n\n2. 从目的出发\n\n   - 列出所有的待办事项，分为“可以做，但不做也无妨”和“必须走，不做会出大麻烦”两种\n   - 可以以天、周、月、年为单位\n\n\n\n## 备注\n\n- 做事情前，弄清楚事情的根本目的什么\n- 最重要的事只有一件\n- 二八法则（很多时候，我们花20%的精力就可以做到80%的完美程度）","source":"_posts/LEVEL 1/高效工作/1 做正确的事/1.1 结果导向、极致专心.md","raw":"## 实现“以始为终”\n\n#### 将“以始为终”付诸实践的两大步骤\n\n1. 明确我们的最终目的\n\n   - 从职位本身出发\n\n     基于该职位的职责，做这件事的目的是什么？\n\n   - 从公司重点出发\n\n     从公司近期目标来看，做这件事的目的事什么？\n\n   - 从任务本身出发\n\n     这件事本身的目的事什么？\n\n2. 从目的出发\n\n   - 列出所有的待办事项，分为“可以做，但不做也无妨”和“必须走，不做会出大麻烦”两种\n   - 可以以天、周、月、年为单位\n\n\n\n## 备注\n\n- 做事情前，弄清楚事情的根本目的什么\n- 最重要的事只有一件\n- 二八法则（很多时候，我们花20%的精力就可以做到80%的完美程度）","slug":"LEVEL 1/高效工作/1 做正确的事/1.1 结果导向、极致专心","published":1,"date":"2020-06-25T03:10:24.442Z","updated":"2020-06-25T03:10:24.442Z","title":"LEVEL 1/高效工作/1 做正确的事/1.1 结果导向、极致专心","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpo001d3ns6ds3f1zia","content":"<h2 id=\"实现“以始为终”\"><a href=\"#实现“以始为终”\" class=\"headerlink\" title=\"实现“以始为终”\"></a>实现“以始为终”</h2><h4 id=\"将“以始为终”付诸实践的两大步骤\"><a href=\"#将“以始为终”付诸实践的两大步骤\" class=\"headerlink\" title=\"将“以始为终”付诸实践的两大步骤\"></a>将“以始为终”付诸实践的两大步骤</h4><ol>\n<li><p>明确我们的最终目的</p>\n<ul>\n<li><p>从职位本身出发</p>\n<p>基于该职位的职责，做这件事的目的是什么？</p>\n</li>\n<li><p>从公司重点出发</p>\n<p>从公司近期目标来看，做这件事的目的事什么？</p>\n</li>\n<li><p>从任务本身出发</p>\n<p>这件事本身的目的事什么？</p>\n</li>\n</ul>\n</li>\n<li><p>从目的出发</p>\n<ul>\n<li>列出所有的待办事项，分为“可以做，但不做也无妨”和“必须走，不做会出大麻烦”两种</li>\n<li>可以以天、周、月、年为单位</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><ul>\n<li>做事情前，弄清楚事情的根本目的什么</li>\n<li>最重要的事只有一件</li>\n<li>二八法则（很多时候，我们花20%的精力就可以做到80%的完美程度）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实现“以始为终”\"><a href=\"#实现“以始为终”\" class=\"headerlink\" title=\"实现“以始为终”\"></a>实现“以始为终”</h2><h4 id=\"将“以始为终”付诸实践的两大步骤\"><a href=\"#将“以始为终”付诸实践的两大步骤\" class=\"headerlink\" title=\"将“以始为终”付诸实践的两大步骤\"></a>将“以始为终”付诸实践的两大步骤</h4><ol>\n<li><p>明确我们的最终目的</p>\n<ul>\n<li><p>从职位本身出发</p>\n<p>基于该职位的职责，做这件事的目的是什么？</p>\n</li>\n<li><p>从公司重点出发</p>\n<p>从公司近期目标来看，做这件事的目的事什么？</p>\n</li>\n<li><p>从任务本身出发</p>\n<p>这件事本身的目的事什么？</p>\n</li>\n</ul>\n</li>\n<li><p>从目的出发</p>\n<ul>\n<li>列出所有的待办事项，分为“可以做，但不做也无妨”和“必须走，不做会出大麻烦”两种</li>\n<li>可以以天、周、月、年为单位</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><ul>\n<li>做事情前，弄清楚事情的根本目的什么</li>\n<li>最重要的事只有一件</li>\n<li>二八法则（很多时候，我们花20%的精力就可以做到80%的完美程度）</li>\n</ul>\n"},{"_content":"## 为何要借助外部力量\n\n> 在明确了正确的事后，善于借助外部力量。来提高工作的效率正确地做事，以节省自己所花费的精力\n\n## 如何借助外部力量\n\n> 工作中，可以借助的力量：资深人士、资料和数据。**站在巨人的肩膀上，把事情做的更好**\n\n#### 求助资深人士\n\n- 提问时候，不要问简答题，而是问 **选择题** 或 **判断题**\n- 提前做准备很重要\n\n#### 借助资料和数据\n\n- 借以参考而不是从零开始\n- 定期整理资料、素材，以便以后查找","source":"_posts/LEVEL 1/高效工作/2 正确地做事/2.1 善于借助外部力量.md","raw":"## 为何要借助外部力量\n\n> 在明确了正确的事后，善于借助外部力量。来提高工作的效率正确地做事，以节省自己所花费的精力\n\n## 如何借助外部力量\n\n> 工作中，可以借助的力量：资深人士、资料和数据。**站在巨人的肩膀上，把事情做的更好**\n\n#### 求助资深人士\n\n- 提问时候，不要问简答题，而是问 **选择题** 或 **判断题**\n- 提前做准备很重要\n\n#### 借助资料和数据\n\n- 借以参考而不是从零开始\n- 定期整理资料、素材，以便以后查找","slug":"LEVEL 1/高效工作/2 正确地做事/2.1 善于借助外部力量","published":1,"date":"2020-06-25T03:10:24.443Z","updated":"2020-06-25T03:10:24.443Z","title":"LEVEL 1/高效工作/2 正确地做事/2.1 善于借助外部力量","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpp001e3ns6dcsr4v8o","content":"<h2 id=\"为何要借助外部力量\"><a href=\"#为何要借助外部力量\" class=\"headerlink\" title=\"为何要借助外部力量\"></a>为何要借助外部力量</h2><blockquote>\n<p>在明确了正确的事后，善于借助外部力量。来提高工作的效率正确地做事，以节省自己所花费的精力</p>\n</blockquote>\n<h2 id=\"如何借助外部力量\"><a href=\"#如何借助外部力量\" class=\"headerlink\" title=\"如何借助外部力量\"></a>如何借助外部力量</h2><blockquote>\n<p>工作中，可以借助的力量：资深人士、资料和数据。<strong>站在巨人的肩膀上，把事情做的更好</strong></p>\n</blockquote>\n<h4 id=\"求助资深人士\"><a href=\"#求助资深人士\" class=\"headerlink\" title=\"求助资深人士\"></a>求助资深人士</h4><ul>\n<li>提问时候，不要问简答题，而是问 <strong>选择题</strong> 或 <strong>判断题</strong></li>\n<li>提前做准备很重要</li>\n</ul>\n<h4 id=\"借助资料和数据\"><a href=\"#借助资料和数据\" class=\"headerlink\" title=\"借助资料和数据\"></a>借助资料和数据</h4><ul>\n<li>借以参考而不是从零开始</li>\n<li>定期整理资料、素材，以便以后查找</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为何要借助外部力量\"><a href=\"#为何要借助外部力量\" class=\"headerlink\" title=\"为何要借助外部力量\"></a>为何要借助外部力量</h2><blockquote>\n<p>在明确了正确的事后，善于借助外部力量。来提高工作的效率正确地做事，以节省自己所花费的精力</p>\n</blockquote>\n<h2 id=\"如何借助外部力量\"><a href=\"#如何借助外部力量\" class=\"headerlink\" title=\"如何借助外部力量\"></a>如何借助外部力量</h2><blockquote>\n<p>工作中，可以借助的力量：资深人士、资料和数据。<strong>站在巨人的肩膀上，把事情做的更好</strong></p>\n</blockquote>\n<h4 id=\"求助资深人士\"><a href=\"#求助资深人士\" class=\"headerlink\" title=\"求助资深人士\"></a>求助资深人士</h4><ul>\n<li>提问时候，不要问简答题，而是问 <strong>选择题</strong> 或 <strong>判断题</strong></li>\n<li>提前做准备很重要</li>\n</ul>\n<h4 id=\"借助资料和数据\"><a href=\"#借助资料和数据\" class=\"headerlink\" title=\"借助资料和数据\"></a>借助资料和数据</h4><ul>\n<li>借以参考而不是从零开始</li>\n<li>定期整理资料、素材，以便以后查找</li>\n</ul>\n"},{"_content":"## 如何小步快跑、是错迭代\n\n#### 为何需小步快跑、试错迭代\n\n1. 完成比完美更重要，没有100%完美的事，为自己减负，从而避免拖延\n2. 互联网时代，不存在完美的计划，按图索骥，很容易因环境变化而前功尽弃\n\n#### 如何小步快跑、试错迭代\n\n1. 用最快的速度，做出满足核心功能的简单版本，即使粗糙，也是一个成品\n2. 不断更新版本，添加其他辅助功能或美化\n3. 在过程中，保持对环境变化的敏感\n4. 不断地提出假设，随时调整，找到最终方向\n5. 通过打磨，不断接近完美\n\n## 工作化游戏\n\n#### 游戏特点：\n\n- 玩家是资源参与\n- 游戏中的每一步都有明确的目标\n- 游戏中的规则是明确而固定的\n- 游戏中有着打鸡血般及时的反馈和奖励\n\n#### 小步快跑、试错迭代要点：\n\n1. 设定大目标；\n2. 将大目标拆分，以每个迭代版本为阶段性小目标；\n3. 给自己设立有趣的规则和调整；\n4. 给自己正面的反馈和小奖励。\n\n\n\n> 复盘能帮我们进一步提升效率","source":"_posts/LEVEL 1/高效工作/2 正确地做事/2.2 小步快跑、试错迭代.md","raw":"## 如何小步快跑、是错迭代\n\n#### 为何需小步快跑、试错迭代\n\n1. 完成比完美更重要，没有100%完美的事，为自己减负，从而避免拖延\n2. 互联网时代，不存在完美的计划，按图索骥，很容易因环境变化而前功尽弃\n\n#### 如何小步快跑、试错迭代\n\n1. 用最快的速度，做出满足核心功能的简单版本，即使粗糙，也是一个成品\n2. 不断更新版本，添加其他辅助功能或美化\n3. 在过程中，保持对环境变化的敏感\n4. 不断地提出假设，随时调整，找到最终方向\n5. 通过打磨，不断接近完美\n\n## 工作化游戏\n\n#### 游戏特点：\n\n- 玩家是资源参与\n- 游戏中的每一步都有明确的目标\n- 游戏中的规则是明确而固定的\n- 游戏中有着打鸡血般及时的反馈和奖励\n\n#### 小步快跑、试错迭代要点：\n\n1. 设定大目标；\n2. 将大目标拆分，以每个迭代版本为阶段性小目标；\n3. 给自己设立有趣的规则和调整；\n4. 给自己正面的反馈和小奖励。\n\n\n\n> 复盘能帮我们进一步提升效率","slug":"LEVEL 1/高效工作/2 正确地做事/2.2 小步快跑、试错迭代","published":1,"date":"2020-06-25T03:10:24.443Z","updated":"2020-06-25T03:10:24.443Z","title":"LEVEL 1/高效工作/2 正确地做事/2.2 小步快跑、试错迭代","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpq001f3ns69sc50mlx","content":"<h2 id=\"如何小步快跑、是错迭代\"><a href=\"#如何小步快跑、是错迭代\" class=\"headerlink\" title=\"如何小步快跑、是错迭代\"></a>如何小步快跑、是错迭代</h2><h4 id=\"为何需小步快跑、试错迭代\"><a href=\"#为何需小步快跑、试错迭代\" class=\"headerlink\" title=\"为何需小步快跑、试错迭代\"></a>为何需小步快跑、试错迭代</h4><ol>\n<li>完成比完美更重要，没有100%完美的事，为自己减负，从而避免拖延</li>\n<li>互联网时代，不存在完美的计划，按图索骥，很容易因环境变化而前功尽弃</li>\n</ol>\n<h4 id=\"如何小步快跑、试错迭代\"><a href=\"#如何小步快跑、试错迭代\" class=\"headerlink\" title=\"如何小步快跑、试错迭代\"></a>如何小步快跑、试错迭代</h4><ol>\n<li>用最快的速度，做出满足核心功能的简单版本，即使粗糙，也是一个成品</li>\n<li>不断更新版本，添加其他辅助功能或美化</li>\n<li>在过程中，保持对环境变化的敏感</li>\n<li>不断地提出假设，随时调整，找到最终方向</li>\n<li>通过打磨，不断接近完美</li>\n</ol>\n<h2 id=\"工作化游戏\"><a href=\"#工作化游戏\" class=\"headerlink\" title=\"工作化游戏\"></a>工作化游戏</h2><h4 id=\"游戏特点：\"><a href=\"#游戏特点：\" class=\"headerlink\" title=\"游戏特点：\"></a>游戏特点：</h4><ul>\n<li>玩家是资源参与</li>\n<li>游戏中的每一步都有明确的目标</li>\n<li>游戏中的规则是明确而固定的</li>\n<li>游戏中有着打鸡血般及时的反馈和奖励</li>\n</ul>\n<h4 id=\"小步快跑、试错迭代要点：\"><a href=\"#小步快跑、试错迭代要点：\" class=\"headerlink\" title=\"小步快跑、试错迭代要点：\"></a>小步快跑、试错迭代要点：</h4><ol>\n<li>设定大目标；</li>\n<li>将大目标拆分，以每个迭代版本为阶段性小目标；</li>\n<li>给自己设立有趣的规则和调整；</li>\n<li>给自己正面的反馈和小奖励。</li>\n</ol>\n<blockquote>\n<p>复盘能帮我们进一步提升效率</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何小步快跑、是错迭代\"><a href=\"#如何小步快跑、是错迭代\" class=\"headerlink\" title=\"如何小步快跑、是错迭代\"></a>如何小步快跑、是错迭代</h2><h4 id=\"为何需小步快跑、试错迭代\"><a href=\"#为何需小步快跑、试错迭代\" class=\"headerlink\" title=\"为何需小步快跑、试错迭代\"></a>为何需小步快跑、试错迭代</h4><ol>\n<li>完成比完美更重要，没有100%完美的事，为自己减负，从而避免拖延</li>\n<li>互联网时代，不存在完美的计划，按图索骥，很容易因环境变化而前功尽弃</li>\n</ol>\n<h4 id=\"如何小步快跑、试错迭代\"><a href=\"#如何小步快跑、试错迭代\" class=\"headerlink\" title=\"如何小步快跑、试错迭代\"></a>如何小步快跑、试错迭代</h4><ol>\n<li>用最快的速度，做出满足核心功能的简单版本，即使粗糙，也是一个成品</li>\n<li>不断更新版本，添加其他辅助功能或美化</li>\n<li>在过程中，保持对环境变化的敏感</li>\n<li>不断地提出假设，随时调整，找到最终方向</li>\n<li>通过打磨，不断接近完美</li>\n</ol>\n<h2 id=\"工作化游戏\"><a href=\"#工作化游戏\" class=\"headerlink\" title=\"工作化游戏\"></a>工作化游戏</h2><h4 id=\"游戏特点：\"><a href=\"#游戏特点：\" class=\"headerlink\" title=\"游戏特点：\"></a>游戏特点：</h4><ul>\n<li>玩家是资源参与</li>\n<li>游戏中的每一步都有明确的目标</li>\n<li>游戏中的规则是明确而固定的</li>\n<li>游戏中有着打鸡血般及时的反馈和奖励</li>\n</ul>\n<h4 id=\"小步快跑、试错迭代要点：\"><a href=\"#小步快跑、试错迭代要点：\" class=\"headerlink\" title=\"小步快跑、试错迭代要点：\"></a>小步快跑、试错迭代要点：</h4><ol>\n<li>设定大目标；</li>\n<li>将大目标拆分，以每个迭代版本为阶段性小目标；</li>\n<li>给自己设立有趣的规则和调整；</li>\n<li>给自己正面的反馈和小奖励。</li>\n</ol>\n<blockquote>\n<p>复盘能帮我们进一步提升效率</p>\n</blockquote>\n"},{"_content":"## 为什么需要复盘\n\n#### 1. 提升能力\n\n实践中积累的经验，可以反过来强化我们的认知\n\n#### 2. 总结流程\n\n丰富素材库，从长远来看，能够提高工作效率\n\n#### 3. 认清问题本质\n\n认清自己和环境，既不盲目自大，也不妄自菲薄\n\n## 复盘的四大步骤\n\n#### 1. 对比预期和结果\n\n#### 2. 情景再现\n\n回顾项目的各个节点，对其他路径进行推演，并设想意外情况（可以从资源、信息、管理、环境、个人情绪等角度思考）\n\n#### 3. 总结规律、得出结论、形成标准\n\n保存到个人素材甚至企业数据库\n\n#### 4.  分析得失\n\n包括个人、团队、公司三个层面的得失\n\n\n\n## 总结高效工作\n\n- 做正确的事情\n- 正确的做事\n- 事后进行正确的复盘\n","source":"_posts/LEVEL 1/高效工作/3 事后复盘/3.1 不被同一块石头绊倒两次.md","raw":"## 为什么需要复盘\n\n#### 1. 提升能力\n\n实践中积累的经验，可以反过来强化我们的认知\n\n#### 2. 总结流程\n\n丰富素材库，从长远来看，能够提高工作效率\n\n#### 3. 认清问题本质\n\n认清自己和环境，既不盲目自大，也不妄自菲薄\n\n## 复盘的四大步骤\n\n#### 1. 对比预期和结果\n\n#### 2. 情景再现\n\n回顾项目的各个节点，对其他路径进行推演，并设想意外情况（可以从资源、信息、管理、环境、个人情绪等角度思考）\n\n#### 3. 总结规律、得出结论、形成标准\n\n保存到个人素材甚至企业数据库\n\n#### 4.  分析得失\n\n包括个人、团队、公司三个层面的得失\n\n\n\n## 总结高效工作\n\n- 做正确的事情\n- 正确的做事\n- 事后进行正确的复盘\n","slug":"LEVEL 1/高效工作/3 事后复盘/3.1 不被同一块石头绊倒两次","published":1,"date":"2020-06-25T03:10:24.444Z","updated":"2020-06-25T03:10:24.444Z","title":"LEVEL 1/高效工作/3 事后复盘/3.1 不被同一块石头绊倒两次","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpq001g3ns6efvdgtt6","content":"<h2 id=\"为什么需要复盘\"><a href=\"#为什么需要复盘\" class=\"headerlink\" title=\"为什么需要复盘\"></a>为什么需要复盘</h2><h4 id=\"1-提升能力\"><a href=\"#1-提升能力\" class=\"headerlink\" title=\"1. 提升能力\"></a>1. 提升能力</h4><p>实践中积累的经验，可以反过来强化我们的认知</p>\n<h4 id=\"2-总结流程\"><a href=\"#2-总结流程\" class=\"headerlink\" title=\"2. 总结流程\"></a>2. 总结流程</h4><p>丰富素材库，从长远来看，能够提高工作效率</p>\n<h4 id=\"3-认清问题本质\"><a href=\"#3-认清问题本质\" class=\"headerlink\" title=\"3. 认清问题本质\"></a>3. 认清问题本质</h4><p>认清自己和环境，既不盲目自大，也不妄自菲薄</p>\n<h2 id=\"复盘的四大步骤\"><a href=\"#复盘的四大步骤\" class=\"headerlink\" title=\"复盘的四大步骤\"></a>复盘的四大步骤</h2><h4 id=\"1-对比预期和结果\"><a href=\"#1-对比预期和结果\" class=\"headerlink\" title=\"1. 对比预期和结果\"></a>1. 对比预期和结果</h4><h4 id=\"2-情景再现\"><a href=\"#2-情景再现\" class=\"headerlink\" title=\"2. 情景再现\"></a>2. 情景再现</h4><p>回顾项目的各个节点，对其他路径进行推演，并设想意外情况（可以从资源、信息、管理、环境、个人情绪等角度思考）</p>\n<h4 id=\"3-总结规律、得出结论、形成标准\"><a href=\"#3-总结规律、得出结论、形成标准\" class=\"headerlink\" title=\"3. 总结规律、得出结论、形成标准\"></a>3. 总结规律、得出结论、形成标准</h4><p>保存到个人素材甚至企业数据库</p>\n<h4 id=\"4-分析得失\"><a href=\"#4-分析得失\" class=\"headerlink\" title=\"4.  分析得失\"></a>4.  分析得失</h4><p>包括个人、团队、公司三个层面的得失</p>\n<h2 id=\"总结高效工作\"><a href=\"#总结高效工作\" class=\"headerlink\" title=\"总结高效工作\"></a>总结高效工作</h2><ul>\n<li>做正确的事情</li>\n<li>正确的做事</li>\n<li>事后进行正确的复盘</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么需要复盘\"><a href=\"#为什么需要复盘\" class=\"headerlink\" title=\"为什么需要复盘\"></a>为什么需要复盘</h2><h4 id=\"1-提升能力\"><a href=\"#1-提升能力\" class=\"headerlink\" title=\"1. 提升能力\"></a>1. 提升能力</h4><p>实践中积累的经验，可以反过来强化我们的认知</p>\n<h4 id=\"2-总结流程\"><a href=\"#2-总结流程\" class=\"headerlink\" title=\"2. 总结流程\"></a>2. 总结流程</h4><p>丰富素材库，从长远来看，能够提高工作效率</p>\n<h4 id=\"3-认清问题本质\"><a href=\"#3-认清问题本质\" class=\"headerlink\" title=\"3. 认清问题本质\"></a>3. 认清问题本质</h4><p>认清自己和环境，既不盲目自大，也不妄自菲薄</p>\n<h2 id=\"复盘的四大步骤\"><a href=\"#复盘的四大步骤\" class=\"headerlink\" title=\"复盘的四大步骤\"></a>复盘的四大步骤</h2><h4 id=\"1-对比预期和结果\"><a href=\"#1-对比预期和结果\" class=\"headerlink\" title=\"1. 对比预期和结果\"></a>1. 对比预期和结果</h4><h4 id=\"2-情景再现\"><a href=\"#2-情景再现\" class=\"headerlink\" title=\"2. 情景再现\"></a>2. 情景再现</h4><p>回顾项目的各个节点，对其他路径进行推演，并设想意外情况（可以从资源、信息、管理、环境、个人情绪等角度思考）</p>\n<h4 id=\"3-总结规律、得出结论、形成标准\"><a href=\"#3-总结规律、得出结论、形成标准\" class=\"headerlink\" title=\"3. 总结规律、得出结论、形成标准\"></a>3. 总结规律、得出结论、形成标准</h4><p>保存到个人素材甚至企业数据库</p>\n<h4 id=\"4-分析得失\"><a href=\"#4-分析得失\" class=\"headerlink\" title=\"4.  分析得失\"></a>4.  分析得失</h4><p>包括个人、团队、公司三个层面的得失</p>\n<h2 id=\"总结高效工作\"><a href=\"#总结高效工作\" class=\"headerlink\" title=\"总结高效工作\"></a>总结高效工作</h2><ul>\n<li>做正确的事情</li>\n<li>正确的做事</li>\n<li>事后进行正确的复盘</li>\n</ul>\n"},{"_content":"## 诉诸权威的谬误\n\n> 市井上有个潜在的意识“你成功了，你说的就都是对的”\n\n这话看着就有些难受。权威当证据本身是没错的，但权威说的话往往也分场景，如果放错了位置，比如：家里老人经常转发一些专家的养生文章，而这个专家是中医，不是营养学家。\n\n以及权威的结论没有任何理由和证据支持，就相当于找了一个无效的因素来支持结论。这就产生了诉诸权威谬误。\n\n\n\n#### 如何发和应对\n\n我们通过三方面来进行判断\n\n1. ##### **是否是相关领域的权威**\n\n   确定权威是哪方面的权威\n\n   不能汽车制造领域专家说手机制造的事情；\n\n   自媒体大V的结论：“应届生应该去大厂”，那么可以去查一下这个大V是在哪个领域，如果是人力资源领域的资深人力资源高管。可以参考，然后做下一步判断。如果是领域内两年三年的普通从业人员，这在资历上就不具备说服力。\n\n   \n\n2. ##### **结论是否具有理由和证据**\n\n   比如“应届生应该去大厂”，支撑这个结论的理由和证据是什么？如果没有理由和证据，就算是权威说的，也应该怀疑：这纯粹是个人观点，无说服力\n\n   \n\n3. ##### **提出结论的背景是什么**\n\n   比如“应届生应该去大厂”，大V是在什么情况下提出的这个结论的，如果是和他个人经历相关：比如去大厂因为一些原因没有发展好，而自己做自媒体确获得了很多。\n\n   首先个例的经验是不具备强说服力的，再是作者是因为自己的经历得出的观点，本身就存疑。\n\n\n\n## 诉诸公众的谬误\n\n很多时候我们对权威的话、大多数人认同的观点，会不假思索的接受。\n\n比如很多公众号会用“被多家媒体转载”、“超过几十万转发”等方式来标榜自己等等。企图用“大多数人认同”来证明自己的观点。\n\n而当我们轻易接受这些权威或大众的观点时，其实是基于一个错误的假设：**只要是专家或者大多数人认同的就是正确的**。这时候就会出现诉诸公众谬误。\n\n\n\n#### 如何发现跟应对\n\n想要避免诉诸公众谬误的影响时，就需要了解它一般会以什么样的方式出现，主要会有两种情况：\n\n1. ##### 借助真实的公众观点\n\n   “贩卖儿童是否应该一律死刑”，尽管大多数人都认为应该判死刑，但并不代表大多数人认为的是一件正确的事情。\n\n2. ##### 伪造支持者众多的假象\n\n   “广州市自来水价格调整方案听证会中，24名听证会参加人全票赞成水价上涨”。24名参会人代表所有人吗？\n\n   “那些走上人生巅峰的人，都有关注这几个公众号”。是哪些走上人生巅峰的人？\n\n   ","source":"_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/不当诉诸的谬误.md","raw":"## 诉诸权威的谬误\n\n> 市井上有个潜在的意识“你成功了，你说的就都是对的”\n\n这话看着就有些难受。权威当证据本身是没错的，但权威说的话往往也分场景，如果放错了位置，比如：家里老人经常转发一些专家的养生文章，而这个专家是中医，不是营养学家。\n\n以及权威的结论没有任何理由和证据支持，就相当于找了一个无效的因素来支持结论。这就产生了诉诸权威谬误。\n\n\n\n#### 如何发和应对\n\n我们通过三方面来进行判断\n\n1. ##### **是否是相关领域的权威**\n\n   确定权威是哪方面的权威\n\n   不能汽车制造领域专家说手机制造的事情；\n\n   自媒体大V的结论：“应届生应该去大厂”，那么可以去查一下这个大V是在哪个领域，如果是人力资源领域的资深人力资源高管。可以参考，然后做下一步判断。如果是领域内两年三年的普通从业人员，这在资历上就不具备说服力。\n\n   \n\n2. ##### **结论是否具有理由和证据**\n\n   比如“应届生应该去大厂”，支撑这个结论的理由和证据是什么？如果没有理由和证据，就算是权威说的，也应该怀疑：这纯粹是个人观点，无说服力\n\n   \n\n3. ##### **提出结论的背景是什么**\n\n   比如“应届生应该去大厂”，大V是在什么情况下提出的这个结论的，如果是和他个人经历相关：比如去大厂因为一些原因没有发展好，而自己做自媒体确获得了很多。\n\n   首先个例的经验是不具备强说服力的，再是作者是因为自己的经历得出的观点，本身就存疑。\n\n\n\n## 诉诸公众的谬误\n\n很多时候我们对权威的话、大多数人认同的观点，会不假思索的接受。\n\n比如很多公众号会用“被多家媒体转载”、“超过几十万转发”等方式来标榜自己等等。企图用“大多数人认同”来证明自己的观点。\n\n而当我们轻易接受这些权威或大众的观点时，其实是基于一个错误的假设：**只要是专家或者大多数人认同的就是正确的**。这时候就会出现诉诸公众谬误。\n\n\n\n#### 如何发现跟应对\n\n想要避免诉诸公众谬误的影响时，就需要了解它一般会以什么样的方式出现，主要会有两种情况：\n\n1. ##### 借助真实的公众观点\n\n   “贩卖儿童是否应该一律死刑”，尽管大多数人都认为应该判死刑，但并不代表大多数人认为的是一件正确的事情。\n\n2. ##### 伪造支持者众多的假象\n\n   “广州市自来水价格调整方案听证会中，24名听证会参加人全票赞成水价上涨”。24名参会人代表所有人吗？\n\n   “那些走上人生巅峰的人，都有关注这几个公众号”。是哪些走上人生巅峰的人？\n\n   ","slug":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/不当诉诸的谬误","published":1,"date":"2020-06-25T03:10:24.424Z","updated":"2020-06-25T03:10:24.424Z","title":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/不当诉诸的谬误","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpw001h3ns64dyz90rk","content":"<h2 id=\"诉诸权威的谬误\"><a href=\"#诉诸权威的谬误\" class=\"headerlink\" title=\"诉诸权威的谬误\"></a>诉诸权威的谬误</h2><blockquote>\n<p>市井上有个潜在的意识“你成功了，你说的就都是对的”</p>\n</blockquote>\n<p>这话看着就有些难受。权威当证据本身是没错的，但权威说的话往往也分场景，如果放错了位置，比如：家里老人经常转发一些专家的养生文章，而这个专家是中医，不是营养学家。</p>\n<p>以及权威的结论没有任何理由和证据支持，就相当于找了一个无效的因素来支持结论。这就产生了诉诸权威谬误。</p>\n<h4 id=\"如何发和应对\"><a href=\"#如何发和应对\" class=\"headerlink\" title=\"如何发和应对\"></a>如何发和应对</h4><p>我们通过三方面来进行判断</p>\n<ol>\n<li><h5 id=\"是否是相关领域的权威\"><a href=\"#是否是相关领域的权威\" class=\"headerlink\" title=\"是否是相关领域的权威\"></a><strong>是否是相关领域的权威</strong></h5><p>确定权威是哪方面的权威</p>\n<p>不能汽车制造领域专家说手机制造的事情；</p>\n<p>自媒体大V的结论：“应届生应该去大厂”，那么可以去查一下这个大V是在哪个领域，如果是人力资源领域的资深人力资源高管。可以参考，然后做下一步判断。如果是领域内两年三年的普通从业人员，这在资历上就不具备说服力。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h5 id=\"结论是否具有理由和证据\"><a href=\"#结论是否具有理由和证据\" class=\"headerlink\" title=\"结论是否具有理由和证据\"></a><strong>结论是否具有理由和证据</strong></h5><p>比如“应届生应该去大厂”，支撑这个结论的理由和证据是什么？如果没有理由和证据，就算是权威说的，也应该怀疑：这纯粹是个人观点，无说服力</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h5 id=\"提出结论的背景是什么\"><a href=\"#提出结论的背景是什么\" class=\"headerlink\" title=\"提出结论的背景是什么\"></a><strong>提出结论的背景是什么</strong></h5><p>比如“应届生应该去大厂”，大V是在什么情况下提出的这个结论的，如果是和他个人经历相关：比如去大厂因为一些原因没有发展好，而自己做自媒体确获得了很多。</p>\n<p>首先个例的经验是不具备强说服力的，再是作者是因为自己的经历得出的观点，本身就存疑。</p>\n</li>\n</ol>\n<h2 id=\"诉诸公众的谬误\"><a href=\"#诉诸公众的谬误\" class=\"headerlink\" title=\"诉诸公众的谬误\"></a>诉诸公众的谬误</h2><p>很多时候我们对权威的话、大多数人认同的观点，会不假思索的接受。</p>\n<p>比如很多公众号会用“被多家媒体转载”、“超过几十万转发”等方式来标榜自己等等。企图用“大多数人认同”来证明自己的观点。</p>\n<p>而当我们轻易接受这些权威或大众的观点时，其实是基于一个错误的假设：<strong>只要是专家或者大多数人认同的就是正确的</strong>。这时候就会出现诉诸公众谬误。</p>\n<h4 id=\"如何发现跟应对\"><a href=\"#如何发现跟应对\" class=\"headerlink\" title=\"如何发现跟应对\"></a>如何发现跟应对</h4><p>想要避免诉诸公众谬误的影响时，就需要了解它一般会以什么样的方式出现，主要会有两种情况：</p>\n<ol>\n<li><h5 id=\"借助真实的公众观点\"><a href=\"#借助真实的公众观点\" class=\"headerlink\" title=\"借助真实的公众观点\"></a>借助真实的公众观点</h5><p>“贩卖儿童是否应该一律死刑”，尽管大多数人都认为应该判死刑，但并不代表大多数人认为的是一件正确的事情。</p>\n</li>\n<li><h5 id=\"伪造支持者众多的假象\"><a href=\"#伪造支持者众多的假象\" class=\"headerlink\" title=\"伪造支持者众多的假象\"></a>伪造支持者众多的假象</h5><p>“广州市自来水价格调整方案听证会中，24名听证会参加人全票赞成水价上涨”。24名参会人代表所有人吗？</p>\n<p>“那些走上人生巅峰的人，都有关注这几个公众号”。是哪些走上人生巅峰的人？</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"诉诸权威的谬误\"><a href=\"#诉诸权威的谬误\" class=\"headerlink\" title=\"诉诸权威的谬误\"></a>诉诸权威的谬误</h2><blockquote>\n<p>市井上有个潜在的意识“你成功了，你说的就都是对的”</p>\n</blockquote>\n<p>这话看着就有些难受。权威当证据本身是没错的，但权威说的话往往也分场景，如果放错了位置，比如：家里老人经常转发一些专家的养生文章，而这个专家是中医，不是营养学家。</p>\n<p>以及权威的结论没有任何理由和证据支持，就相当于找了一个无效的因素来支持结论。这就产生了诉诸权威谬误。</p>\n<h4 id=\"如何发和应对\"><a href=\"#如何发和应对\" class=\"headerlink\" title=\"如何发和应对\"></a>如何发和应对</h4><p>我们通过三方面来进行判断</p>\n<ol>\n<li><h5 id=\"是否是相关领域的权威\"><a href=\"#是否是相关领域的权威\" class=\"headerlink\" title=\"是否是相关领域的权威\"></a><strong>是否是相关领域的权威</strong></h5><p>确定权威是哪方面的权威</p>\n<p>不能汽车制造领域专家说手机制造的事情；</p>\n<p>自媒体大V的结论：“应届生应该去大厂”，那么可以去查一下这个大V是在哪个领域，如果是人力资源领域的资深人力资源高管。可以参考，然后做下一步判断。如果是领域内两年三年的普通从业人员，这在资历上就不具备说服力。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h5 id=\"结论是否具有理由和证据\"><a href=\"#结论是否具有理由和证据\" class=\"headerlink\" title=\"结论是否具有理由和证据\"></a><strong>结论是否具有理由和证据</strong></h5><p>比如“应届生应该去大厂”，支撑这个结论的理由和证据是什么？如果没有理由和证据，就算是权威说的，也应该怀疑：这纯粹是个人观点，无说服力</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h5 id=\"提出结论的背景是什么\"><a href=\"#提出结论的背景是什么\" class=\"headerlink\" title=\"提出结论的背景是什么\"></a><strong>提出结论的背景是什么</strong></h5><p>比如“应届生应该去大厂”，大V是在什么情况下提出的这个结论的，如果是和他个人经历相关：比如去大厂因为一些原因没有发展好，而自己做自媒体确获得了很多。</p>\n<p>首先个例的经验是不具备强说服力的，再是作者是因为自己的经历得出的观点，本身就存疑。</p>\n</li>\n</ol>\n<h2 id=\"诉诸公众的谬误\"><a href=\"#诉诸公众的谬误\" class=\"headerlink\" title=\"诉诸公众的谬误\"></a>诉诸公众的谬误</h2><p>很多时候我们对权威的话、大多数人认同的观点，会不假思索的接受。</p>\n<p>比如很多公众号会用“被多家媒体转载”、“超过几十万转发”等方式来标榜自己等等。企图用“大多数人认同”来证明自己的观点。</p>\n<p>而当我们轻易接受这些权威或大众的观点时，其实是基于一个错误的假设：<strong>只要是专家或者大多数人认同的就是正确的</strong>。这时候就会出现诉诸公众谬误。</p>\n<h4 id=\"如何发现跟应对\"><a href=\"#如何发现跟应对\" class=\"headerlink\" title=\"如何发现跟应对\"></a>如何发现跟应对</h4><p>想要避免诉诸公众谬误的影响时，就需要了解它一般会以什么样的方式出现，主要会有两种情况：</p>\n<ol>\n<li><h5 id=\"借助真实的公众观点\"><a href=\"#借助真实的公众观点\" class=\"headerlink\" title=\"借助真实的公众观点\"></a>借助真实的公众观点</h5><p>“贩卖儿童是否应该一律死刑”，尽管大多数人都认为应该判死刑，但并不代表大多数人认为的是一件正确的事情。</p>\n</li>\n<li><h5 id=\"伪造支持者众多的假象\"><a href=\"#伪造支持者众多的假象\" class=\"headerlink\" title=\"伪造支持者众多的假象\"></a>伪造支持者众多的假象</h5><p>“广州市自来水价格调整方案听证会中，24名听证会参加人全票赞成水价上涨”。24名参会人代表所有人吗？</p>\n<p>“那些走上人生巅峰的人，都有关注这几个公众号”。是哪些走上人生巅峰的人？</p>\n</li>\n</ol>\n"},{"_content":"> “你还好意思说支持正版呢，难道你就没在网上下载过电影吗？”\n\n类似这种不回应讨论的主题，而是冲着给出观点的人作文章，将注意力转移到人身伤的情况，很可能存在**人身攻击谬误**\n\n事实上，我们不该将一个人的观点和这个人本身等同起来，说出观点的并不能作为判断观点是否符合逻辑的依据。\n\n这一点对自己也一样，在和别人交流的时候，如果对方说了不一样的观点，尽管我们可能认为是更有道理的，但你还是不愿意承认，会为了了坚持而坚持。\n\n这是因为我们***没有将人和观点分开。观点的不好，不代表人不好，如果将两者等同起来，会限制自己接受外部信息，从而无法获得成长***。\n\n在遇到人身攻击谬误时，可能会让我们产生一些不良的情绪和感受，从而自乱阵脚。如果我们能够及时地识别，并且予以恰当的回应，可避免陷入无谓的争执之中，让自己占上风。\n\n常见的人身谬误又分为两种：\n\n- 直接人身攻击\n- 隐藏的人身攻击\n\n\n\n## 直接人身攻击谬误\n\n直接的对他人进行指责或评价，甚至会带有侮辱性、攻击性的词汇去攻击对方，并以此为证据，质疑他人的观点和推论。\n\n比如“你不抵制日货，所以你时汉奸，我们不停汉奸的说的话！”\n\n\n\n## 隐藏人身攻击谬误\n\n指出对方行为与言论的矛盾，以此来转移注意力。\n\n“你自己没有孩子，没资格教我怎么管孩子”\n\n\n\n## 如何应对\n\n遇到这种事，真生气啊！怎么应对呢？\n\n- 自己要保持冷静，这时候容易产生不良情绪和感受，但不要轻易被带着走，将焦点调整回来。\n- 明确向对方指出，这是在逃避问题。如果对方继续进行人身攻击。请他对你的观点本身发表意见（再次尝试将焦点调整回来）\n- 最后，如果对方继续攻击或拒绝回到主题，那么可以终止讨论了。不浪费时间精力。\n\n\n\n首先注意一点：人身攻击谬误并不是指对他人使用了侮辱性的语言，或是做出不好的评价。人身攻击谬误被**作为一种手段，试图贬低对方观点的行为**。**在攻击“送信的人”，而不是讨论“信件”的内容本身**\n\n\n\n\n\n![Slide5.jpeg](https://static.iqycamp.com/challenge-20181008152228-q1unptonz.jpeg)\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/两种转移人身谬误.md","raw":"> “你还好意思说支持正版呢，难道你就没在网上下载过电影吗？”\n\n类似这种不回应讨论的主题，而是冲着给出观点的人作文章，将注意力转移到人身伤的情况，很可能存在**人身攻击谬误**\n\n事实上，我们不该将一个人的观点和这个人本身等同起来，说出观点的并不能作为判断观点是否符合逻辑的依据。\n\n这一点对自己也一样，在和别人交流的时候，如果对方说了不一样的观点，尽管我们可能认为是更有道理的，但你还是不愿意承认，会为了了坚持而坚持。\n\n这是因为我们***没有将人和观点分开。观点的不好，不代表人不好，如果将两者等同起来，会限制自己接受外部信息，从而无法获得成长***。\n\n在遇到人身攻击谬误时，可能会让我们产生一些不良的情绪和感受，从而自乱阵脚。如果我们能够及时地识别，并且予以恰当的回应，可避免陷入无谓的争执之中，让自己占上风。\n\n常见的人身谬误又分为两种：\n\n- 直接人身攻击\n- 隐藏的人身攻击\n\n\n\n## 直接人身攻击谬误\n\n直接的对他人进行指责或评价，甚至会带有侮辱性、攻击性的词汇去攻击对方，并以此为证据，质疑他人的观点和推论。\n\n比如“你不抵制日货，所以你时汉奸，我们不停汉奸的说的话！”\n\n\n\n## 隐藏人身攻击谬误\n\n指出对方行为与言论的矛盾，以此来转移注意力。\n\n“你自己没有孩子，没资格教我怎么管孩子”\n\n\n\n## 如何应对\n\n遇到这种事，真生气啊！怎么应对呢？\n\n- 自己要保持冷静，这时候容易产生不良情绪和感受，但不要轻易被带着走，将焦点调整回来。\n- 明确向对方指出，这是在逃避问题。如果对方继续进行人身攻击。请他对你的观点本身发表意见（再次尝试将焦点调整回来）\n- 最后，如果对方继续攻击或拒绝回到主题，那么可以终止讨论了。不浪费时间精力。\n\n\n\n首先注意一点：人身攻击谬误并不是指对他人使用了侮辱性的语言，或是做出不好的评价。人身攻击谬误被**作为一种手段，试图贬低对方观点的行为**。**在攻击“送信的人”，而不是讨论“信件”的内容本身**\n\n\n\n\n\n![Slide5.jpeg](https://static.iqycamp.com/challenge-20181008152228-q1unptonz.jpeg)\n\n","slug":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/两种转移人身谬误","published":1,"date":"2020-06-25T06:37:56.651Z","updated":"2020-06-25T08:47:10.945Z","title":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/两种转移人身谬误","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpx001i3ns6dg1vd1fs","content":"<blockquote>\n<p>“你还好意思说支持正版呢，难道你就没在网上下载过电影吗？”</p>\n</blockquote>\n<p>类似这种不回应讨论的主题，而是冲着给出观点的人作文章，将注意力转移到人身伤的情况，很可能存在<strong>人身攻击谬误</strong></p>\n<p>事实上，我们不该将一个人的观点和这个人本身等同起来，说出观点的并不能作为判断观点是否符合逻辑的依据。</p>\n<p>这一点对自己也一样，在和别人交流的时候，如果对方说了不一样的观点，尽管我们可能认为是更有道理的，但你还是不愿意承认，会为了了坚持而坚持。</p>\n<p>这是因为我们<strong><em>没有将人和观点分开。观点的不好，不代表人不好，如果将两者等同起来，会限制自己接受外部信息，从而无法获得成长</em></strong>。</p>\n<p>在遇到人身攻击谬误时，可能会让我们产生一些不良的情绪和感受，从而自乱阵脚。如果我们能够及时地识别，并且予以恰当的回应，可避免陷入无谓的争执之中，让自己占上风。</p>\n<p>常见的人身谬误又分为两种：</p>\n<ul>\n<li>直接人身攻击</li>\n<li>隐藏的人身攻击</li>\n</ul>\n<h2 id=\"直接人身攻击谬误\"><a href=\"#直接人身攻击谬误\" class=\"headerlink\" title=\"直接人身攻击谬误\"></a>直接人身攻击谬误</h2><p>直接的对他人进行指责或评价，甚至会带有侮辱性、攻击性的词汇去攻击对方，并以此为证据，质疑他人的观点和推论。</p>\n<p>比如“你不抵制日货，所以你时汉奸，我们不停汉奸的说的话！”</p>\n<h2 id=\"隐藏人身攻击谬误\"><a href=\"#隐藏人身攻击谬误\" class=\"headerlink\" title=\"隐藏人身攻击谬误\"></a>隐藏人身攻击谬误</h2><p>指出对方行为与言论的矛盾，以此来转移注意力。</p>\n<p>“你自己没有孩子，没资格教我怎么管孩子”</p>\n<h2 id=\"如何应对\"><a href=\"#如何应对\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h2><p>遇到这种事，真生气啊！怎么应对呢？</p>\n<ul>\n<li>自己要保持冷静，这时候容易产生不良情绪和感受，但不要轻易被带着走，将焦点调整回来。</li>\n<li>明确向对方指出，这是在逃避问题。如果对方继续进行人身攻击。请他对你的观点本身发表意见（再次尝试将焦点调整回来）</li>\n<li>最后，如果对方继续攻击或拒绝回到主题，那么可以终止讨论了。不浪费时间精力。</li>\n</ul>\n<p>首先注意一点：人身攻击谬误并不是指对他人使用了侮辱性的语言，或是做出不好的评价。人身攻击谬误被<strong>作为一种手段，试图贬低对方观点的行为</strong>。<strong>在攻击“送信的人”，而不是讨论“信件”的内容本身</strong></p>\n<p><img src=\"https://static.iqycamp.com/challenge-20181008152228-q1unptonz.jpeg\" alt=\"Slide5.jpeg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“你还好意思说支持正版呢，难道你就没在网上下载过电影吗？”</p>\n</blockquote>\n<p>类似这种不回应讨论的主题，而是冲着给出观点的人作文章，将注意力转移到人身伤的情况，很可能存在<strong>人身攻击谬误</strong></p>\n<p>事实上，我们不该将一个人的观点和这个人本身等同起来，说出观点的并不能作为判断观点是否符合逻辑的依据。</p>\n<p>这一点对自己也一样，在和别人交流的时候，如果对方说了不一样的观点，尽管我们可能认为是更有道理的，但你还是不愿意承认，会为了了坚持而坚持。</p>\n<p>这是因为我们<strong><em>没有将人和观点分开。观点的不好，不代表人不好，如果将两者等同起来，会限制自己接受外部信息，从而无法获得成长</em></strong>。</p>\n<p>在遇到人身攻击谬误时，可能会让我们产生一些不良的情绪和感受，从而自乱阵脚。如果我们能够及时地识别，并且予以恰当的回应，可避免陷入无谓的争执之中，让自己占上风。</p>\n<p>常见的人身谬误又分为两种：</p>\n<ul>\n<li>直接人身攻击</li>\n<li>隐藏的人身攻击</li>\n</ul>\n<h2 id=\"直接人身攻击谬误\"><a href=\"#直接人身攻击谬误\" class=\"headerlink\" title=\"直接人身攻击谬误\"></a>直接人身攻击谬误</h2><p>直接的对他人进行指责或评价，甚至会带有侮辱性、攻击性的词汇去攻击对方，并以此为证据，质疑他人的观点和推论。</p>\n<p>比如“你不抵制日货，所以你时汉奸，我们不停汉奸的说的话！”</p>\n<h2 id=\"隐藏人身攻击谬误\"><a href=\"#隐藏人身攻击谬误\" class=\"headerlink\" title=\"隐藏人身攻击谬误\"></a>隐藏人身攻击谬误</h2><p>指出对方行为与言论的矛盾，以此来转移注意力。</p>\n<p>“你自己没有孩子，没资格教我怎么管孩子”</p>\n<h2 id=\"如何应对\"><a href=\"#如何应对\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h2><p>遇到这种事，真生气啊！怎么应对呢？</p>\n<ul>\n<li>自己要保持冷静，这时候容易产生不良情绪和感受，但不要轻易被带着走，将焦点调整回来。</li>\n<li>明确向对方指出，这是在逃避问题。如果对方继续进行人身攻击。请他对你的观点本身发表意见（再次尝试将焦点调整回来）</li>\n<li>最后，如果对方继续攻击或拒绝回到主题，那么可以终止讨论了。不浪费时间精力。</li>\n</ul>\n<p>首先注意一点：人身攻击谬误并不是指对他人使用了侮辱性的语言，或是做出不好的评价。人身攻击谬误被<strong>作为一种手段，试图贬低对方观点的行为</strong>。<strong>在攻击“送信的人”，而不是讨论“信件”的内容本身</strong></p>\n<p><img src=\"https://static.iqycamp.com/challenge-20181008152228-q1unptonz.jpeg\" alt=\"Slide5.jpeg\"></p>\n"},{"_content":"在我们从理由推导出结论的过程中，有各种各样的逻辑谬误阻拦我们。当我们了解这些逻辑谬误，可以帮助我们敏锐的发现它们，有力的反驳它们。\n\n常见的三类“骗术”\n\n- **结论背后有错误的假设**\n\n  如果某个观点是大家都认同的，那就是对的（大家认同的就是对的？）\n\n- **试图转移我们的注意力**\n\n  采访某运动员为什么服用兴奋剂时，运动员说还有其他人也服用兴奋剂只是没有被发现（问的是你为什么服用兴奋剂）\n\n- **使用错误的因果关系**\n\n  孩子看电视时间多了，所以变得更胖了（胖不是因为吃和不运动吗？和电视有什么关系）\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/几种常见的逻辑谬误.md","raw":"在我们从理由推导出结论的过程中，有各种各样的逻辑谬误阻拦我们。当我们了解这些逻辑谬误，可以帮助我们敏锐的发现它们，有力的反驳它们。\n\n常见的三类“骗术”\n\n- **结论背后有错误的假设**\n\n  如果某个观点是大家都认同的，那就是对的（大家认同的就是对的？）\n\n- **试图转移我们的注意力**\n\n  采访某运动员为什么服用兴奋剂时，运动员说还有其他人也服用兴奋剂只是没有被发现（问的是你为什么服用兴奋剂）\n\n- **使用错误的因果关系**\n\n  孩子看电视时间多了，所以变得更胖了（胖不是因为吃和不运动吗？和电视有什么关系）\n\n","slug":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/几种常见的逻辑谬误","published":1,"date":"2020-06-25T03:10:24.425Z","updated":"2020-06-25T03:10:24.425Z","title":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/几种常见的逻辑谬误","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpy001j3ns61j6hdimn","content":"<p>在我们从理由推导出结论的过程中，有各种各样的逻辑谬误阻拦我们。当我们了解这些逻辑谬误，可以帮助我们敏锐的发现它们，有力的反驳它们。</p>\n<p>常见的三类“骗术”</p>\n<ul>\n<li><p><strong>结论背后有错误的假设</strong></p>\n<p>如果某个观点是大家都认同的，那就是对的（大家认同的就是对的？）</p>\n</li>\n<li><p><strong>试图转移我们的注意力</strong></p>\n<p>采访某运动员为什么服用兴奋剂时，运动员说还有其他人也服用兴奋剂只是没有被发现（问的是你为什么服用兴奋剂）</p>\n</li>\n<li><p><strong>使用错误的因果关系</strong></p>\n<p>孩子看电视时间多了，所以变得更胖了（胖不是因为吃和不运动吗？和电视有什么关系）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在我们从理由推导出结论的过程中，有各种各样的逻辑谬误阻拦我们。当我们了解这些逻辑谬误，可以帮助我们敏锐的发现它们，有力的反驳它们。</p>\n<p>常见的三类“骗术”</p>\n<ul>\n<li><p><strong>结论背后有错误的假设</strong></p>\n<p>如果某个观点是大家都认同的，那就是对的（大家认同的就是对的？）</p>\n</li>\n<li><p><strong>试图转移我们的注意力</strong></p>\n<p>采访某运动员为什么服用兴奋剂时，运动员说还有其他人也服用兴奋剂只是没有被发现（问的是你为什么服用兴奋剂）</p>\n</li>\n<li><p><strong>使用错误的因果关系</strong></p>\n<p>孩子看电视时间多了，所以变得更胖了（胖不是因为吃和不运动吗？和电视有什么关系）</p>\n</li>\n</ul>\n"},{"_content":"### 场景\n\n> 选择稳定的工作还是追求梦想？享受当下还是活在未来？\n\n### 质疑\n\n难道只有两个选择？为什么工作一定是稳定的，稳定工作和追求梦想有冲突吗？享受当下和活在未来不应该是平衡吗？怎么变成了二选一。**<u>很多问题的答案远远不只两个</u>**\n\n### 原因\n\n许多类似问题，往往因为一些不当的限制，将解决问题限制在一个很严苛的范围内（非黑即白，不是一就是二）\n\n**这种限制是因为：错误地假设这些选项中，必定有一个是正确的，导致经常出现虚假两难谬误。**\n\n- 警惕绝对化措辞\n\n  非黑即白，不是一就是二\n\n- 提出疑问\n\n  没有其他选择了吗？、反问、列举其他选项\n\n### 如何避免\n\n如何避免陷入虚假两难的逻辑谬误中呢：\n\n- 改变认知：完成比完美重要，一件事并不是完美和不做两个选项\n- 做计划的面面俱到 ❌\n- 一心想把事情做的尽善尽美❌\n- 吝惜资源害怕投入没有产出❌\n\n<u>***认清谬误和事实，保持清晰思维去分析事情，并做出方案。不要被自己的主观所限制住。***</u>\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/判断与应对虚假两难谬误.md","raw":"### 场景\n\n> 选择稳定的工作还是追求梦想？享受当下还是活在未来？\n\n### 质疑\n\n难道只有两个选择？为什么工作一定是稳定的，稳定工作和追求梦想有冲突吗？享受当下和活在未来不应该是平衡吗？怎么变成了二选一。**<u>很多问题的答案远远不只两个</u>**\n\n### 原因\n\n许多类似问题，往往因为一些不当的限制，将解决问题限制在一个很严苛的范围内（非黑即白，不是一就是二）\n\n**这种限制是因为：错误地假设这些选项中，必定有一个是正确的，导致经常出现虚假两难谬误。**\n\n- 警惕绝对化措辞\n\n  非黑即白，不是一就是二\n\n- 提出疑问\n\n  没有其他选择了吗？、反问、列举其他选项\n\n### 如何避免\n\n如何避免陷入虚假两难的逻辑谬误中呢：\n\n- 改变认知：完成比完美重要，一件事并不是完美和不做两个选项\n- 做计划的面面俱到 ❌\n- 一心想把事情做的尽善尽美❌\n- 吝惜资源害怕投入没有产出❌\n\n<u>***认清谬误和事实，保持清晰思维去分析事情，并做出方案。不要被自己的主观所限制住。***</u>\n\n","slug":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/判断与应对虚假两难谬误","published":1,"date":"2020-06-25T03:10:24.425Z","updated":"2020-06-25T03:10:24.425Z","title":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/判断与应对虚假两难谬误","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpy001k3ns6btmi4z4e","content":"<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><blockquote>\n<p>选择稳定的工作还是追求梦想？享受当下还是活在未来？</p>\n</blockquote>\n<h3 id=\"质疑\"><a href=\"#质疑\" class=\"headerlink\" title=\"质疑\"></a>质疑</h3><p>难道只有两个选择？为什么工作一定是稳定的，稳定工作和追求梦想有冲突吗？享受当下和活在未来不应该是平衡吗？怎么变成了二选一。<strong><u>很多问题的答案远远不只两个</u></strong></p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>许多类似问题，往往因为一些不当的限制，将解决问题限制在一个很严苛的范围内（非黑即白，不是一就是二）</p>\n<p><strong>这种限制是因为：错误地假设这些选项中，必定有一个是正确的，导致经常出现虚假两难谬误。</strong></p>\n<ul>\n<li><p>警惕绝对化措辞</p>\n<p>非黑即白，不是一就是二</p>\n</li>\n<li><p>提出疑问</p>\n<p>没有其他选择了吗？、反问、列举其他选项</p>\n</li>\n</ul>\n<h3 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h3><p>如何避免陷入虚假两难的逻辑谬误中呢：</p>\n<ul>\n<li>改变认知：完成比完美重要，一件事并不是完美和不做两个选项</li>\n<li>做计划的面面俱到 ❌</li>\n<li>一心想把事情做的尽善尽美❌</li>\n<li>吝惜资源害怕投入没有产出❌</li>\n</ul>\n<p><u><strong><em>认清谬误和事实，保持清晰思维去分析事情，并做出方案。不要被自己的主观所限制住。</em></strong></u></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><blockquote>\n<p>选择稳定的工作还是追求梦想？享受当下还是活在未来？</p>\n</blockquote>\n<h3 id=\"质疑\"><a href=\"#质疑\" class=\"headerlink\" title=\"质疑\"></a>质疑</h3><p>难道只有两个选择？为什么工作一定是稳定的，稳定工作和追求梦想有冲突吗？享受当下和活在未来不应该是平衡吗？怎么变成了二选一。<strong><u>很多问题的答案远远不只两个</u></strong></p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>许多类似问题，往往因为一些不当的限制，将解决问题限制在一个很严苛的范围内（非黑即白，不是一就是二）</p>\n<p><strong>这种限制是因为：错误地假设这些选项中，必定有一个是正确的，导致经常出现虚假两难谬误。</strong></p>\n<ul>\n<li><p>警惕绝对化措辞</p>\n<p>非黑即白，不是一就是二</p>\n</li>\n<li><p>提出疑问</p>\n<p>没有其他选择了吗？、反问、列举其他选项</p>\n</li>\n</ul>\n<h3 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h3><p>如何避免陷入虚假两难的逻辑谬误中呢：</p>\n<ul>\n<li>改变认知：完成比完美重要，一件事并不是完美和不做两个选项</li>\n<li>做计划的面面俱到 ❌</li>\n<li>一心想把事情做的尽善尽美❌</li>\n<li>吝惜资源害怕投入没有产出❌</li>\n</ul>\n<p><u><strong><em>认清谬误和事实，保持清晰思维去分析事情，并做出方案。不要被自己的主观所限制住。</em></strong></u></p>\n"},{"_content":"转移话题有两种不同的方式\n\n- 转移到不同的话题上去\n- 转移到别的人身上去\n\n识别它们，可以减少无效沟通。\n\n\n\n### 转移话题谬误\n\n从原来的话题转移，到里一个看起来和原话题相关但其实不同的话题，想要以此回避回答，或者是掩盖自己观点的薄弱。\n\n比如：你换条裤子，这个太露了。别人也这么穿。\n\n别人穿和你换裤子有什么关系？\n\n#### 如何识别\n\n- 牢记真正的论题\n- 检查对方是否回答了提问者的问题。\n- 如果对方回答了，检查其论证师是否和主题相关。\n\n#### 如何应对\n\n大多数情况下，话题转移是无意间发生的，如果只是直接说：“你在转移话题”，可能会引起对方的不愉快。因为对方可能没意识到自己跑题了。所以我们可以顺着对方的话委婉的提醒：\n\n“你说的有道理，话说回来...”\n\n“你说的我明白了，那么对于刚刚...的话题，你是怎么看的呢？”\n\n<u>继续话题，并且让对方舒服。</u>\n\n### 稻草人谬误\n\n表面上看起来对方没有转移话题，实际上，对方将你的立场进行了歪曲和夸大。先树立一个错漏百出的“稻草人”，然后再去攻击、反驳这个稻草人。\n\n比如常见的劝酒：你不喝酒就是看不起我们咯？这里把“不能喝酒”解读为“看不起人”\n\n#### 如何识别\n\n- 歪曲原意\n\n  “进化论太可笑了，居然说人类是由猩猩进化来的”\n\n  这是曲解，进化论说的是人类和猩猩有共同的祖先\n\n- 结果夸张化\n\n  <u>我不同意缩减推广预算，按照你的意思，公司就不要对外宣传了？</u>\n\n  <u>原文将缩减预算夸大到完全不用对外宣传。并且质疑夸张后的观点，也就是攻击自己树立起来的稻草人。</u>\n\n#### 如何应对\n\n终止歪曲后的话题，并且重新澄清观点\n\n\n\n\n\n#### 思考：\n\n当别人出现转移话题或歪曲、夸大观点时，是不是我本身自己没有准确清晰的表达观点？\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/常见的逻辑谬误/转移到不同的话题.md","raw":"转移话题有两种不同的方式\n\n- 转移到不同的话题上去\n- 转移到别的人身上去\n\n识别它们，可以减少无效沟通。\n\n\n\n### 转移话题谬误\n\n从原来的话题转移，到里一个看起来和原话题相关但其实不同的话题，想要以此回避回答，或者是掩盖自己观点的薄弱。\n\n比如：你换条裤子，这个太露了。别人也这么穿。\n\n别人穿和你换裤子有什么关系？\n\n#### 如何识别\n\n- 牢记真正的论题\n- 检查对方是否回答了提问者的问题。\n- 如果对方回答了，检查其论证师是否和主题相关。\n\n#### 如何应对\n\n大多数情况下，话题转移是无意间发生的，如果只是直接说：“你在转移话题”，可能会引起对方的不愉快。因为对方可能没意识到自己跑题了。所以我们可以顺着对方的话委婉的提醒：\n\n“你说的有道理，话说回来...”\n\n“你说的我明白了，那么对于刚刚...的话题，你是怎么看的呢？”\n\n<u>继续话题，并且让对方舒服。</u>\n\n### 稻草人谬误\n\n表面上看起来对方没有转移话题，实际上，对方将你的立场进行了歪曲和夸大。先树立一个错漏百出的“稻草人”，然后再去攻击、反驳这个稻草人。\n\n比如常见的劝酒：你不喝酒就是看不起我们咯？这里把“不能喝酒”解读为“看不起人”\n\n#### 如何识别\n\n- 歪曲原意\n\n  “进化论太可笑了，居然说人类是由猩猩进化来的”\n\n  这是曲解，进化论说的是人类和猩猩有共同的祖先\n\n- 结果夸张化\n\n  <u>我不同意缩减推广预算，按照你的意思，公司就不要对外宣传了？</u>\n\n  <u>原文将缩减预算夸大到完全不用对外宣传。并且质疑夸张后的观点，也就是攻击自己树立起来的稻草人。</u>\n\n#### 如何应对\n\n终止歪曲后的话题，并且重新澄清观点\n\n\n\n\n\n#### 思考：\n\n当别人出现转移话题或歪曲、夸大观点时，是不是我本身自己没有准确清晰的表达观点？\n\n","slug":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/转移到不同的话题","published":1,"date":"2020-06-25T03:10:24.425Z","updated":"2020-06-25T03:10:24.426Z","title":"LEVEL 1/批判思维/独立思考/常见的逻辑谬误/转移到不同的话题","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wpz001l3ns60apv9w8i","content":"<p>转移话题有两种不同的方式</p>\n<ul>\n<li>转移到不同的话题上去</li>\n<li>转移到别的人身上去</li>\n</ul>\n<p>识别它们，可以减少无效沟通。</p>\n<h3 id=\"转移话题谬误\"><a href=\"#转移话题谬误\" class=\"headerlink\" title=\"转移话题谬误\"></a>转移话题谬误</h3><p>从原来的话题转移，到里一个看起来和原话题相关但其实不同的话题，想要以此回避回答，或者是掩盖自己观点的薄弱。</p>\n<p>比如：你换条裤子，这个太露了。别人也这么穿。</p>\n<p>别人穿和你换裤子有什么关系？</p>\n<h4 id=\"如何识别\"><a href=\"#如何识别\" class=\"headerlink\" title=\"如何识别\"></a>如何识别</h4><ul>\n<li>牢记真正的论题</li>\n<li>检查对方是否回答了提问者的问题。</li>\n<li>如果对方回答了，检查其论证师是否和主题相关。</li>\n</ul>\n<h4 id=\"如何应对\"><a href=\"#如何应对\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h4><p>大多数情况下，话题转移是无意间发生的，如果只是直接说：“你在转移话题”，可能会引起对方的不愉快。因为对方可能没意识到自己跑题了。所以我们可以顺着对方的话委婉的提醒：</p>\n<p>“你说的有道理，话说回来…”</p>\n<p>“你说的我明白了，那么对于刚刚…的话题，你是怎么看的呢？”</p>\n<p><u>继续话题，并且让对方舒服。</u></p>\n<h3 id=\"稻草人谬误\"><a href=\"#稻草人谬误\" class=\"headerlink\" title=\"稻草人谬误\"></a>稻草人谬误</h3><p>表面上看起来对方没有转移话题，实际上，对方将你的立场进行了歪曲和夸大。先树立一个错漏百出的“稻草人”，然后再去攻击、反驳这个稻草人。</p>\n<p>比如常见的劝酒：你不喝酒就是看不起我们咯？这里把“不能喝酒”解读为“看不起人”</p>\n<h4 id=\"如何识别-1\"><a href=\"#如何识别-1\" class=\"headerlink\" title=\"如何识别\"></a>如何识别</h4><ul>\n<li><p>歪曲原意</p>\n<p>“进化论太可笑了，居然说人类是由猩猩进化来的”</p>\n<p>这是曲解，进化论说的是人类和猩猩有共同的祖先</p>\n</li>\n<li><p>结果夸张化</p>\n<p><u>我不同意缩减推广预算，按照你的意思，公司就不要对外宣传了？</u></p>\n<p><u>原文将缩减预算夸大到完全不用对外宣传。并且质疑夸张后的观点，也就是攻击自己树立起来的稻草人。</u></p>\n</li>\n</ul>\n<h4 id=\"如何应对-1\"><a href=\"#如何应对-1\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h4><p>终止歪曲后的话题，并且重新澄清观点</p>\n<h4 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h4><p>当别人出现转移话题或歪曲、夸大观点时，是不是我本身自己没有准确清晰的表达观点？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>转移话题有两种不同的方式</p>\n<ul>\n<li>转移到不同的话题上去</li>\n<li>转移到别的人身上去</li>\n</ul>\n<p>识别它们，可以减少无效沟通。</p>\n<h3 id=\"转移话题谬误\"><a href=\"#转移话题谬误\" class=\"headerlink\" title=\"转移话题谬误\"></a>转移话题谬误</h3><p>从原来的话题转移，到里一个看起来和原话题相关但其实不同的话题，想要以此回避回答，或者是掩盖自己观点的薄弱。</p>\n<p>比如：你换条裤子，这个太露了。别人也这么穿。</p>\n<p>别人穿和你换裤子有什么关系？</p>\n<h4 id=\"如何识别\"><a href=\"#如何识别\" class=\"headerlink\" title=\"如何识别\"></a>如何识别</h4><ul>\n<li>牢记真正的论题</li>\n<li>检查对方是否回答了提问者的问题。</li>\n<li>如果对方回答了，检查其论证师是否和主题相关。</li>\n</ul>\n<h4 id=\"如何应对\"><a href=\"#如何应对\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h4><p>大多数情况下，话题转移是无意间发生的，如果只是直接说：“你在转移话题”，可能会引起对方的不愉快。因为对方可能没意识到自己跑题了。所以我们可以顺着对方的话委婉的提醒：</p>\n<p>“你说的有道理，话说回来…”</p>\n<p>“你说的我明白了，那么对于刚刚…的话题，你是怎么看的呢？”</p>\n<p><u>继续话题，并且让对方舒服。</u></p>\n<h3 id=\"稻草人谬误\"><a href=\"#稻草人谬误\" class=\"headerlink\" title=\"稻草人谬误\"></a>稻草人谬误</h3><p>表面上看起来对方没有转移话题，实际上，对方将你的立场进行了歪曲和夸大。先树立一个错漏百出的“稻草人”，然后再去攻击、反驳这个稻草人。</p>\n<p>比如常见的劝酒：你不喝酒就是看不起我们咯？这里把“不能喝酒”解读为“看不起人”</p>\n<h4 id=\"如何识别-1\"><a href=\"#如何识别-1\" class=\"headerlink\" title=\"如何识别\"></a>如何识别</h4><ul>\n<li><p>歪曲原意</p>\n<p>“进化论太可笑了，居然说人类是由猩猩进化来的”</p>\n<p>这是曲解，进化论说的是人类和猩猩有共同的祖先</p>\n</li>\n<li><p>结果夸张化</p>\n<p><u>我不同意缩减推广预算，按照你的意思，公司就不要对外宣传了？</u></p>\n<p><u>原文将缩减预算夸大到完全不用对外宣传。并且质疑夸张后的观点，也就是攻击自己树立起来的稻草人。</u></p>\n</li>\n</ul>\n<h4 id=\"如何应对-1\"><a href=\"#如何应对-1\" class=\"headerlink\" title=\"如何应对\"></a>如何应对</h4><p>终止歪曲后的话题，并且重新澄清观点</p>\n<h4 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h4><p>当别人出现转移话题或歪曲、夸大观点时，是不是我本身自己没有准确清晰的表达观点？</p>\n"},{"_content":"> **独立思考的第一步：主动理清楚思考的对象是什么**，以及我们要判断的是什么。这是抛开主观判断、进行理性思考的第一步\n\n## 如何找到讨论对象\n\n可以通过三个问题来找到讨论对象：\n\n1. **这些信息讨论的是什么？**\n2. **想要我们相信什么？**\n3. **怎么证明ta是对的？**\n\n这三个核心问题，其实就代表了论证的三大要素：`论题`、`结论`、`理由`\n\n## 什么是论题\n\n论题是引起对话或讨论的对象，是后续所有讨论的动力。论题一般分为两种：\n\n#### 描述性论题\n\n> *世界是什么？*\n>\n> *牛奶是白的？*\n>\n> *2019年美国失业人数是多少？*\n>\n> *去年中国的GDP是多少？*\n\n以上是对事物客观状态或属性提出的问题，不为人的意志力转移。这类论题，我们往往更关注：最后的结论是什么\n\n#### 规定性论题\n\n> *打车软件应不应该在高峰期加价？*\n>\n> *女人该趁早结婚？*\n>\n> *在一家公司工作5年后应不应该跳槽？*\n\n以上问题它们跟个人的主观看法相关，讨论的是“世界应该是什么”，我们称之为规定性论题。往往属于 道德、伦理、社会等等领域。这些问题是没有唯一正确答案的，是无法通过研究来证明的。\n\n所以对于规定性论题，我们不会想描述行论题那样关注结论，而更应该关注整个论证过程、也就是得出结论的过程是否合理。\n\n## 什么是结论\n\n> ***<u>结论是对论题的回应，是试图传递给你的信息</u>***，现在很多人搞不清`事实`和`观点`\n\n论题有两种类型，那么结论也是分为两种：\n\n- **事实**\n\n  多吃蔬菜是否有利于健康？我们有一个结论是“多吃蔬菜有利于健康”，如果这是有利于科学研究支撑的，那么这是事实。\n\n  <u>如果针对描述性论题的结论是正确的，我们可以称之为事实</u>\n\n- **观点**\n\n  “蜜蜂是勤劳的益虫”、“大灰狼是坏蛋”、“不应该吃青蛙”等等，这些都是观点，不是事实。\n\n  <u>观点是规定性论题的结论，不同人有不同观点，不存在对错</u>\n\n纯粹观点的争论是无益也是无意义的，理清`事实`和`观点`可以帮助我们减少很多争执、有精力独立思考。\n\n## 怎么证明ta是对的-理由\n\n>  理由是用来支撑结论的看法、证据，也就是得出结论的原因。结论是否可信，就取决于理由是否充足。\n\n描述性论题中，理由一般都是少有争议的信息，只要是通过大量人类实践证明的信息即可。\n\n在规定性论题里，由于结论可以是不同的观点，往往很难通过简单几句话来直接证明，会有大量的理由来进行佐证。如果是没有理由支撑的结论：那就只是“纯观点”，“打嘴炮”，这是毫无价值的。\n\n从理由到结论的推到，是一个论证的过程，往往论证过程不只有一层。\n\n#### 理由和结论的关系\n\n必须先有理由，后后结论。许多人在陷入自我为中心误区的时候<u>，先对自己的结论深信不疑，然后再找理由将结论合理化</u>。这是错误的。\n\n比如，我任务某某明星长的不好看，就是网上找到很多她的丑照。但事实上，这是本末倒置的\n\n## 如何找到论题、结论和理由\n\n#### 找到论题的技巧\n\n- 论题通常会出现在文章的开头部分\n- 而有时候论题是隐藏的，我们可以先找到结论，然后反推出论题。\n\n#### 如何找到结论\n\n- **找到关键词的指示词**\n\n  `因此`、`所以`、`由此可见`、`我觉得`、`这表明` 等等\n\n- **常见在开头和结尾**\n\n- **排除那些一定不是结论的内容**\n\n  例句、数据、定义、背景、证据等等，这些都不可能是结论。\n\n#### 如何找到理由\n\n**留意文中的关键的指示词**\n\n比如：由于、鉴于、研究显示、调查表明\n\n\n\n> **理由是支撑结论是否可靠的基石，它非常重要**\n\n\n\n\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/1 讨论对象三要素｜把偏离的思路拉回正轨.md","raw":"> **独立思考的第一步：主动理清楚思考的对象是什么**，以及我们要判断的是什么。这是抛开主观判断、进行理性思考的第一步\n\n## 如何找到讨论对象\n\n可以通过三个问题来找到讨论对象：\n\n1. **这些信息讨论的是什么？**\n2. **想要我们相信什么？**\n3. **怎么证明ta是对的？**\n\n这三个核心问题，其实就代表了论证的三大要素：`论题`、`结论`、`理由`\n\n## 什么是论题\n\n论题是引起对话或讨论的对象，是后续所有讨论的动力。论题一般分为两种：\n\n#### 描述性论题\n\n> *世界是什么？*\n>\n> *牛奶是白的？*\n>\n> *2019年美国失业人数是多少？*\n>\n> *去年中国的GDP是多少？*\n\n以上是对事物客观状态或属性提出的问题，不为人的意志力转移。这类论题，我们往往更关注：最后的结论是什么\n\n#### 规定性论题\n\n> *打车软件应不应该在高峰期加价？*\n>\n> *女人该趁早结婚？*\n>\n> *在一家公司工作5年后应不应该跳槽？*\n\n以上问题它们跟个人的主观看法相关，讨论的是“世界应该是什么”，我们称之为规定性论题。往往属于 道德、伦理、社会等等领域。这些问题是没有唯一正确答案的，是无法通过研究来证明的。\n\n所以对于规定性论题，我们不会想描述行论题那样关注结论，而更应该关注整个论证过程、也就是得出结论的过程是否合理。\n\n## 什么是结论\n\n> ***<u>结论是对论题的回应，是试图传递给你的信息</u>***，现在很多人搞不清`事实`和`观点`\n\n论题有两种类型，那么结论也是分为两种：\n\n- **事实**\n\n  多吃蔬菜是否有利于健康？我们有一个结论是“多吃蔬菜有利于健康”，如果这是有利于科学研究支撑的，那么这是事实。\n\n  <u>如果针对描述性论题的结论是正确的，我们可以称之为事实</u>\n\n- **观点**\n\n  “蜜蜂是勤劳的益虫”、“大灰狼是坏蛋”、“不应该吃青蛙”等等，这些都是观点，不是事实。\n\n  <u>观点是规定性论题的结论，不同人有不同观点，不存在对错</u>\n\n纯粹观点的争论是无益也是无意义的，理清`事实`和`观点`可以帮助我们减少很多争执、有精力独立思考。\n\n## 怎么证明ta是对的-理由\n\n>  理由是用来支撑结论的看法、证据，也就是得出结论的原因。结论是否可信，就取决于理由是否充足。\n\n描述性论题中，理由一般都是少有争议的信息，只要是通过大量人类实践证明的信息即可。\n\n在规定性论题里，由于结论可以是不同的观点，往往很难通过简单几句话来直接证明，会有大量的理由来进行佐证。如果是没有理由支撑的结论：那就只是“纯观点”，“打嘴炮”，这是毫无价值的。\n\n从理由到结论的推到，是一个论证的过程，往往论证过程不只有一层。\n\n#### 理由和结论的关系\n\n必须先有理由，后后结论。许多人在陷入自我为中心误区的时候<u>，先对自己的结论深信不疑，然后再找理由将结论合理化</u>。这是错误的。\n\n比如，我任务某某明星长的不好看，就是网上找到很多她的丑照。但事实上，这是本末倒置的\n\n## 如何找到论题、结论和理由\n\n#### 找到论题的技巧\n\n- 论题通常会出现在文章的开头部分\n- 而有时候论题是隐藏的，我们可以先找到结论，然后反推出论题。\n\n#### 如何找到结论\n\n- **找到关键词的指示词**\n\n  `因此`、`所以`、`由此可见`、`我觉得`、`这表明` 等等\n\n- **常见在开头和结尾**\n\n- **排除那些一定不是结论的内容**\n\n  例句、数据、定义、背景、证据等等，这些都不可能是结论。\n\n#### 如何找到理由\n\n**留意文中的关键的指示词**\n\n比如：由于、鉴于、研究显示、调查表明\n\n\n\n> **理由是支撑结论是否可靠的基石，它非常重要**\n\n\n\n\n\n","slug":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/1 讨论对象三要素｜把偏离的思路拉回正轨","published":1,"date":"2020-06-25T03:10:24.426Z","updated":"2020-06-25T03:10:24.427Z","title":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/1 讨论对象三要素｜把偏离的思路拉回正轨","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wq0001m3ns69azfgcrp","content":"<blockquote>\n<p><strong>独立思考的第一步：主动理清楚思考的对象是什么</strong>，以及我们要判断的是什么。这是抛开主观判断、进行理性思考的第一步</p>\n</blockquote>\n<h2 id=\"如何找到讨论对象\"><a href=\"#如何找到讨论对象\" class=\"headerlink\" title=\"如何找到讨论对象\"></a>如何找到讨论对象</h2><p>可以通过三个问题来找到讨论对象：</p>\n<ol>\n<li><strong>这些信息讨论的是什么？</strong></li>\n<li><strong>想要我们相信什么？</strong></li>\n<li><strong>怎么证明ta是对的？</strong></li>\n</ol>\n<p>这三个核心问题，其实就代表了论证的三大要素：<code>论题</code>、<code>结论</code>、<code>理由</code></p>\n<h2 id=\"什么是论题\"><a href=\"#什么是论题\" class=\"headerlink\" title=\"什么是论题\"></a>什么是论题</h2><p>论题是引起对话或讨论的对象，是后续所有讨论的动力。论题一般分为两种：</p>\n<h4 id=\"描述性论题\"><a href=\"#描述性论题\" class=\"headerlink\" title=\"描述性论题\"></a>描述性论题</h4><blockquote>\n<p><em>世界是什么？</em></p>\n<p><em>牛奶是白的？</em></p>\n<p><em>2019年美国失业人数是多少？</em></p>\n<p><em>去年中国的GDP是多少？</em></p>\n</blockquote>\n<p>以上是对事物客观状态或属性提出的问题，不为人的意志力转移。这类论题，我们往往更关注：最后的结论是什么</p>\n<h4 id=\"规定性论题\"><a href=\"#规定性论题\" class=\"headerlink\" title=\"规定性论题\"></a>规定性论题</h4><blockquote>\n<p><em>打车软件应不应该在高峰期加价？</em></p>\n<p><em>女人该趁早结婚？</em></p>\n<p><em>在一家公司工作5年后应不应该跳槽？</em></p>\n</blockquote>\n<p>以上问题它们跟个人的主观看法相关，讨论的是“世界应该是什么”，我们称之为规定性论题。往往属于 道德、伦理、社会等等领域。这些问题是没有唯一正确答案的，是无法通过研究来证明的。</p>\n<p>所以对于规定性论题，我们不会想描述行论题那样关注结论，而更应该关注整个论证过程、也就是得出结论的过程是否合理。</p>\n<h2 id=\"什么是结论\"><a href=\"#什么是结论\" class=\"headerlink\" title=\"什么是结论\"></a>什么是结论</h2><blockquote>\n<p><strong>*<u>结论是对论题的回应，是试图传递给你的信息</u>*</strong>，现在很多人搞不清<code>事实</code>和<code>观点</code></p>\n</blockquote>\n<p>论题有两种类型，那么结论也是分为两种：</p>\n<ul>\n<li><p><strong>事实</strong></p>\n<p>多吃蔬菜是否有利于健康？我们有一个结论是“多吃蔬菜有利于健康”，如果这是有利于科学研究支撑的，那么这是事实。</p>\n<p><u>如果针对描述性论题的结论是正确的，我们可以称之为事实</u></p>\n</li>\n<li><p><strong>观点</strong></p>\n<p>“蜜蜂是勤劳的益虫”、“大灰狼是坏蛋”、“不应该吃青蛙”等等，这些都是观点，不是事实。</p>\n<p><u>观点是规定性论题的结论，不同人有不同观点，不存在对错</u></p>\n</li>\n</ul>\n<p>纯粹观点的争论是无益也是无意义的，理清<code>事实</code>和<code>观点</code>可以帮助我们减少很多争执、有精力独立思考。</p>\n<h2 id=\"怎么证明ta是对的-理由\"><a href=\"#怎么证明ta是对的-理由\" class=\"headerlink\" title=\"怎么证明ta是对的-理由\"></a>怎么证明ta是对的-理由</h2><blockquote>\n<p> 理由是用来支撑结论的看法、证据，也就是得出结论的原因。结论是否可信，就取决于理由是否充足。</p>\n</blockquote>\n<p>描述性论题中，理由一般都是少有争议的信息，只要是通过大量人类实践证明的信息即可。</p>\n<p>在规定性论题里，由于结论可以是不同的观点，往往很难通过简单几句话来直接证明，会有大量的理由来进行佐证。如果是没有理由支撑的结论：那就只是“纯观点”，“打嘴炮”，这是毫无价值的。</p>\n<p>从理由到结论的推到，是一个论证的过程，往往论证过程不只有一层。</p>\n<h4 id=\"理由和结论的关系\"><a href=\"#理由和结论的关系\" class=\"headerlink\" title=\"理由和结论的关系\"></a>理由和结论的关系</h4><p>必须先有理由，后后结论。许多人在陷入自我为中心误区的时候<u>，先对自己的结论深信不疑，然后再找理由将结论合理化</u>。这是错误的。</p>\n<p>比如，我任务某某明星长的不好看，就是网上找到很多她的丑照。但事实上，这是本末倒置的</p>\n<h2 id=\"如何找到论题、结论和理由\"><a href=\"#如何找到论题、结论和理由\" class=\"headerlink\" title=\"如何找到论题、结论和理由\"></a>如何找到论题、结论和理由</h2><h4 id=\"找到论题的技巧\"><a href=\"#找到论题的技巧\" class=\"headerlink\" title=\"找到论题的技巧\"></a>找到论题的技巧</h4><ul>\n<li>论题通常会出现在文章的开头部分</li>\n<li>而有时候论题是隐藏的，我们可以先找到结论，然后反推出论题。</li>\n</ul>\n<h4 id=\"如何找到结论\"><a href=\"#如何找到结论\" class=\"headerlink\" title=\"如何找到结论\"></a>如何找到结论</h4><ul>\n<li><p><strong>找到关键词的指示词</strong></p>\n<p><code>因此</code>、<code>所以</code>、<code>由此可见</code>、<code>我觉得</code>、<code>这表明</code> 等等</p>\n</li>\n<li><p><strong>常见在开头和结尾</strong></p>\n</li>\n<li><p><strong>排除那些一定不是结论的内容</strong></p>\n<p>例句、数据、定义、背景、证据等等，这些都不可能是结论。</p>\n</li>\n</ul>\n<h4 id=\"如何找到理由\"><a href=\"#如何找到理由\" class=\"headerlink\" title=\"如何找到理由\"></a>如何找到理由</h4><p><strong>留意文中的关键的指示词</strong></p>\n<p>比如：由于、鉴于、研究显示、调查表明</p>\n<blockquote>\n<p><strong>理由是支撑结论是否可靠的基石，它非常重要</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>独立思考的第一步：主动理清楚思考的对象是什么</strong>，以及我们要判断的是什么。这是抛开主观判断、进行理性思考的第一步</p>\n</blockquote>\n<h2 id=\"如何找到讨论对象\"><a href=\"#如何找到讨论对象\" class=\"headerlink\" title=\"如何找到讨论对象\"></a>如何找到讨论对象</h2><p>可以通过三个问题来找到讨论对象：</p>\n<ol>\n<li><strong>这些信息讨论的是什么？</strong></li>\n<li><strong>想要我们相信什么？</strong></li>\n<li><strong>怎么证明ta是对的？</strong></li>\n</ol>\n<p>这三个核心问题，其实就代表了论证的三大要素：<code>论题</code>、<code>结论</code>、<code>理由</code></p>\n<h2 id=\"什么是论题\"><a href=\"#什么是论题\" class=\"headerlink\" title=\"什么是论题\"></a>什么是论题</h2><p>论题是引起对话或讨论的对象，是后续所有讨论的动力。论题一般分为两种：</p>\n<h4 id=\"描述性论题\"><a href=\"#描述性论题\" class=\"headerlink\" title=\"描述性论题\"></a>描述性论题</h4><blockquote>\n<p><em>世界是什么？</em></p>\n<p><em>牛奶是白的？</em></p>\n<p><em>2019年美国失业人数是多少？</em></p>\n<p><em>去年中国的GDP是多少？</em></p>\n</blockquote>\n<p>以上是对事物客观状态或属性提出的问题，不为人的意志力转移。这类论题，我们往往更关注：最后的结论是什么</p>\n<h4 id=\"规定性论题\"><a href=\"#规定性论题\" class=\"headerlink\" title=\"规定性论题\"></a>规定性论题</h4><blockquote>\n<p><em>打车软件应不应该在高峰期加价？</em></p>\n<p><em>女人该趁早结婚？</em></p>\n<p><em>在一家公司工作5年后应不应该跳槽？</em></p>\n</blockquote>\n<p>以上问题它们跟个人的主观看法相关，讨论的是“世界应该是什么”，我们称之为规定性论题。往往属于 道德、伦理、社会等等领域。这些问题是没有唯一正确答案的，是无法通过研究来证明的。</p>\n<p>所以对于规定性论题，我们不会想描述行论题那样关注结论，而更应该关注整个论证过程、也就是得出结论的过程是否合理。</p>\n<h2 id=\"什么是结论\"><a href=\"#什么是结论\" class=\"headerlink\" title=\"什么是结论\"></a>什么是结论</h2><blockquote>\n<p><strong>*<u>结论是对论题的回应，是试图传递给你的信息</u>*</strong>，现在很多人搞不清<code>事实</code>和<code>观点</code></p>\n</blockquote>\n<p>论题有两种类型，那么结论也是分为两种：</p>\n<ul>\n<li><p><strong>事实</strong></p>\n<p>多吃蔬菜是否有利于健康？我们有一个结论是“多吃蔬菜有利于健康”，如果这是有利于科学研究支撑的，那么这是事实。</p>\n<p><u>如果针对描述性论题的结论是正确的，我们可以称之为事实</u></p>\n</li>\n<li><p><strong>观点</strong></p>\n<p>“蜜蜂是勤劳的益虫”、“大灰狼是坏蛋”、“不应该吃青蛙”等等，这些都是观点，不是事实。</p>\n<p><u>观点是规定性论题的结论，不同人有不同观点，不存在对错</u></p>\n</li>\n</ul>\n<p>纯粹观点的争论是无益也是无意义的，理清<code>事实</code>和<code>观点</code>可以帮助我们减少很多争执、有精力独立思考。</p>\n<h2 id=\"怎么证明ta是对的-理由\"><a href=\"#怎么证明ta是对的-理由\" class=\"headerlink\" title=\"怎么证明ta是对的-理由\"></a>怎么证明ta是对的-理由</h2><blockquote>\n<p> 理由是用来支撑结论的看法、证据，也就是得出结论的原因。结论是否可信，就取决于理由是否充足。</p>\n</blockquote>\n<p>描述性论题中，理由一般都是少有争议的信息，只要是通过大量人类实践证明的信息即可。</p>\n<p>在规定性论题里，由于结论可以是不同的观点，往往很难通过简单几句话来直接证明，会有大量的理由来进行佐证。如果是没有理由支撑的结论：那就只是“纯观点”，“打嘴炮”，这是毫无价值的。</p>\n<p>从理由到结论的推到，是一个论证的过程，往往论证过程不只有一层。</p>\n<h4 id=\"理由和结论的关系\"><a href=\"#理由和结论的关系\" class=\"headerlink\" title=\"理由和结论的关系\"></a>理由和结论的关系</h4><p>必须先有理由，后后结论。许多人在陷入自我为中心误区的时候<u>，先对自己的结论深信不疑，然后再找理由将结论合理化</u>。这是错误的。</p>\n<p>比如，我任务某某明星长的不好看，就是网上找到很多她的丑照。但事实上，这是本末倒置的</p>\n<h2 id=\"如何找到论题、结论和理由\"><a href=\"#如何找到论题、结论和理由\" class=\"headerlink\" title=\"如何找到论题、结论和理由\"></a>如何找到论题、结论和理由</h2><h4 id=\"找到论题的技巧\"><a href=\"#找到论题的技巧\" class=\"headerlink\" title=\"找到论题的技巧\"></a>找到论题的技巧</h4><ul>\n<li>论题通常会出现在文章的开头部分</li>\n<li>而有时候论题是隐藏的，我们可以先找到结论，然后反推出论题。</li>\n</ul>\n<h4 id=\"如何找到结论\"><a href=\"#如何找到结论\" class=\"headerlink\" title=\"如何找到结论\"></a>如何找到结论</h4><ul>\n<li><p><strong>找到关键词的指示词</strong></p>\n<p><code>因此</code>、<code>所以</code>、<code>由此可见</code>、<code>我觉得</code>、<code>这表明</code> 等等</p>\n</li>\n<li><p><strong>常见在开头和结尾</strong></p>\n</li>\n<li><p><strong>排除那些一定不是结论的内容</strong></p>\n<p>例句、数据、定义、背景、证据等等，这些都不可能是结论。</p>\n</li>\n</ul>\n<h4 id=\"如何找到理由\"><a href=\"#如何找到理由\" class=\"headerlink\" title=\"如何找到理由\"></a>如何找到理由</h4><p><strong>留意文中的关键的指示词</strong></p>\n<p>比如：由于、鉴于、研究显示、调查表明</p>\n<blockquote>\n<p><strong>理由是支撑结论是否可靠的基石，它非常重要</strong></p>\n</blockquote>\n"},{"_content":"## 如何对理由批判性思考？\n\n>  如果理由经不起批判性思考，那又怎么能支撑结论呢？对理由进行批判性思考，可以检测证据的效力如何。\n\n而对理由批判性思考，先看**支持理由的证据效力如何**，也就是检测理由的可信度。\n\n\n\n## 如何检测理由的可信度\n\n如何检测理由的可信度，可以从通常具有效力的证据类型入手，常见的3种证据类型：\n\n1. **个人经历**\n\n   自身经历、他人经历。有局限性：人类大脑会选择性得记住哪些想记的片段，而忽略掉一些细节。\n\n   同样，他人的经历存在不确定性。这个证据的有效性是不太具有强说服力的。\n\n2. **权威或专家意见**\n\n   权威或专家代表一个<u>领域的最高话语权</u>，但一定可靠吗？\n\n   - 首先看到专家说，权威说的信息时，先甄别信息来源。\n   - 确认专家在谈论的话题领域有没有足够权威。前三和前300可就差远了。\n   - 专家谈论该话题时，有没有存在利益背景。\n\n3. **数据或研究报告**\n\n   数据时客观的，但客观就一定可靠吗？怎么验证数据是不是可靠的\n\n   - 时效性\n\n     比如1990年的就业数据，对2019年的就业分析是没有什么效力的。但2018年的就业数据对2019年的就业分析是具有效力的。\n\n   - 完整性\n\n     典型的数据样本问题。比如对一家奶茶店的问卷调查。调查100人时不足以说明什么问题。可能这100人只是奶茶店顾客的5%。5%不足以代表100%意见反馈。\n\n\n\n## 完全不可信的类比\n\n<u>什么是类比</u>？类比是通过找到两件事情的相似点作为基础，从而推断出一个结论。\n\n比如：纸质书很快就会被电子书代替，就如当年CD被MP3代替一样。（完全不是一回事，简单粗暴做类比推断来断定一件事情）\n\n**<u>*类比只看到相似点，没有考虑到其他不同的因素*</u>**\n\n但很多时候，类比帮助别人更好的理解，是非常可取的一种方式。而作为结论的理由，类比只是一种猜测，不可靠。在论证的时候，提防不可靠的类比。\n\n\n\n> **除了严谨的选择证据之外，还需要看到一些看不见的假设**","source":"_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/2 四类证据效力｜打造缜密的思维.md","raw":"## 如何对理由批判性思考？\n\n>  如果理由经不起批判性思考，那又怎么能支撑结论呢？对理由进行批判性思考，可以检测证据的效力如何。\n\n而对理由批判性思考，先看**支持理由的证据效力如何**，也就是检测理由的可信度。\n\n\n\n## 如何检测理由的可信度\n\n如何检测理由的可信度，可以从通常具有效力的证据类型入手，常见的3种证据类型：\n\n1. **个人经历**\n\n   自身经历、他人经历。有局限性：人类大脑会选择性得记住哪些想记的片段，而忽略掉一些细节。\n\n   同样，他人的经历存在不确定性。这个证据的有效性是不太具有强说服力的。\n\n2. **权威或专家意见**\n\n   权威或专家代表一个<u>领域的最高话语权</u>，但一定可靠吗？\n\n   - 首先看到专家说，权威说的信息时，先甄别信息来源。\n   - 确认专家在谈论的话题领域有没有足够权威。前三和前300可就差远了。\n   - 专家谈论该话题时，有没有存在利益背景。\n\n3. **数据或研究报告**\n\n   数据时客观的，但客观就一定可靠吗？怎么验证数据是不是可靠的\n\n   - 时效性\n\n     比如1990年的就业数据，对2019年的就业分析是没有什么效力的。但2018年的就业数据对2019年的就业分析是具有效力的。\n\n   - 完整性\n\n     典型的数据样本问题。比如对一家奶茶店的问卷调查。调查100人时不足以说明什么问题。可能这100人只是奶茶店顾客的5%。5%不足以代表100%意见反馈。\n\n\n\n## 完全不可信的类比\n\n<u>什么是类比</u>？类比是通过找到两件事情的相似点作为基础，从而推断出一个结论。\n\n比如：纸质书很快就会被电子书代替，就如当年CD被MP3代替一样。（完全不是一回事，简单粗暴做类比推断来断定一件事情）\n\n**<u>*类比只看到相似点，没有考虑到其他不同的因素*</u>**\n\n但很多时候，类比帮助别人更好的理解，是非常可取的一种方式。而作为结论的理由，类比只是一种猜测，不可靠。在论证的时候，提防不可靠的类比。\n\n\n\n> **除了严谨的选择证据之外，还需要看到一些看不见的假设**","slug":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/2 四类证据效力｜打造缜密的思维","published":1,"date":"2020-06-25T03:10:24.427Z","updated":"2020-06-25T03:10:24.428Z","title":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/2 四类证据效力｜打造缜密的思维","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wq0001n3ns69wshdcrq","content":"<h2 id=\"如何对理由批判性思考？\"><a href=\"#如何对理由批判性思考？\" class=\"headerlink\" title=\"如何对理由批判性思考？\"></a>如何对理由批判性思考？</h2><blockquote>\n<p> 如果理由经不起批判性思考，那又怎么能支撑结论呢？对理由进行批判性思考，可以检测证据的效力如何。</p>\n</blockquote>\n<p>而对理由批判性思考，先看<strong>支持理由的证据效力如何</strong>，也就是检测理由的可信度。</p>\n<h2 id=\"如何检测理由的可信度\"><a href=\"#如何检测理由的可信度\" class=\"headerlink\" title=\"如何检测理由的可信度\"></a>如何检测理由的可信度</h2><p>如何检测理由的可信度，可以从通常具有效力的证据类型入手，常见的3种证据类型：</p>\n<ol>\n<li><p><strong>个人经历</strong></p>\n<p>自身经历、他人经历。有局限性：人类大脑会选择性得记住哪些想记的片段，而忽略掉一些细节。</p>\n<p>同样，他人的经历存在不确定性。这个证据的有效性是不太具有强说服力的。</p>\n</li>\n<li><p><strong>权威或专家意见</strong></p>\n<p>权威或专家代表一个<u>领域的最高话语权</u>，但一定可靠吗？</p>\n<ul>\n<li>首先看到专家说，权威说的信息时，先甄别信息来源。</li>\n<li>确认专家在谈论的话题领域有没有足够权威。前三和前300可就差远了。</li>\n<li>专家谈论该话题时，有没有存在利益背景。</li>\n</ul>\n</li>\n<li><p><strong>数据或研究报告</strong></p>\n<p>数据时客观的，但客观就一定可靠吗？怎么验证数据是不是可靠的</p>\n<ul>\n<li><p>时效性</p>\n<p>比如1990年的就业数据，对2019年的就业分析是没有什么效力的。但2018年的就业数据对2019年的就业分析是具有效力的。</p>\n</li>\n<li><p>完整性</p>\n<p>典型的数据样本问题。比如对一家奶茶店的问卷调查。调查100人时不足以说明什么问题。可能这100人只是奶茶店顾客的5%。5%不足以代表100%意见反馈。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"完全不可信的类比\"><a href=\"#完全不可信的类比\" class=\"headerlink\" title=\"完全不可信的类比\"></a>完全不可信的类比</h2><p><u>什么是类比</u>？类比是通过找到两件事情的相似点作为基础，从而推断出一个结论。</p>\n<p>比如：纸质书很快就会被电子书代替，就如当年CD被MP3代替一样。（完全不是一回事，简单粗暴做类比推断来断定一件事情）</p>\n<p><strong><u><em>类比只看到相似点，没有考虑到其他不同的因素</em></u></strong></p>\n<p>但很多时候，类比帮助别人更好的理解，是非常可取的一种方式。而作为结论的理由，类比只是一种猜测，不可靠。在论证的时候，提防不可靠的类比。</p>\n<blockquote>\n<p><strong>除了严谨的选择证据之外，还需要看到一些看不见的假设</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何对理由批判性思考？\"><a href=\"#如何对理由批判性思考？\" class=\"headerlink\" title=\"如何对理由批判性思考？\"></a>如何对理由批判性思考？</h2><blockquote>\n<p> 如果理由经不起批判性思考，那又怎么能支撑结论呢？对理由进行批判性思考，可以检测证据的效力如何。</p>\n</blockquote>\n<p>而对理由批判性思考，先看<strong>支持理由的证据效力如何</strong>，也就是检测理由的可信度。</p>\n<h2 id=\"如何检测理由的可信度\"><a href=\"#如何检测理由的可信度\" class=\"headerlink\" title=\"如何检测理由的可信度\"></a>如何检测理由的可信度</h2><p>如何检测理由的可信度，可以从通常具有效力的证据类型入手，常见的3种证据类型：</p>\n<ol>\n<li><p><strong>个人经历</strong></p>\n<p>自身经历、他人经历。有局限性：人类大脑会选择性得记住哪些想记的片段，而忽略掉一些细节。</p>\n<p>同样，他人的经历存在不确定性。这个证据的有效性是不太具有强说服力的。</p>\n</li>\n<li><p><strong>权威或专家意见</strong></p>\n<p>权威或专家代表一个<u>领域的最高话语权</u>，但一定可靠吗？</p>\n<ul>\n<li>首先看到专家说，权威说的信息时，先甄别信息来源。</li>\n<li>确认专家在谈论的话题领域有没有足够权威。前三和前300可就差远了。</li>\n<li>专家谈论该话题时，有没有存在利益背景。</li>\n</ul>\n</li>\n<li><p><strong>数据或研究报告</strong></p>\n<p>数据时客观的，但客观就一定可靠吗？怎么验证数据是不是可靠的</p>\n<ul>\n<li><p>时效性</p>\n<p>比如1990年的就业数据，对2019年的就业分析是没有什么效力的。但2018年的就业数据对2019年的就业分析是具有效力的。</p>\n</li>\n<li><p>完整性</p>\n<p>典型的数据样本问题。比如对一家奶茶店的问卷调查。调查100人时不足以说明什么问题。可能这100人只是奶茶店顾客的5%。5%不足以代表100%意见反馈。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"完全不可信的类比\"><a href=\"#完全不可信的类比\" class=\"headerlink\" title=\"完全不可信的类比\"></a>完全不可信的类比</h2><p><u>什么是类比</u>？类比是通过找到两件事情的相似点作为基础，从而推断出一个结论。</p>\n<p>比如：纸质书很快就会被电子书代替，就如当年CD被MP3代替一样。（完全不是一回事，简单粗暴做类比推断来断定一件事情）</p>\n<p><strong><u><em>类比只看到相似点，没有考虑到其他不同的因素</em></u></strong></p>\n<p>但很多时候，类比帮助别人更好的理解，是非常可取的一种方式。而作为结论的理由，类比只是一种猜测，不可靠。在论证的时候，提防不可靠的类比。</p>\n<blockquote>\n<p><strong>除了严谨的选择证据之外，还需要看到一些看不见的假设</strong></p>\n</blockquote>\n"},{"_content":"> 发现前提假设：破除眼见为实，以为看见或听见的就是全部，不要让假设经常迷惑我们的眼睛。假设类型，一般为两种：价值观假设、描述性假设\n\n\n\n## 价值观假设\n\n#### 什么是价值观假设\n\n关于一种价值观比另一种价值观更重要的假设\n\n比如：宁可放弃经济发展也要治理雾霾（几年前我还被带进去了，导致了非黑即白，难道不能通知治理雾霾又发展经济吗？）\n\n#### 如何识别价值观假设\n\n- 了解对方的背景\n\n  - 了解作者的背景信息\n  - 阅读作者的以往作品\n\n  以此来了解作者的是什么样的人，作者的价值观\n\n- 反向思考\n\n  假设自己采取相反的观点，那突出的是哪些价值观\n\n## 描述性假设\n\n#### 什么是描述性假设\n\n对一些客观描述的假设；关于世界过去、现在、未来是怎样的假设\n\n比如：”我觉得小王应该是感冒了，因为昨天降温，他衣服穿得少“。\n\n#### 如何发现描述性假设\n\n技巧：理由和结论之间在逻辑上是怎么联系起来的\n\n实践：感冒真的和衣服穿得少有关系吗？因为衣服穿得少导致了小王感冒？感冒不是病毒感染吗？穿得少所以感染了？\n\n\n\n## 总结\n\n发现论证背后的隐藏的假设，对我们论证质量的提高和价值观发现非常有帮助。\n\n发现更多的论证漏洞或者为自己的论证找到更充足的理由，以及对发现自己真正的价值观\n\n","source":"_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/3 两类假设｜洞悉那些看似有道理却靠不住的观念.md","raw":"> 发现前提假设：破除眼见为实，以为看见或听见的就是全部，不要让假设经常迷惑我们的眼睛。假设类型，一般为两种：价值观假设、描述性假设\n\n\n\n## 价值观假设\n\n#### 什么是价值观假设\n\n关于一种价值观比另一种价值观更重要的假设\n\n比如：宁可放弃经济发展也要治理雾霾（几年前我还被带进去了，导致了非黑即白，难道不能通知治理雾霾又发展经济吗？）\n\n#### 如何识别价值观假设\n\n- 了解对方的背景\n\n  - 了解作者的背景信息\n  - 阅读作者的以往作品\n\n  以此来了解作者的是什么样的人，作者的价值观\n\n- 反向思考\n\n  假设自己采取相反的观点，那突出的是哪些价值观\n\n## 描述性假设\n\n#### 什么是描述性假设\n\n对一些客观描述的假设；关于世界过去、现在、未来是怎样的假设\n\n比如：”我觉得小王应该是感冒了，因为昨天降温，他衣服穿得少“。\n\n#### 如何发现描述性假设\n\n技巧：理由和结论之间在逻辑上是怎么联系起来的\n\n实践：感冒真的和衣服穿得少有关系吗？因为衣服穿得少导致了小王感冒？感冒不是病毒感染吗？穿得少所以感染了？\n\n\n\n## 总结\n\n发现论证背后的隐藏的假设，对我们论证质量的提高和价值观发现非常有帮助。\n\n发现更多的论证漏洞或者为自己的论证找到更充足的理由，以及对发现自己真正的价值观\n\n","slug":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/3 两类假设｜洞悉那些看似有道理却靠不住的观念","published":1,"date":"2020-06-25T03:10:24.428Z","updated":"2020-06-25T03:10:24.428Z","title":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/3 两类假设｜洞悉那些看似有道理却靠不住的观念","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wq1001o3ns6fmkzg0y9","content":"<blockquote>\n<p>发现前提假设：破除眼见为实，以为看见或听见的就是全部，不要让假设经常迷惑我们的眼睛。假设类型，一般为两种：价值观假设、描述性假设</p>\n</blockquote>\n<h2 id=\"价值观假设\"><a href=\"#价值观假设\" class=\"headerlink\" title=\"价值观假设\"></a>价值观假设</h2><h4 id=\"什么是价值观假设\"><a href=\"#什么是价值观假设\" class=\"headerlink\" title=\"什么是价值观假设\"></a>什么是价值观假设</h4><p>关于一种价值观比另一种价值观更重要的假设</p>\n<p>比如：宁可放弃经济发展也要治理雾霾（几年前我还被带进去了，导致了非黑即白，难道不能通知治理雾霾又发展经济吗？）</p>\n<h4 id=\"如何识别价值观假设\"><a href=\"#如何识别价值观假设\" class=\"headerlink\" title=\"如何识别价值观假设\"></a>如何识别价值观假设</h4><ul>\n<li><p>了解对方的背景</p>\n<ul>\n<li>了解作者的背景信息</li>\n<li>阅读作者的以往作品</li>\n</ul>\n<p>以此来了解作者的是什么样的人，作者的价值观</p>\n</li>\n<li><p>反向思考</p>\n<p>假设自己采取相反的观点，那突出的是哪些价值观</p>\n</li>\n</ul>\n<h2 id=\"描述性假设\"><a href=\"#描述性假设\" class=\"headerlink\" title=\"描述性假设\"></a>描述性假设</h2><h4 id=\"什么是描述性假设\"><a href=\"#什么是描述性假设\" class=\"headerlink\" title=\"什么是描述性假设\"></a>什么是描述性假设</h4><p>对一些客观描述的假设；关于世界过去、现在、未来是怎样的假设</p>\n<p>比如：”我觉得小王应该是感冒了，因为昨天降温，他衣服穿得少“。</p>\n<h4 id=\"如何发现描述性假设\"><a href=\"#如何发现描述性假设\" class=\"headerlink\" title=\"如何发现描述性假设\"></a>如何发现描述性假设</h4><p>技巧：理由和结论之间在逻辑上是怎么联系起来的</p>\n<p>实践：感冒真的和衣服穿得少有关系吗？因为衣服穿得少导致了小王感冒？感冒不是病毒感染吗？穿得少所以感染了？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>发现论证背后的隐藏的假设，对我们论证质量的提高和价值观发现非常有帮助。</p>\n<p>发现更多的论证漏洞或者为自己的论证找到更充足的理由，以及对发现自己真正的价值观</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>发现前提假设：破除眼见为实，以为看见或听见的就是全部，不要让假设经常迷惑我们的眼睛。假设类型，一般为两种：价值观假设、描述性假设</p>\n</blockquote>\n<h2 id=\"价值观假设\"><a href=\"#价值观假设\" class=\"headerlink\" title=\"价值观假设\"></a>价值观假设</h2><h4 id=\"什么是价值观假设\"><a href=\"#什么是价值观假设\" class=\"headerlink\" title=\"什么是价值观假设\"></a>什么是价值观假设</h4><p>关于一种价值观比另一种价值观更重要的假设</p>\n<p>比如：宁可放弃经济发展也要治理雾霾（几年前我还被带进去了，导致了非黑即白，难道不能通知治理雾霾又发展经济吗？）</p>\n<h4 id=\"如何识别价值观假设\"><a href=\"#如何识别价值观假设\" class=\"headerlink\" title=\"如何识别价值观假设\"></a>如何识别价值观假设</h4><ul>\n<li><p>了解对方的背景</p>\n<ul>\n<li>了解作者的背景信息</li>\n<li>阅读作者的以往作品</li>\n</ul>\n<p>以此来了解作者的是什么样的人，作者的价值观</p>\n</li>\n<li><p>反向思考</p>\n<p>假设自己采取相反的观点，那突出的是哪些价值观</p>\n</li>\n</ul>\n<h2 id=\"描述性假设\"><a href=\"#描述性假设\" class=\"headerlink\" title=\"描述性假设\"></a>描述性假设</h2><h4 id=\"什么是描述性假设\"><a href=\"#什么是描述性假设\" class=\"headerlink\" title=\"什么是描述性假设\"></a>什么是描述性假设</h4><p>对一些客观描述的假设；关于世界过去、现在、未来是怎样的假设</p>\n<p>比如：”我觉得小王应该是感冒了，因为昨天降温，他衣服穿得少“。</p>\n<h4 id=\"如何发现描述性假设\"><a href=\"#如何发现描述性假设\" class=\"headerlink\" title=\"如何发现描述性假设\"></a>如何发现描述性假设</h4><p>技巧：理由和结论之间在逻辑上是怎么联系起来的</p>\n<p>实践：感冒真的和衣服穿得少有关系吗？因为衣服穿得少导致了小王感冒？感冒不是病毒感染吗？穿得少所以感染了？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>发现论证背后的隐藏的假设，对我们论证质量的提高和价值观发现非常有帮助。</p>\n<p>发现更多的论证漏洞或者为自己的论证找到更充足的理由，以及对发现自己真正的价值观</p>\n"},{"_content":"## 为什么要提防逻辑谬误\n\n让我们辨别理由是否足够充分的推出结论，以及跟他人争论时，识别他人的“神逻辑”，占据优势。\n\n先看看常见的几种逻辑谬误：\n\n- **因果倒置谬误**\n- **诉诸公众谬误**\n- **虚假两难选择谬误**\n\n\n\n## 因果倒置谬误\n\n- 把原因当结果\n\n  名牌大学毕业的学生都能找到好工作，说明名牌大学能创造优秀人才。为什么不是本来比较优秀的人很多上名牌大学了呢。\n\n- 把相关当因果\n\n  长的好看的人普遍收入高，所以应该是整容。\n\n  长得好看和收入高没有因果关系，是相关关系。收入高 爱打扮，看起来好看。也可能是长的好看的人普遍自信，本质上来说是自信的人收入更高。\n\n## 诉诸公众谬误\n\n24名听证会参与人全部赞成水价上涨，所以水价上涨是合理的。\n\n24位参会人代表全市人民吗？他们的身份、背景是什么样的，如果他们是水利公司的人呢？\n\n这里认为“大部分人”同意就是对的。<u>利用人们的丛众心理</u>，可能是伪公众。\n\n## 虚假两难选择谬误\n\n我觉得你现在必须做一个决定：要么分手，要么凑合。\n\n难道没第三、第四个选择吗？深度沟通一次，冷静期。这些不是选择吗？为什么不是一就是二？\n\n<u>跳出思维枷锁，会发现办法总比困难多</u>\n\n\n\n>  **一旦有了这样的一些谬误，不仅难做到独立思考，而且容易被他人利用。将自己局限在一个小天地里。迷惘焦虑却无法解决问题。**\n>\n> 跳出思维定势、破除这些逻辑谬误，寻求突破口。做一个掌握自己思想的人。\n\n\n\n> <u>***把独立思考和综合判断的能力放在第一位，而非获得特定知识的能力***</u>——爱因斯坦 \n\n","source":"_posts/LEVEL 1/批判思维/独立思考/思考跟独立四步法/4 三种逻辑谬误｜牢固掌握批判性思维能力.md","raw":"## 为什么要提防逻辑谬误\n\n让我们辨别理由是否足够充分的推出结论，以及跟他人争论时，识别他人的“神逻辑”，占据优势。\n\n先看看常见的几种逻辑谬误：\n\n- **因果倒置谬误**\n- **诉诸公众谬误**\n- **虚假两难选择谬误**\n\n\n\n## 因果倒置谬误\n\n- 把原因当结果\n\n  名牌大学毕业的学生都能找到好工作，说明名牌大学能创造优秀人才。为什么不是本来比较优秀的人很多上名牌大学了呢。\n\n- 把相关当因果\n\n  长的好看的人普遍收入高，所以应该是整容。\n\n  长得好看和收入高没有因果关系，是相关关系。收入高 爱打扮，看起来好看。也可能是长的好看的人普遍自信，本质上来说是自信的人收入更高。\n\n## 诉诸公众谬误\n\n24名听证会参与人全部赞成水价上涨，所以水价上涨是合理的。\n\n24位参会人代表全市人民吗？他们的身份、背景是什么样的，如果他们是水利公司的人呢？\n\n这里认为“大部分人”同意就是对的。<u>利用人们的丛众心理</u>，可能是伪公众。\n\n## 虚假两难选择谬误\n\n我觉得你现在必须做一个决定：要么分手，要么凑合。\n\n难道没第三、第四个选择吗？深度沟通一次，冷静期。这些不是选择吗？为什么不是一就是二？\n\n<u>跳出思维枷锁，会发现办法总比困难多</u>\n\n\n\n>  **一旦有了这样的一些谬误，不仅难做到独立思考，而且容易被他人利用。将自己局限在一个小天地里。迷惘焦虑却无法解决问题。**\n>\n> 跳出思维定势、破除这些逻辑谬误，寻求突破口。做一个掌握自己思想的人。\n\n\n\n> <u>***把独立思考和综合判断的能力放在第一位，而非获得特定知识的能力***</u>——爱因斯坦 \n\n","slug":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/4 三种逻辑谬误｜牢固掌握批判性思维能力","published":1,"date":"2020-06-25T03:10:24.428Z","updated":"2020-06-25T03:10:24.429Z","title":"LEVEL 1/批判思维/独立思考/思考跟独立四步法/4 三种逻辑谬误｜牢固掌握批判性思维能力","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wq3001p3ns6671jgg21","content":"<h2 id=\"为什么要提防逻辑谬误\"><a href=\"#为什么要提防逻辑谬误\" class=\"headerlink\" title=\"为什么要提防逻辑谬误\"></a>为什么要提防逻辑谬误</h2><p>让我们辨别理由是否足够充分的推出结论，以及跟他人争论时，识别他人的“神逻辑”，占据优势。</p>\n<p>先看看常见的几种逻辑谬误：</p>\n<ul>\n<li><strong>因果倒置谬误</strong></li>\n<li><strong>诉诸公众谬误</strong></li>\n<li><strong>虚假两难选择谬误</strong></li>\n</ul>\n<h2 id=\"因果倒置谬误\"><a href=\"#因果倒置谬误\" class=\"headerlink\" title=\"因果倒置谬误\"></a>因果倒置谬误</h2><ul>\n<li><p>把原因当结果</p>\n<p>名牌大学毕业的学生都能找到好工作，说明名牌大学能创造优秀人才。为什么不是本来比较优秀的人很多上名牌大学了呢。</p>\n</li>\n<li><p>把相关当因果</p>\n<p>长的好看的人普遍收入高，所以应该是整容。</p>\n<p>长得好看和收入高没有因果关系，是相关关系。收入高 爱打扮，看起来好看。也可能是长的好看的人普遍自信，本质上来说是自信的人收入更高。</p>\n</li>\n</ul>\n<h2 id=\"诉诸公众谬误\"><a href=\"#诉诸公众谬误\" class=\"headerlink\" title=\"诉诸公众谬误\"></a>诉诸公众谬误</h2><p>24名听证会参与人全部赞成水价上涨，所以水价上涨是合理的。</p>\n<p>24位参会人代表全市人民吗？他们的身份、背景是什么样的，如果他们是水利公司的人呢？</p>\n<p>这里认为“大部分人”同意就是对的。<u>利用人们的丛众心理</u>，可能是伪公众。</p>\n<h2 id=\"虚假两难选择谬误\"><a href=\"#虚假两难选择谬误\" class=\"headerlink\" title=\"虚假两难选择谬误\"></a>虚假两难选择谬误</h2><p>我觉得你现在必须做一个决定：要么分手，要么凑合。</p>\n<p>难道没第三、第四个选择吗？深度沟通一次，冷静期。这些不是选择吗？为什么不是一就是二？</p>\n<p><u>跳出思维枷锁，会发现办法总比困难多</u></p>\n<blockquote>\n<p> <strong>一旦有了这样的一些谬误，不仅难做到独立思考，而且容易被他人利用。将自己局限在一个小天地里。迷惘焦虑却无法解决问题。</strong></p>\n<p>跳出思维定势、破除这些逻辑谬误，寻求突破口。做一个掌握自己思想的人。</p>\n</blockquote>\n<blockquote>\n<p><u><strong><em>把独立思考和综合判断的能力放在第一位，而非获得特定知识的能力</em></strong></u>——爱因斯坦 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要提防逻辑谬误\"><a href=\"#为什么要提防逻辑谬误\" class=\"headerlink\" title=\"为什么要提防逻辑谬误\"></a>为什么要提防逻辑谬误</h2><p>让我们辨别理由是否足够充分的推出结论，以及跟他人争论时，识别他人的“神逻辑”，占据优势。</p>\n<p>先看看常见的几种逻辑谬误：</p>\n<ul>\n<li><strong>因果倒置谬误</strong></li>\n<li><strong>诉诸公众谬误</strong></li>\n<li><strong>虚假两难选择谬误</strong></li>\n</ul>\n<h2 id=\"因果倒置谬误\"><a href=\"#因果倒置谬误\" class=\"headerlink\" title=\"因果倒置谬误\"></a>因果倒置谬误</h2><ul>\n<li><p>把原因当结果</p>\n<p>名牌大学毕业的学生都能找到好工作，说明名牌大学能创造优秀人才。为什么不是本来比较优秀的人很多上名牌大学了呢。</p>\n</li>\n<li><p>把相关当因果</p>\n<p>长的好看的人普遍收入高，所以应该是整容。</p>\n<p>长得好看和收入高没有因果关系，是相关关系。收入高 爱打扮，看起来好看。也可能是长的好看的人普遍自信，本质上来说是自信的人收入更高。</p>\n</li>\n</ul>\n<h2 id=\"诉诸公众谬误\"><a href=\"#诉诸公众谬误\" class=\"headerlink\" title=\"诉诸公众谬误\"></a>诉诸公众谬误</h2><p>24名听证会参与人全部赞成水价上涨，所以水价上涨是合理的。</p>\n<p>24位参会人代表全市人民吗？他们的身份、背景是什么样的，如果他们是水利公司的人呢？</p>\n<p>这里认为“大部分人”同意就是对的。<u>利用人们的丛众心理</u>，可能是伪公众。</p>\n<h2 id=\"虚假两难选择谬误\"><a href=\"#虚假两难选择谬误\" class=\"headerlink\" title=\"虚假两难选择谬误\"></a>虚假两难选择谬误</h2><p>我觉得你现在必须做一个决定：要么分手，要么凑合。</p>\n<p>难道没第三、第四个选择吗？深度沟通一次，冷静期。这些不是选择吗？为什么不是一就是二？</p>\n<p><u>跳出思维枷锁，会发现办法总比困难多</u></p>\n<blockquote>\n<p> <strong>一旦有了这样的一些谬误，不仅难做到独立思考，而且容易被他人利用。将自己局限在一个小天地里。迷惘焦虑却无法解决问题。</strong></p>\n<p>跳出思维定势、破除这些逻辑谬误，寻求突破口。做一个掌握自己思想的人。</p>\n</blockquote>\n<blockquote>\n<p><u><strong><em>把独立思考和综合判断的能力放在第一位，而非获得特定知识的能力</em></strong></u>——爱因斯坦 </p>\n</blockquote>\n"},{"_content":"## 四种常见思维误区\n\n1. ### 自我为中心\n\n   > 你看到一篇文章，是一位老板写的，说他的实习生竟然拒绝帮自己拿外卖，你的第一反应是什么？\n\n   \n\n   由于个人成长经历、社会环境、教育背景等影响，我们在感知信息的时候，容易选择性的关注那些我们关心的信息，而自动忽略其他相反的信息。——选择性知觉\n\n   **破除：真正去关心真相到底是什么**\n\n2. ### 盲从信息\n\n   > 佳洁士等牙膏广告上，都会标注“经全国牙防组认证”这几个字，借此认证，迅速获取消费者信任。然后10多年后被曝，牙防组根本不是什么认证的权威机构。\n\n   当今信息爆炸时代，媒体未来吸引观众注意力，往往把信息尽可能低幼化、情绪化、直觉化。以便观众容易接受，导致我们对接受到的信息缺乏甄别能力，总是一味的吸收。这种盲从导致我们无法独立思考。\n\n3. ### 眼见为实\n\n   > 政府应该禁止香烟买卖，我的理由是：吸烟危害吸烟者健康，二手烟还对他人造成影响\n\n   这话表面看起来停客观公正的，但事实隐藏了一个假设：健康比吸烟的自由更重要。所以我们为了人们的健康，可以剥夺他们的选择自由。这时候你又会怎么想呢？\n\n   我们会以为别人说的信息就是全部，基于这些信息作判断，而没有发现对方可能隐藏了一些“看不见的”前提假设。眼见不一定为实，“看不见的”可能比“看得见的”更加重要。\n\n4. ### 简单归因\n\n   我们试图用很简单的方式去解释一个复杂的现象或事物。看到穷人觉得他懒，看到大龄单身女青年就觉得她挑。这些也会阻碍我们独立了思考。\n\n## 如何破除误区\n\n1. ### 找出讨论对象\n\n   1. 这讨论的是什么\n   2. 对方想让我相信什么\n   3. 对方怎么证明他是对的\n\n2. ### 检验证据效力\n\n   对于接收到的所有信息，我们要有意识地甄别是不是有可靠的证据\n\n3. ### 发现隐藏假设\n\n   想想对方在什么语境说这些话，有没有隐藏一些前提假设，企图影响你的判断。（看到作者的真实的价值取向）。\n\n   破除“眼见为实”的误区，除了看到那些看得见的理由之外，还要去推敲背后看不见的假设是什么\n\n4. ### 提防逻辑谬误\n\n   如果想要减少被带偏，我们需要检验结论和理由之间是否存在合理的逻辑关系，并且多认识一些常见的逻辑谬误。\n\n\n\n## 现有的误区\n\n- 盲从信息：权威说的话并不一定可信或真实。\n- 眼见为实","source":"_posts/LEVEL 1/批判思维/独立思考/破除思维误区/四大思维误区｜冲破独立思考.md","raw":"## 四种常见思维误区\n\n1. ### 自我为中心\n\n   > 你看到一篇文章，是一位老板写的，说他的实习生竟然拒绝帮自己拿外卖，你的第一反应是什么？\n\n   \n\n   由于个人成长经历、社会环境、教育背景等影响，我们在感知信息的时候，容易选择性的关注那些我们关心的信息，而自动忽略其他相反的信息。——选择性知觉\n\n   **破除：真正去关心真相到底是什么**\n\n2. ### 盲从信息\n\n   > 佳洁士等牙膏广告上，都会标注“经全国牙防组认证”这几个字，借此认证，迅速获取消费者信任。然后10多年后被曝，牙防组根本不是什么认证的权威机构。\n\n   当今信息爆炸时代，媒体未来吸引观众注意力，往往把信息尽可能低幼化、情绪化、直觉化。以便观众容易接受，导致我们对接受到的信息缺乏甄别能力，总是一味的吸收。这种盲从导致我们无法独立思考。\n\n3. ### 眼见为实\n\n   > 政府应该禁止香烟买卖，我的理由是：吸烟危害吸烟者健康，二手烟还对他人造成影响\n\n   这话表面看起来停客观公正的，但事实隐藏了一个假设：健康比吸烟的自由更重要。所以我们为了人们的健康，可以剥夺他们的选择自由。这时候你又会怎么想呢？\n\n   我们会以为别人说的信息就是全部，基于这些信息作判断，而没有发现对方可能隐藏了一些“看不见的”前提假设。眼见不一定为实，“看不见的”可能比“看得见的”更加重要。\n\n4. ### 简单归因\n\n   我们试图用很简单的方式去解释一个复杂的现象或事物。看到穷人觉得他懒，看到大龄单身女青年就觉得她挑。这些也会阻碍我们独立了思考。\n\n## 如何破除误区\n\n1. ### 找出讨论对象\n\n   1. 这讨论的是什么\n   2. 对方想让我相信什么\n   3. 对方怎么证明他是对的\n\n2. ### 检验证据效力\n\n   对于接收到的所有信息，我们要有意识地甄别是不是有可靠的证据\n\n3. ### 发现隐藏假设\n\n   想想对方在什么语境说这些话，有没有隐藏一些前提假设，企图影响你的判断。（看到作者的真实的价值取向）。\n\n   破除“眼见为实”的误区，除了看到那些看得见的理由之外，还要去推敲背后看不见的假设是什么\n\n4. ### 提防逻辑谬误\n\n   如果想要减少被带偏，我们需要检验结论和理由之间是否存在合理的逻辑关系，并且多认识一些常见的逻辑谬误。\n\n\n\n## 现有的误区\n\n- 盲从信息：权威说的话并不一定可信或真实。\n- 眼见为实","slug":"LEVEL 1/批判思维/独立思考/破除思维误区/四大思维误区｜冲破独立思考","published":1,"date":"2020-06-25T03:10:24.429Z","updated":"2020-06-25T03:10:24.429Z","title":"LEVEL 1/批判思维/独立思考/破除思维误区/四大思维误区｜冲破独立思考","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbvm3wq5001q3ns6gz4r8chy","content":"<h2 id=\"四种常见思维误区\"><a href=\"#四种常见思维误区\" class=\"headerlink\" title=\"四种常见思维误区\"></a>四种常见思维误区</h2><ol>\n<li><h3 id=\"自我为中心\"><a href=\"#自我为中心\" class=\"headerlink\" title=\"自我为中心\"></a>自我为中心</h3><blockquote>\n<p>你看到一篇文章，是一位老板写的，说他的实习生竟然拒绝帮自己拿外卖，你的第一反应是什么？</p>\n</blockquote>\n</li>\n</ol>\n<p>   由于个人成长经历、社会环境、教育背景等影响，我们在感知信息的时候，容易选择性的关注那些我们关心的信息，而自动忽略其他相反的信息。——选择性知觉</p>\n<p>   <strong>破除：真正去关心真相到底是什么</strong></p>\n<ol start=\"2\">\n<li><h3 id=\"盲从信息\"><a href=\"#盲从信息\" class=\"headerlink\" title=\"盲从信息\"></a>盲从信息</h3><blockquote>\n<p>佳洁士等牙膏广告上，都会标注“经全国牙防组认证”这几个字，借此认证，迅速获取消费者信任。然后10多年后被曝，牙防组根本不是什么认证的权威机构。</p>\n</blockquote>\n<p>当今信息爆炸时代，媒体未来吸引观众注意力，往往把信息尽可能低幼化、情绪化、直觉化。以便观众容易接受，导致我们对接受到的信息缺乏甄别能力，总是一味的吸收。这种盲从导致我们无法独立思考。</p>\n</li>\n<li><h3 id=\"眼见为实\"><a href=\"#眼见为实\" class=\"headerlink\" title=\"眼见为实\"></a>眼见为实</h3><blockquote>\n<p>政府应该禁止香烟买卖，我的理由是：吸烟危害吸烟者健康，二手烟还对他人造成影响</p>\n</blockquote>\n<p>这话表面看起来停客观公正的，但事实隐藏了一个假设：健康比吸烟的自由更重要。所以我们为了人们的健康，可以剥夺他们的选择自由。这时候你又会怎么想呢？</p>\n<p>我们会以为别人说的信息就是全部，基于这些信息作判断，而没有发现对方可能隐藏了一些“看不见的”前提假设。眼见不一定为实，“看不见的”可能比“看得见的”更加重要。</p>\n</li>\n<li><h3 id=\"简单归因\"><a href=\"#简单归因\" class=\"headerlink\" title=\"简单归因\"></a>简单归因</h3><p>我们试图用很简单的方式去解释一个复杂的现象或事物。看到穷人觉得他懒，看到大龄单身女青年就觉得她挑。这些也会阻碍我们独立了思考。</p>\n</li>\n</ol>\n<h2 id=\"如何破除误区\"><a href=\"#如何破除误区\" class=\"headerlink\" title=\"如何破除误区\"></a>如何破除误区</h2><ol>\n<li><h3 id=\"找出讨论对象\"><a href=\"#找出讨论对象\" class=\"headerlink\" title=\"找出讨论对象\"></a>找出讨论对象</h3><ol>\n<li>这讨论的是什么</li>\n<li>对方想让我相信什么</li>\n<li>对方怎么证明他是对的</li>\n</ol>\n</li>\n<li><h3 id=\"检验证据效力\"><a href=\"#检验证据效力\" class=\"headerlink\" title=\"检验证据效力\"></a>检验证据效力</h3><p>对于接收到的所有信息，我们要有意识地甄别是不是有可靠的证据</p>\n</li>\n<li><h3 id=\"发现隐藏假设\"><a href=\"#发现隐藏假设\" class=\"headerlink\" title=\"发现隐藏假设\"></a>发现隐藏假设</h3><p>想想对方在什么语境说这些话，有没有隐藏一些前提假设，企图影响你的判断。（看到作者的真实的价值取向）。</p>\n<p>破除“眼见为实”的误区，除了看到那些看得见的理由之外，还要去推敲背后看不见的假设是什么</p>\n</li>\n<li><h3 id=\"提防逻辑谬误\"><a href=\"#提防逻辑谬误\" class=\"headerlink\" title=\"提防逻辑谬误\"></a>提防逻辑谬误</h3><p>如果想要减少被带偏，我们需要检验结论和理由之间是否存在合理的逻辑关系，并且多认识一些常见的逻辑谬误。</p>\n</li>\n</ol>\n<h2 id=\"现有的误区\"><a href=\"#现有的误区\" class=\"headerlink\" title=\"现有的误区\"></a>现有的误区</h2><ul>\n<li>盲从信息：权威说的话并不一定可信或真实。</li>\n<li>眼见为实</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"四种常见思维误区\"><a href=\"#四种常见思维误区\" class=\"headerlink\" title=\"四种常见思维误区\"></a>四种常见思维误区</h2><ol>\n<li><h3 id=\"自我为中心\"><a href=\"#自我为中心\" class=\"headerlink\" title=\"自我为中心\"></a>自我为中心</h3><blockquote>\n<p>你看到一篇文章，是一位老板写的，说他的实习生竟然拒绝帮自己拿外卖，你的第一反应是什么？</p>\n</blockquote>\n</li>\n</ol>\n<p>   由于个人成长经历、社会环境、教育背景等影响，我们在感知信息的时候，容易选择性的关注那些我们关心的信息，而自动忽略其他相反的信息。——选择性知觉</p>\n<p>   <strong>破除：真正去关心真相到底是什么</strong></p>\n<ol start=\"2\">\n<li><h3 id=\"盲从信息\"><a href=\"#盲从信息\" class=\"headerlink\" title=\"盲从信息\"></a>盲从信息</h3><blockquote>\n<p>佳洁士等牙膏广告上，都会标注“经全国牙防组认证”这几个字，借此认证，迅速获取消费者信任。然后10多年后被曝，牙防组根本不是什么认证的权威机构。</p>\n</blockquote>\n<p>当今信息爆炸时代，媒体未来吸引观众注意力，往往把信息尽可能低幼化、情绪化、直觉化。以便观众容易接受，导致我们对接受到的信息缺乏甄别能力，总是一味的吸收。这种盲从导致我们无法独立思考。</p>\n</li>\n<li><h3 id=\"眼见为实\"><a href=\"#眼见为实\" class=\"headerlink\" title=\"眼见为实\"></a>眼见为实</h3><blockquote>\n<p>政府应该禁止香烟买卖，我的理由是：吸烟危害吸烟者健康，二手烟还对他人造成影响</p>\n</blockquote>\n<p>这话表面看起来停客观公正的，但事实隐藏了一个假设：健康比吸烟的自由更重要。所以我们为了人们的健康，可以剥夺他们的选择自由。这时候你又会怎么想呢？</p>\n<p>我们会以为别人说的信息就是全部，基于这些信息作判断，而没有发现对方可能隐藏了一些“看不见的”前提假设。眼见不一定为实，“看不见的”可能比“看得见的”更加重要。</p>\n</li>\n<li><h3 id=\"简单归因\"><a href=\"#简单归因\" class=\"headerlink\" title=\"简单归因\"></a>简单归因</h3><p>我们试图用很简单的方式去解释一个复杂的现象或事物。看到穷人觉得他懒，看到大龄单身女青年就觉得她挑。这些也会阻碍我们独立了思考。</p>\n</li>\n</ol>\n<h2 id=\"如何破除误区\"><a href=\"#如何破除误区\" class=\"headerlink\" title=\"如何破除误区\"></a>如何破除误区</h2><ol>\n<li><h3 id=\"找出讨论对象\"><a href=\"#找出讨论对象\" class=\"headerlink\" title=\"找出讨论对象\"></a>找出讨论对象</h3><ol>\n<li>这讨论的是什么</li>\n<li>对方想让我相信什么</li>\n<li>对方怎么证明他是对的</li>\n</ol>\n</li>\n<li><h3 id=\"检验证据效力\"><a href=\"#检验证据效力\" class=\"headerlink\" title=\"检验证据效力\"></a>检验证据效力</h3><p>对于接收到的所有信息，我们要有意识地甄别是不是有可靠的证据</p>\n</li>\n<li><h3 id=\"发现隐藏假设\"><a href=\"#发现隐藏假设\" class=\"headerlink\" title=\"发现隐藏假设\"></a>发现隐藏假设</h3><p>想想对方在什么语境说这些话，有没有隐藏一些前提假设，企图影响你的判断。（看到作者的真实的价值取向）。</p>\n<p>破除“眼见为实”的误区，除了看到那些看得见的理由之外，还要去推敲背后看不见的假设是什么</p>\n</li>\n<li><h3 id=\"提防逻辑谬误\"><a href=\"#提防逻辑谬误\" class=\"headerlink\" title=\"提防逻辑谬误\"></a>提防逻辑谬误</h3><p>如果想要减少被带偏，我们需要检验结论和理由之间是否存在合理的逻辑关系，并且多认识一些常见的逻辑谬误。</p>\n</li>\n</ol>\n<h2 id=\"现有的误区\"><a href=\"#现有的误区\" class=\"headerlink\" title=\"现有的误区\"></a>现有的误区</h2><ul>\n<li>盲从信息：权威说的话并不一定可信或真实。</li>\n<li>眼见为实</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}