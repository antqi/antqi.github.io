## 原型 Prototype

- **我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`**

  这个属性对应着一个对象，这个对象就是我们所谓的原型

- **如果函数作为一个普通函数调用`prototype`没有任何作用**

- **当函数以构造函数形式调用时，它所创建的对象会有一个隐含的属性`__proto__`** 

  指向该构造函数的原型对象，我们可以用过`__proto__`访问

- **原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象**

  可以将对象中共有的内容，统一设置到原型对象中（<u>节省内存</u>）

- **当访问对象的属性方法时，会现在对象自身找，，如果有则直接使用，如果没有则回去原型对象中寻找**

``` javascript
function Person(name){
  if(name){
    this.name=name
  }
}

Person.prototype.name = '祖宗'
Person.prototype.sayName=function(){
  console.log(this.name)
}

var p1 = new Person('小花')
var p2 = new Person('小明')
var p3 = new Person()

p2.sayName=function(){
  console.log(this.name,'自己的sayName')
}
p1.sayName() // 小花
p2.sayName() // 小明 自己的sayName
p3.sayName() // 祖宗

```

```  mermaid
classDiagram
Person函数对象 --> 原型对象
Person函数对象 : name-有条件添加
通过Person类创建的对象p1 --> 原型对象
通过Person类创建的对象p2 --> 原型对象
Person函数对象 : prototype-->(0x123)
原型对象 : 内存地址(0x123)
原型对象 : sayName(){}
通过Person类创建的对象p1 : __proto__-->(0x123)
通过Person类创建的对象p1 : name=小花
通过Person类创建的对象p2 : sayName(){ 自定义}
通过Person类创建的对象p2 : name=小明
通过Person类创建的对象p2 : __proto__-->(0x123)
class 原型对象{
 		name = 祖宗
 		__proto__
}

```

