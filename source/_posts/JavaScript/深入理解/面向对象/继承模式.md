### 原型链继承

##### 套路

1. 定义父类型构造函数
2. 给父类型的原型添加方法
3. 定义子类型的构造函数
4. 创建父类型的对象赋值给子类型的原型
5. 将子类型原型的构造属性设置为子类型
6. 给子类型原型添加方法
7. 创建子类型的对象：可以调用父类型的方法

##### 关键

子类型的原型为父类型的一个实例对象

``` javascript
function Super() {
  this.type = 'Super'
}

Super.prototype.say = function () {
  console.log('Super Say')
}

function Sub() {
  this.type = 'Sub'
}

//【重点代码】创建父类型的对象赋值给子类型的原型
// sub.__proto__=== Super.prototype
Sub.prototype = new Super()

// 将Sub的原型构造函数指向Sub
Sub.prototype.constructor = Sub

Sub.prototype.sayLoudly = function () {
  console.log('Sub Say !!!')
}

var sub = new Sub()
console.log(sub.constructor) // Super 这是不对的，正常应该指向Sub
```



### 借用构造函数继承

PS：构造函数是假的

##### 套路

1. 定义父类型构造函数
2. 定义子类型构造函数
3. 在子类型构造函数中调用父类型构造函数

##### 关键

在子类型构造函数中通用call调用父类型构造函数

```  javascript
function Super(name) {
  this.name = name
}

Super.prototype.say = function () {
  console.log('Super Say')
}

function Sub(name) {
  // 在子类型构造函数中通用super()调用父类型构造函数
  Super.call(this,name)
}

Sub.prototype.sayLoudly = function () {
  console.log('Sub Say!!!')
}

var sub = new Sub()
console.log(sub.type) // Super
sub.say() // Uncaught TypeError: sub.say is not a function
// 可不能调用父类的原型对象方法
```



### 组合继承

原型链继承+构造函数继承

```javascript
function Super(name) {
  this.name = name
}

Super.prototype.say = function () {
  console.log('Super Say')
}

function Sub(name) {
  // 在子类型构造函数中通用super()调用父类型构造函数,初始化属性
  Super.call(this,name) 
}

Sub.prototype = new Super() // 继承Super的属性/方法 
Sub.prototype.constructor = Sub // 修正constructor

Sub.prototype.sayLoudly = function () {
  console.log('Sub Say!!!')
}

var sub = new Sub()
```

