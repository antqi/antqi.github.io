### Object构造函数模式

- 创建空的Object对象，再动态的添加属性/方法

``` javascript
var person = new Obejct()
person.name = 'xiaoming'
person.age = 20
```

适合不需要批量创建的对象，但其实字面量比它更简洁

### 对象字面量

可以一条语句搞定，简单；适合不需要批量创建的对象

``` javascript
var person = {
  name : 'xiaoming'
  age : 20,
  setName:function(name){
    this.name=name
  }
}
```

虽然可以一套语句搞定对象，语法上更简洁。<u>但如果需要批量创建呢？</u>

### 工厂模式

- 通过工厂函数动态批量创建对象

``` javascript
function createDog(name,age){
  var dog = {
    name:name,
    age:age,
    say:function(){
      console.log('汪汪！')
    }
  }
  return dog
}

var dog1=createDog('柯基',2)
var dog2=createDog('二哈',3)

function createCat(name,age){
  var cat = {
    name:name,
    age:age,
    say:function(){
      console.log('喵喵~')
    }
  }
}

var cat1=createCat('布偶',5)
var cat2=createCat('折耳',7)
```

工厂模式解决了批量创建对象的问题，But看下一段代码:

``` javascript
var dog2=createDog('二哈',3)
var cat2=createCat('折耳',7)

dog2 instanceof Object // true
cat2 instanceof Object // true
```

<u>两个的类型是一样的，如果是真正的业务，我想要区分两个的类型怎么办？</u>这时候工厂模式则办不到了

### 自定义构造函数模式

- 自定义构造函数，通过`new`关键字创建对象

- 该方式创建的对象，拥有不同于Object的确定的类型

``` javascript
function Dog(name,age){
  this.name = name
  this.age	= age
  this.say	= function(){
    console.log('汪汪')
  }
}

function Cat(name,age){
  this.name = name
  this.age	= age
  this.say	= function(){
    console.log('喵喵')
  }
}

var dog1 = new Dog('二哈',2)
var dog2 = new Dog('柯基',3)
var cat1 = new Cat('布偶',5)
var cat2 = new Cat('折耳',7)

dog1 instanceof Dog // true
cat1 instanceof Cat // true
```

利用构造函数的方式，即可批量创建对象，对象也具备不同类型，<u>但是其中有一个say方法本质做了相同的事情，但每次都重复创建了，一个对象实例就创建一个say方法，100个对象实例就创建100个say方法。这有些浪费内存，其实只要如何将它公用起来，每次个实例用一个say方法呢？</u>

### 构造函数+原型组合模式

- 自定义构造函数初始化一般的属性，方法添加到该对象的原型对象上

``` javascript
function Dog(name,age){
  this.name = name
  this.age	= age
}

Dog.prototype.say	= function(voice){
    console.log(voice)
}

var dog1 = new Dog('二哈',2)
var dog2 = new Dog('柯基',3)
// 查看上面两个实例的原型，会发现say方法只创建了一次
```

