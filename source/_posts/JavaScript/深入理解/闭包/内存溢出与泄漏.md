> **虽然延长了声明周期，但某一些情况下，这也是缺点**

### 闭包缺点

- 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
- 容易造成内存泄漏



### 如何解决

- 能不用闭包就不用

- 及时释放  设置为null

  ``` javascript
  function fn1(){
    var arr = new  Array[10000000]
    function fn2(){
      console.log(arr.length)
    }
    return fn2
  }
  
  var f = fn1()
  f()
  
  // 及时释放。让内部函数成为垃圾对象==》被自动回收
  f = null
  ```

  

### 概念

#### 内存溢出

``` javascript
var bigBigObj = {}

for(var i=0; i<10000 ; i++){
  bigBigObj[i] = new Array[10000000]
}
```



> 内存使用超过最大限额

- 一种程序运行出现的错误
- 当程序运行需要的内存超过了剩余的内存时，就会跑出内存溢出的错误

#### 内存泄漏  

> 占用的内存没有及时释放

- 占用的内存没有及时释放
- 内存泄漏积累多了就容易导致内存溢出
- 没有及时清理的计时器或回调函数
- 闭包



### QA

1. ``` javascript
   var name = 'window'
   var obj = {
     name:'object',
     getNameFunc:function(){
       return function(){
         return this.name
       }
     }
   }
   
   console.log(obj.getNameFunc()()) // window; obj.getNameFunc()返回的一个函数，函数直接在window环境执行。
   ```

2. ``` javascript
   var name2 = 'window'
   var obj2 = {
     name2:'object',
     getNameFunc:function(){
       var that = this
       return function(){
         return that.name2
       }
     }
   }
   
   console.log(obj2.getNameFunc()()) // object
   ```

3. ``` javascript
   function fun(n,o){ 
     console.log(o) 
     return {
       fun:function(m){
         return fun(m,n) 
       }
     }
   }
   
   var a = fun(0) //undefined 
   a.fun(1) // 0 (执行环境是window)
   a.fun(2) // 0 (执行环境是window)
   a.fun(3) // 0 (执行环境是window)
   
   var b = fun(0).fun(1).fun(2).fun(3) 
   // undefined 
   // 0 (执行环境是fun,表示在闭包中)
   // 1 (执行环境是fun,表示在闭包中)
   // 2 (执行环境是fun,表示在闭包中)
   
   var c = fun(0).fun(1) // undefined 0 (执行环境是fun,表示在闭包中)
   c.fun(2) // undefined 0 (执行环境是window)
   c.fun(3) // undefined 0 (执行环境是window)
   ```

   



