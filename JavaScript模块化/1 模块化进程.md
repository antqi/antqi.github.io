## 什么是模块化

#### 什么是模块

将一个复杂的程序，依据一定的规则（规范，业务、功能等等）封装成几个块（文件），并进行组合在一起

块内部数据/实现是私有的，对外暴露一些方法（API）供其他模块调用（通信）

PS：设计原则，高内聚低耦合等等，主要目的为了解偶，减少单个程序的复杂性和增加可维护性。

#### 模块化的进程

##### global，全局模式

方法和变量在全局环境中，当方法越来越多的时候

- 容易造成命名冲突
- 项目难以维护管理
- 引发全局污染

``` javascript
// 全局环境
function foo(){}

function bar(){}
```

##### 简单封装：namespace 命名空间模式

- 减少了global上变量的数量
- 本质上是对象，可以直接操作变量的属性，数据是不安全的

``` javascript
// 全局环境
var APP={
  message:'Hi',
  foo:function(){},
  bar:function(){
    console.log(this.message)
  }
}
```

##### 匿名闭包：IIFE模式

- 变量是私有的，除了提供方法外，不能改变

- 其他模块不能是全局的，如果需要依赖其他模块呢？

``` javascript
// 全局环境
(function(){
  let message='Hi';
  
  function foo(){
    console.log(message)
  }
  
  window.foo=foo
})()
```

##### IIFE模式plus：引入依赖

- 解决依赖其他模块问题

``` javascript
// 全局环境
(function(env,$){
  let message='Hi';
  
  function getEleById(id){
   	return $(id)
  }
  
  env.getEleById=getEleById
})(window,jQuery)
```



## 为什么要模块化

- **解偶，提高可维护性**

  比如：弹窗功能，负责弹窗显示信息，支付模块负责接收订单信息并计算，不需要显示信息。

  如此，弹窗错了，则维护弹窗，不需要修改其他模块信息。支付算法修改，修改支付模块，不需要去改弹窗模块。降低功能间的耦合度，提高代码可维护性

- **减少单个模块的复杂度**

  一个表单具备收集信息、验证信息以及提交信息道服务器功能。

  而这里可以再此拆解出：收集信息模块、验证信息模块、以及提交信息。

  如此，当验证条件有变化的时候，我只需要去修改验证模块。减少整个表单开发的复杂度。

  清晰的归类模块化，减少程序的复杂度。

- **便于部署，减少HTTP请求响应**

  比如纯粹的列表信息显示，完全没必要引入支付模块



## 模块化的利弊

> **模块化解决了一些代码层面的问题，但也带来了模块管理问题**

#### 利

- 避免命名冲突-（避免命名空间污染）
- 降低代码耦合度，提高可维护性
- 复用性强
- 更好的分类，利于按需加载，减少不必要的HTTP请求响应

#### 弊

``` html
<script src="a.js"></script>
<script src="b.js"></script>
<!-- ... 
	如果这里有若干个script ，必然会导致HTTP请求响应数过多，从而导致加载渲染时阻塞，影响网页体验
--> 
<script>
  // 模块化解决了变量私有，可引入依赖的问题
  /*
    这里有两个问题(b依赖a )
      - 如果a和b调换顺序呢
      - 在上面的基础上，这里有多大20个模块，并且存在依赖关系的时候呢？
        这就导致了依赖模糊
   */
</script>
```



- 请求多

  模块拆解导致原有一个文件，变成了多个文件

- 依赖的模块很多，导致依赖模糊

  依赖顺序模糊，容易出错

- 难以维护

  过多的模块以及模糊的依赖，导致模块化变的难以维护



> **如何解决模块化带来的弊：<u>规范模块化</u>**

